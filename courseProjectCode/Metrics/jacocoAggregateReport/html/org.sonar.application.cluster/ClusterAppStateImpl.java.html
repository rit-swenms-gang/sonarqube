<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClusterAppStateImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.application.cluster</a> &gt; <span class="el_source">ClusterAppStateImpl.java</span></div><h1>ClusterAppStateImpl.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.application.cluster;

import com.hazelcast.cluster.Member;
import com.hazelcast.cluster.MembershipAdapter;
import com.hazelcast.cluster.MembershipEvent;
import com.hazelcast.core.EntryAdapter;
import com.hazelcast.core.EntryEvent;
import com.hazelcast.core.HazelcastInstanceNotActiveException;
import com.hazelcast.replicatedmap.ReplicatedMap;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import org.elasticsearch.ElasticsearchException;
import org.elasticsearch.cluster.health.ClusterHealthStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.application.AppStateListener;
import org.sonar.application.cluster.health.HealthStateSharing;
import org.sonar.application.cluster.health.HealthStateSharingImpl;
import org.sonar.application.cluster.health.SearchNodeHealthProvider;
import org.sonar.application.config.AppSettings;
import org.sonar.application.config.ClusterSettings;
import org.sonar.application.es.EsConnector;
import org.sonar.process.MessageException;
import org.sonar.process.NetworkUtilsImpl;
import org.sonar.process.ProcessId;
import org.sonar.process.cluster.hz.DistributedReference;
import org.sonar.process.cluster.hz.HazelcastMember;

import static java.lang.String.format;
import static org.sonar.process.cluster.hz.HazelcastObjects.CLUSTER_NAME;
import static org.sonar.process.cluster.hz.HazelcastObjects.LEADER;
import static org.sonar.process.cluster.hz.HazelcastObjects.OPERATIONAL_PROCESSES;
import static org.sonar.process.cluster.hz.HazelcastObjects.SONARQUBE_VERSION;

public class ClusterAppStateImpl implements ClusterAppState {

<span class="fc" id="L61">  private static final Logger LOGGER = LoggerFactory.getLogger(ClusterAppStateImpl.class);</span>

  private final HazelcastMember hzMember;
<span class="fc" id="L64">  private final List&lt;AppStateListener&gt; listeners = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L65">  private final Map&lt;ProcessId, Boolean&gt; operationalLocalProcesses = new EnumMap&lt;&gt;(ProcessId.class);</span>
<span class="fc" id="L66">  private final AtomicBoolean esPoolingThreadRunning = new AtomicBoolean(false);</span>
  private final ReplicatedMap&lt;ClusterProcess, Boolean&gt; operationalProcesses;
  private final UUID operationalProcessListenerUUID;
  private final UUID nodeDisconnectedListenerUUID;
  private final EsConnector esConnector;

<span class="fc" id="L72">  private HealthStateSharing healthStateSharing = null;</span>

<span class="fc" id="L74">  public ClusterAppStateImpl(AppSettings settings, HazelcastMember hzMember, EsConnector esConnector, AppNodesClusterHostsConsistency appNodesClusterHostsConsistency) {</span>
<span class="fc" id="L75">    this.hzMember = hzMember;</span>

    // Get or create the replicated map
<span class="fc" id="L78">    operationalProcesses = (ReplicatedMap) hzMember.getReplicatedMap(OPERATIONAL_PROCESSES);</span>
<span class="fc" id="L79">    operationalProcessListenerUUID = operationalProcesses.addEntryListener(new OperationalProcessListener());</span>
<span class="fc" id="L80">    nodeDisconnectedListenerUUID = hzMember.getCluster().addMembershipListener(new NodeDisconnectedListener());</span>
<span class="fc" id="L81">    appNodesClusterHostsConsistency.check();</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">    if (ClusterSettings.isLocalElasticsearchEnabled(settings)) {</span>
<span class="fc" id="L83">      this.healthStateSharing = new HealthStateSharingImpl(hzMember, new SearchNodeHealthProvider(settings.getProps(), this, NetworkUtilsImpl.INSTANCE));</span>
<span class="fc" id="L84">      this.healthStateSharing.start();</span>
    }

<span class="fc" id="L87">    this.esConnector = esConnector;</span>
<span class="fc" id="L88">  }</span>

  @Override
  public HazelcastMember getHazelcastMember() {
<span class="fc" id="L92">    return hzMember;</span>
  }

  @Override
  public void addListener(AppStateListener listener) {
<span class="fc" id="L97">    listeners.add(listener);</span>
<span class="fc" id="L98">  }</span>

  @Override
  public boolean isOperational(ProcessId processId, boolean local) {
<span class="fc bfc" id="L102" title="All 2 branches covered.">    if (local) {</span>
<span class="fc" id="L103">      return operationalLocalProcesses.computeIfAbsent(processId, p -&gt; false);</span>
    }

<span class="pc bpc" id="L106" title="1 of 2 branches missed.">    if (processId.equals(ProcessId.ELASTICSEARCH)) {</span>
<span class="fc" id="L107">      boolean operational = isElasticSearchOperational();</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">      if (!operational) {</span>
<span class="fc" id="L109">        asyncWaitForEsToBecomeOperational();</span>
      }
<span class="fc" id="L111">      return operational;</span>
    }

<span class="nc bnc" id="L114" title="All 2 branches missed.">    for (Map.Entry&lt;ClusterProcess, Boolean&gt; entry : operationalProcesses.entrySet()) {</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">      if (entry.getKey().getProcessId().equals(processId) &amp;&amp; entry.getValue()) {</span>
<span class="nc" id="L116">        return true;</span>
      }
<span class="nc" id="L118">    }</span>
<span class="nc" id="L119">    return false;</span>
  }

  @Override
  public void setOperational(ProcessId processId) {
<span class="fc" id="L124">    operationalLocalProcesses.put(processId, true);</span>
<span class="fc" id="L125">    operationalProcesses.put(new ClusterProcess(hzMember.getUuid(), processId), Boolean.TRUE);</span>
<span class="fc" id="L126">  }</span>

  @Override
  public boolean tryToLockWebLeader() {
<span class="fc" id="L130">    DistributedReference&lt;UUID&gt; leader = hzMember.getAtomicReference(LEADER);</span>
<span class="fc" id="L131">    return leader.compareAndSet(null, hzMember.getUuid());</span>
  }

  @Override
  public void tryToReleaseWebLeaderLock() {
<span class="fc" id="L136">    tryToReleaseWebLeaderLock(hzMember.getUuid());</span>
<span class="fc" id="L137">  }</span>

  /**
   * Tries to release the lock of the cluster leader. It is safe to call this method even if one is not sure about the UUID of the leader.
   * If all nodes call this method then we can be confident that the lock is released.
   *
   * @param uuidOfLeader - the UUID of the leader to release the lock. In case the UUID is not the leader's uuid this method has no effect.
   */
  private void tryToReleaseWebLeaderLock(UUID uuidOfLeader) {
<span class="fc" id="L146">    DistributedReference&lt;UUID&gt; leader = hzMember.getAtomicReference(LEADER);</span>
<span class="fc" id="L147">    leader.compareAndSet(uuidOfLeader, null);</span>
<span class="fc" id="L148">  }</span>

  @Override
  public void reset() {
<span class="fc" id="L152">    throw new IllegalStateException(&quot;state reset is not supported in cluster mode&quot;);</span>
  }

  @Override
  public void registerSonarQubeVersion(String sonarqubeVersion) {
<span class="fc" id="L157">    DistributedReference&lt;String&gt; sqVersion = hzMember.getAtomicReference(SONARQUBE_VERSION);</span>
<span class="fc" id="L158">    boolean wasSet = sqVersion.compareAndSet(null, sonarqubeVersion);</span>

<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (!wasSet) {</span>
<span class="fc" id="L161">      String clusterVersion = sqVersion.get();</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">      if (!sqVersion.get().equals(sonarqubeVersion)) {</span>
<span class="fc" id="L163">        throw new IllegalStateException(</span>
<span class="fc" id="L164">          format(&quot;The local version %s is not the same as the cluster %s&quot;, sonarqubeVersion, clusterVersion));</span>
      }
    }
<span class="fc" id="L167">  }</span>

  @Override
  public void registerClusterName(String clusterName) {
<span class="fc" id="L171">    DistributedReference&lt;String&gt; property = hzMember.getAtomicReference(CLUSTER_NAME);</span>
<span class="fc" id="L172">    boolean wasSet = property.compareAndSet(null, clusterName);</span>

<span class="fc bfc" id="L174" title="All 2 branches covered.">    if (!wasSet) {</span>
<span class="fc" id="L175">      String clusterValue = property.get();</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">      if (!property.get().equals(clusterName)) {</span>
<span class="fc" id="L177">        throw new MessageException(</span>
<span class="fc" id="L178">          format(&quot;This node has a cluster name [%s], which does not match [%s] from the cluster&quot;, clusterName, clusterValue));</span>
      }
    }
<span class="fc" id="L181">  }</span>

  @Override
  public Optional&lt;String&gt; getLeaderHostName() {
<span class="fc" id="L185">    UUID leaderUuid = (UUID) hzMember.getAtomicReference(LEADER).get();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">    if (leaderUuid != null) {</span>
<span class="fc" id="L187">      Optional&lt;Member&gt; leader = hzMember.getCluster().getMembers().stream().filter(m -&gt; m.getUuid().equals(leaderUuid)).findFirst();</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">      if (leader.isPresent()) {</span>
<span class="fc" id="L189">        return Optional.of(leader.get().getAddress().getHost());</span>
      }
    }
<span class="fc" id="L192">    return Optional.empty();</span>
  }

  @Override
  public void close() {
<span class="fc" id="L197">    esConnector.stop();</span>

<span class="pc bpc" id="L199" title="1 of 2 branches missed.">    if (hzMember != null) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">      if (healthStateSharing != null) {</span>
<span class="fc" id="L201">        healthStateSharing.stop();</span>
      }
      try {
        // Removing listeners
<span class="fc" id="L205">        operationalProcesses.removeEntryListener(operationalProcessListenerUUID);</span>
<span class="fc" id="L206">        hzMember.getCluster().removeMembershipListener(nodeDisconnectedListenerUUID);</span>

        // Removing the operationalProcess from the replicated map
<span class="fc" id="L209">        operationalProcesses.keySet().forEach(</span>
          clusterNodeProcess -&gt; {
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (clusterNodeProcess.getNodeUuid().equals(hzMember.getUuid())) {</span>
<span class="fc" id="L212">              operationalProcesses.remove(clusterNodeProcess);</span>
            }
<span class="fc" id="L214">          });</span>

        // Shutdown Hazelcast properly
<span class="fc" id="L217">        hzMember.close();</span>
<span class="nc" id="L218">      } catch (HazelcastInstanceNotActiveException e) {</span>
        // hazelcastCluster may be already closed by the shutdown hook
<span class="nc" id="L220">        LOGGER.debug(&quot;Unable to close Hazelcast cluster&quot;, e);</span>
<span class="fc" id="L221">      }</span>
    }
<span class="fc" id="L223">  }</span>

  private boolean isElasticSearchOperational() {
    try {
<span class="fc" id="L227">      return esConnector.getClusterHealthStatus()</span>
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">        .filter(t -&gt; ClusterHealthStatus.GREEN.equals(t) || ClusterHealthStatus.YELLOW.equals(t))</span>
<span class="fc" id="L229">        .isPresent();</span>
<span class="fc" id="L230">    } catch (ElasticsearchException e) {</span>
<span class="fc" id="L231">      LOGGER.warn(&quot;Cannot check at current time whether Elasticsearch is operational&quot;, e);</span>
<span class="fc" id="L232">      return false;</span>
    }
  }

  private void asyncWaitForEsToBecomeOperational() {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (esPoolingThreadRunning.compareAndSet(false, true)) {</span>
<span class="fc" id="L238">      Thread thread = new EsPoolingThread();</span>
<span class="fc" id="L239">      thread.start();</span>
    }
<span class="fc" id="L241">  }</span>

  private class EsPoolingThread extends Thread {
<span class="fc" id="L244">    private EsPoolingThread() {</span>
<span class="fc" id="L245">      super(&quot;es-state-pooling&quot;);</span>
<span class="fc" id="L246">      this.setDaemon(true);</span>
<span class="fc" id="L247">    }</span>

    @Override
    public void run() {
      while (true) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (isElasticSearchOperational()) {</span>
<span class="fc" id="L253">          esPoolingThreadRunning.set(false);</span>
<span class="fc" id="L254">          listeners.forEach(l -&gt; l.onAppStateOperational(ProcessId.ELASTICSEARCH));</span>
<span class="fc" id="L255">          return;</span>
        }

        try {
<span class="fc" id="L259">          Thread.sleep(5_000);</span>
<span class="nc" id="L260">        } catch (InterruptedException e) {</span>
<span class="nc" id="L261">          esPoolingThreadRunning.set(false);</span>
<span class="nc" id="L262">          Thread.currentThread().interrupt();</span>
<span class="nc" id="L263">          return;</span>
<span class="fc" id="L264">        }</span>
      }
    }
  }

<span class="fc" id="L269">  private class OperationalProcessListener extends EntryAdapter&lt;ClusterProcess, Boolean&gt; {</span>
    @Override
    public void entryAdded(EntryEvent&lt;ClusterProcess, Boolean&gt; event) {
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">      if (event.getValue()) {</span>
<span class="fc" id="L273">        listeners.forEach(appStateListener -&gt; appStateListener.onAppStateOperational(event.getKey().getProcessId()));</span>
      }
<span class="fc" id="L275">    }</span>

    @Override
    public void entryUpdated(EntryEvent&lt;ClusterProcess, Boolean&gt; event) {
<span class="nc bnc" id="L279" title="All 2 branches missed.">      if (event.getValue()) {</span>
<span class="nc" id="L280">        listeners.forEach(appStateListener -&gt; appStateListener.onAppStateOperational(event.getKey().getProcessId()));</span>
      }
<span class="nc" id="L282">    }</span>
  }

<span class="fc" id="L285">  private class NodeDisconnectedListener extends MembershipAdapter {</span>
    @Override
    public void memberRemoved(MembershipEvent membershipEvent) {
<span class="nc" id="L288">      removeOperationalProcess(membershipEvent.getMember().getUuid());</span>
<span class="nc" id="L289">    }</span>

    private void removeOperationalProcess(UUID uuid) {
<span class="nc" id="L292">      tryToReleaseWebLeaderLock(uuid);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">      for (ClusterProcess clusterProcess : operationalProcesses.keySet()) {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (clusterProcess.getNodeUuid().equals(uuid)) {</span>
<span class="nc" id="L295">          LOGGER.debug(&quot;Set node process off for [{}:{}] : &quot;, clusterProcess.getNodeUuid(), clusterProcess.getProcessId());</span>
<span class="nc" id="L296">          hzMember.getReplicatedMap(OPERATIONAL_PROCESSES).put(clusterProcess, Boolean.FALSE);</span>
        }
<span class="nc" id="L298">      }</span>
<span class="nc" id="L299">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>