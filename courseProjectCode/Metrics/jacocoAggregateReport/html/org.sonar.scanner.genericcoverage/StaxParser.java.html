<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StaxParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.scanner.genericcoverage</a> &gt; <span class="el_source">StaxParser.java</span></div><h1>StaxParser.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.scanner.genericcoverage;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.net.URL;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLResolver;
import javax.xml.stream.XMLStreamException;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.staxmate.SMInputFactory;
import org.codehaus.staxmate.in.SMHierarchicCursor;

public class StaxParser {

  private SMInputFactory inf;
  private XmlStreamHandler streamHandler;
  private boolean isoControlCharsAwareParser;

  /**
   * Stax parser for a given stream handler and iso control chars set awarness to off
   *
   * @param streamHandler the xml stream handler
   */
  public StaxParser(XmlStreamHandler streamHandler) {
<span class="fc" id="L49">    this(streamHandler, false);</span>
<span class="fc" id="L50">  }</span>

  /**
   * Stax parser for a given stream handler and iso control chars set awarness to on.
   * The iso control chars in the xml file will be replaced by simple spaces, usefull for
   * potentially bogus XML files to parse, this has a small perfs overhead so use it only when necessary
   *
   * @param streamHandler              the xml stream handler
   * @param isoControlCharsAwareParser true or false
   */
<span class="fc" id="L60">  public StaxParser(XmlStreamHandler streamHandler, boolean isoControlCharsAwareParser) {</span>
<span class="fc" id="L61">    this.streamHandler = streamHandler;</span>
<span class="fc" id="L62">    XMLInputFactory xmlFactory = XMLInputFactory.newInstance();</span>
<span class="fc" id="L63">    xmlFactory.setProperty(XMLInputFactory.IS_VALIDATING, false);</span>
<span class="fc" id="L64">    xmlFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);</span>
<span class="fc" id="L65">    xmlFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, false);</span>
<span class="fc" id="L66">    this.isoControlCharsAwareParser = isoControlCharsAwareParser;</span>
<span class="fc" id="L67">    inf = new SMInputFactory(xmlFactory);</span>
<span class="fc" id="L68">  }</span>

  public void parse(File xmlFile) throws XMLStreamException {
<span class="nc" id="L71">    FileInputStream input = null;</span>
    try {
<span class="nc" id="L73">      input = new FileInputStream(xmlFile);</span>
<span class="nc" id="L74">      parse(input);</span>
<span class="nc" id="L75">    } catch (FileNotFoundException e) {</span>
<span class="nc" id="L76">      throw new XMLStreamException(e);</span>
    } finally {
<span class="nc" id="L78">      IOUtils.closeQuietly(input);</span>
    }
<span class="nc" id="L80">  }</span>

  public void parse(InputStream xmlInput) throws XMLStreamException {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">    xmlInput = isoControlCharsAwareParser ? new ISOControlCharAwareInputStream(xmlInput) : xmlInput;</span>
<span class="fc" id="L84">    parse(inf.rootElementCursor(xmlInput));</span>
<span class="fc" id="L85">  }</span>

  public void parse(Reader xmlReader) throws XMLStreamException {
<span class="nc bnc" id="L88" title="All 2 branches missed.">    if (isoControlCharsAwareParser) {</span>
<span class="nc" id="L89">      throw new IllegalStateException(&quot;Method call not supported when isoControlCharsAwareParser=true&quot;);</span>
    }
<span class="nc" id="L91">    parse(inf.rootElementCursor(xmlReader));</span>
<span class="nc" id="L92">  }</span>

  public void parse(URL xmlUrl) throws XMLStreamException {
    try {
<span class="nc" id="L96">      parse(xmlUrl.openStream());</span>
<span class="nc" id="L97">    } catch (IOException e) {</span>
<span class="nc" id="L98">      throw new XMLStreamException(e);</span>
<span class="nc" id="L99">    }</span>
<span class="nc" id="L100">  }</span>

  private void parse(SMHierarchicCursor rootCursor) throws XMLStreamException {
    try {
<span class="fc" id="L104">      streamHandler.stream(rootCursor);</span>
    } finally {
<span class="fc" id="L106">      rootCursor.getStreamReader().closeCompletely();</span>
    }
<span class="fc" id="L108">  }</span>

  private static class UndeclaredEntitiesXMLResolver implements XMLResolver {
    @Override
    public Object resolveEntity(String arg0, String arg1, String fileName, String undeclaredEntity) throws XMLStreamException {
      // avoid problems with XML docs containing undeclared entities.. return the entity under its raw form if not an unicode expression
<span class="nc bnc" id="L114" title="All 4 branches missed.">      if (StringUtils.startsWithIgnoreCase(undeclaredEntity, &quot;u&quot;) &amp;&amp; undeclaredEntity.length() == 5) {</span>
<span class="nc" id="L115">        int unicodeCharHexValue = Integer.parseInt(undeclaredEntity.substring(1), 16);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (Character.isDefined(unicodeCharHexValue)) {</span>
<span class="nc" id="L117">          undeclaredEntity = new String(new char[] {(char) unicodeCharHexValue});</span>
        }
      }
<span class="nc" id="L120">      return undeclaredEntity;</span>
    }
  }

  /**
   * Simple interface for handling XML stream to parse
   */
  public interface XmlStreamHandler {
    void stream(SMHierarchicCursor rootCursor) throws XMLStreamException;
  }

  private static class ISOControlCharAwareInputStream extends InputStream {

    private InputStream inputToCheck;

    public ISOControlCharAwareInputStream(InputStream inputToCheck) {
<span class="nc" id="L136">      super();</span>
<span class="nc" id="L137">      this.inputToCheck = inputToCheck;</span>
<span class="nc" id="L138">    }</span>

    @Override
    public int read() throws IOException {
<span class="nc" id="L142">      return inputToCheck.read();</span>
    }

    @Override
    public int available() throws IOException {
<span class="nc" id="L147">      return inputToCheck.available();</span>
    }

    @Override
    public void close() throws IOException {
<span class="nc" id="L152">      inputToCheck.close();</span>
<span class="nc" id="L153">    }</span>

    @Override
    public synchronized void mark(int readlimit) {
<span class="nc" id="L157">      inputToCheck.mark(readlimit);</span>
<span class="nc" id="L158">    }</span>

    @Override
    public boolean markSupported() {
<span class="nc" id="L162">      return inputToCheck.markSupported();</span>
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
<span class="nc" id="L167">      int readen = inputToCheck.read(b, off, len);</span>
<span class="nc" id="L168">      checkBufferForISOControlChars(b, off, len);</span>
<span class="nc" id="L169">      return readen;</span>
    }

    @Override
    public int read(byte[] b) throws IOException {
<span class="nc" id="L174">      int readen = inputToCheck.read(b);</span>
<span class="nc" id="L175">      checkBufferForISOControlChars(b, 0, readen);</span>
<span class="nc" id="L176">      return readen;</span>
    }

    @Override
    public synchronized void reset() throws IOException {
<span class="nc" id="L181">      inputToCheck.reset();</span>
<span class="nc" id="L182">    }</span>

    @Override
    public long skip(long n) throws IOException {
<span class="nc" id="L186">      return inputToCheck.skip(n);</span>
    }

    private static void checkBufferForISOControlChars(byte[] buffer, int off, int len) {
<span class="nc bnc" id="L190" title="All 2 branches missed.">      for (int i = off; i &lt; len; i++) {</span>
<span class="nc" id="L191">        char streamChar = (char) buffer[i];</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">        if (Character.isISOControl(streamChar) &amp;&amp; streamChar != '\n') {</span>
          // replace control chars by a simple space
<span class="nc" id="L194">          buffer[i] = ' ';</span>
        }
      }
<span class="nc" id="L197">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>