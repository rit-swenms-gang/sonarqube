<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GroupService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.common.group.service</a> &gt; <span class="el_source">GroupService.java</span></div><h1>GroupService.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.common.group.service;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.api.security.DefaultGroups;
import org.sonar.api.server.ServerSide;
import org.sonar.api.user.UserGroupValidation;
import org.sonar.core.util.UuidFactory;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.permission.GlobalPermission;
import org.sonar.db.user.GroupDto;
import org.sonar.db.user.GroupQuery;
import org.sonar.server.common.SearchResults;
import org.sonar.server.exceptions.BadRequestException;
import org.sonar.server.management.ManagedInstanceService;
import org.sonar.server.usergroups.DefaultGroupFinder;

import static com.google.common.base.Preconditions.checkArgument;
import static java.lang.Boolean.TRUE;
import static org.sonar.server.exceptions.BadRequestException.checkRequest;

@ServerSide
public class GroupService {

  private final DbClient dbClient;
  private final UuidFactory uuidFactory;

  private final DefaultGroupFinder defaultGroupFinder;
  private final ManagedInstanceService managedInstanceService;

<span class="fc" id="L55">  public GroupService(DbClient dbClient, UuidFactory uuidFactory, DefaultGroupFinder defaultGroupFinder, ManagedInstanceService managedInstanceService) {</span>
<span class="fc" id="L56">    this.dbClient = dbClient;</span>
<span class="fc" id="L57">    this.uuidFactory = uuidFactory;</span>
<span class="fc" id="L58">    this.defaultGroupFinder = defaultGroupFinder;</span>
<span class="fc" id="L59">    this.managedInstanceService = managedInstanceService;</span>
<span class="fc" id="L60">  }</span>

  public Optional&lt;GroupDto&gt; findGroup(DbSession dbSession, String groupName) {
<span class="fc" id="L63">    return dbClient.groupDao().selectByName(dbSession, groupName);</span>
  }

  public Optional&lt;GroupInformation&gt; findGroupByUuid(DbSession dbSession, String groupUuid) {

<span class="fc" id="L68">    return Optional.ofNullable(dbClient.groupDao().selectByUuid(dbSession, groupUuid))</span>
<span class="fc" id="L69">      .map(group -&gt; groupDtoToGroupInformation(group, dbSession));</span>
  }

  public SearchResults&lt;GroupInformation&gt; search(DbSession dbSession, GroupSearchRequest groupSearchRequest) {
<span class="fc" id="L73">    GroupDto defaultGroup = defaultGroupFinder.findDefaultGroup(dbSession);</span>
<span class="fc" id="L74">    GroupQuery query = toGroupQuery(groupSearchRequest);</span>

<span class="fc" id="L76">    int limit = dbClient.groupDao().countByQuery(dbSession, query);</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">    if (groupSearchRequest.page() == 0) {</span>
<span class="fc" id="L78">      return new SearchResults&lt;&gt;(List.of(), limit);</span>
    }

<span class="fc" id="L81">    List&lt;GroupDto&gt; groups = dbClient.groupDao().selectByQuery(dbSession, query, groupSearchRequest.page(), groupSearchRequest.pageSize());</span>
<span class="fc" id="L82">    List&lt;String&gt; groupUuids = extractGroupUuids(groups);</span>
<span class="fc" id="L83">    Map&lt;String, Boolean&gt; groupUuidToIsManaged = managedInstanceService.getGroupUuidToManaged(dbSession, new HashSet&lt;&gt;(groupUuids));</span>

<span class="fc" id="L85">    List&lt;GroupInformation&gt; results = groups.stream()</span>
<span class="fc" id="L86">      .map(groupDto -&gt; toGroupInformation(groupDto, defaultGroup.getUuid(), groupUuidToIsManaged))</span>
<span class="fc" id="L87">      .toList();</span>

<span class="fc" id="L89">    return new SearchResults&lt;&gt;(results, limit);</span>
  }

  private GroupQuery toGroupQuery(GroupSearchRequest groupSearchRequest) {
<span class="fc" id="L93">    return GroupQuery.builder()</span>
<span class="fc" id="L94">      .searchText(groupSearchRequest.query())</span>
<span class="fc" id="L95">      .isManagedClause(getManagedInstanceSql(groupSearchRequest.managed()))</span>
<span class="fc" id="L96">      .userId(groupSearchRequest.userUuid())</span>
<span class="fc" id="L97">      .excludedUserId(groupSearchRequest.excludedUserUuid())</span>
<span class="fc" id="L98">      .build();</span>
  }

  @CheckForNull
  private String getManagedInstanceSql(@Nullable Boolean isManaged) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">    if (managedInstanceService.isInstanceExternallyManaged()) {</span>
<span class="fc" id="L104">      return Optional.ofNullable(isManaged)</span>
<span class="fc" id="L105">        .map(managedInstanceService::getManagedGroupsSqlFilter)</span>
<span class="fc" id="L106">        .orElse(null);</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">    } else if (TRUE.equals(isManaged)) {</span>
<span class="fc" id="L108">      throw BadRequestException.create(&quot;The 'managed' parameter is only available for managed instances.&quot;);</span>
    }
<span class="fc" id="L110">    return null;</span>
  }

  private static List&lt;String&gt; extractGroupUuids(List&lt;GroupDto&gt; groups) {
<span class="fc" id="L114">    return groups.stream().map(GroupDto::getUuid).toList();</span>
  }

  private static GroupInformation toGroupInformation(GroupDto groupDto, String defaultGroupUuid, Map&lt;String, Boolean&gt; groupUuidToIsManaged) {
<span class="fc" id="L118">    return new GroupInformation(groupDto, groupUuidToIsManaged.getOrDefault(groupDto.getUuid(), false), defaultGroupUuid.equals(groupDto.getUuid()));</span>
  }

  public void delete(DbSession dbSession, GroupDto group) {
<span class="fc" id="L122">    checkGroupIsNotDefault(dbSession, group);</span>
<span class="fc" id="L123">    checkNotTryingToDeleteLastAdminGroup(dbSession, group);</span>

<span class="fc" id="L125">    removeGroupPermissions(dbSession, group);</span>
<span class="fc" id="L126">    removeGroupFromPermissionTemplates(dbSession, group);</span>
<span class="fc" id="L127">    removeGroupMembers(dbSession, group);</span>
<span class="fc" id="L128">    removeGroupFromQualityProfileEdit(dbSession, group);</span>
<span class="fc" id="L129">    removeGroupFromQualityGateEdit(dbSession, group);</span>
<span class="fc" id="L130">    removeGroupScimLink(dbSession, group);</span>
<span class="fc" id="L131">    removeExternalGroupMapping(dbSession, group);</span>
<span class="fc" id="L132">    removeGithubOrganizationGroup(dbSession, group);</span>

<span class="fc" id="L134">    removeGroup(dbSession, group);</span>
<span class="fc" id="L135">  }</span>

  public GroupInformation updateGroup(DbSession dbSession, GroupDto group, @Nullable String newName) {
<span class="fc" id="L138">    checkGroupIsNotDefault(dbSession, group);</span>
<span class="fc" id="L139">    return groupDtoToGroupInformation(updateName(dbSession, group, newName), dbSession);</span>
  }

  public GroupInformation updateGroup(DbSession dbSession, GroupDto group, @Nullable String newName, @Nullable String newDescription) {
<span class="fc" id="L143">    checkGroupIsNotDefault(dbSession, group);</span>
<span class="fc" id="L144">    GroupDto withUpdatedName = updateName(dbSession, group, newName);</span>
<span class="fc" id="L145">    return groupDtoToGroupInformation(updateDescription(dbSession, withUpdatedName, newDescription), dbSession);</span>
  }

  public GroupInformation createGroup(DbSession dbSession, String name, @Nullable String description) {
<span class="fc" id="L149">    validateGroupName(name);</span>
<span class="fc" id="L150">    checkNameDoesNotExist(dbSession, name);</span>

<span class="fc" id="L152">    GroupDto group = new GroupDto()</span>
<span class="fc" id="L153">      .setUuid(uuidFactory.create())</span>
<span class="fc" id="L154">      .setName(name)</span>
<span class="fc" id="L155">      .setDescription(description);</span>
<span class="fc" id="L156">    return groupDtoToGroupInformation(dbClient.groupDao().insert(dbSession, group), dbSession);</span>
  }

  private GroupInformation groupDtoToGroupInformation(GroupDto groupDto, DbSession dbSession) {
<span class="fc" id="L160">    return new GroupInformation(groupDto, managedInstanceService.isGroupManaged(dbSession, groupDto.getUuid()),</span>
<span class="fc" id="L161">      defaultGroupFinder.findDefaultGroup(dbSession).getUuid().equals(groupDto.getUuid()));</span>
  }

  private GroupDto updateName(DbSession dbSession, GroupDto group, @Nullable String newName) {
<span class="fc bfc" id="L165" title="All 4 branches covered.">    if (newName != null &amp;&amp; !newName.equals(group.getName())) {</span>
<span class="fc" id="L166">      validateGroupName(newName);</span>
<span class="fc" id="L167">      checkNameDoesNotExist(dbSession, newName);</span>
<span class="fc" id="L168">      group.setName(newName);</span>
<span class="fc" id="L169">      return dbClient.groupDao().update(dbSession, group);</span>
    }
<span class="fc" id="L171">    return group;</span>
  }

  private static void validateGroupName(String name) {
    try {
<span class="fc" id="L176">      UserGroupValidation.validateGroupName(name);</span>
<span class="fc" id="L177">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L178">      BadRequestException.throwBadRequestException(e.getMessage());</span>
<span class="fc" id="L179">    }</span>
<span class="fc" id="L180">  }</span>

  private void checkNameDoesNotExist(DbSession dbSession, String name) {
    // There is no database constraint on column groups.name
    // because MySQL cannot create a unique index
    // on a UTF-8 VARCHAR larger than 255 characters on InnoDB
<span class="fc bfc" id="L186" title="All 2 branches covered.">    checkRequest(!dbClient.groupDao().selectByName(dbSession, name).isPresent(), &quot;Group '%s' already exists&quot;, name);</span>
<span class="fc" id="L187">  }</span>

  private GroupDto updateDescription(DbSession dbSession, GroupDto group, @Nullable String newDescription) {
<span class="fc bfc" id="L190" title="All 2 branches covered.">    if (newDescription != null) {</span>
<span class="fc" id="L191">      group.setDescription(newDescription);</span>
<span class="fc" id="L192">      return dbClient.groupDao().update(dbSession, group);</span>
    }
<span class="fc" id="L194">    return group;</span>
  }

  private void checkGroupIsNotDefault(DbSession dbSession, GroupDto groupDto) {
<span class="fc" id="L198">    GroupDto defaultGroup = findDefaultGroup(dbSession);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">    checkArgument(!defaultGroup.getUuid().equals(groupDto.getUuid()), &quot;Default group '%s' cannot be used to perform this action&quot;, groupDto.getName());</span>
<span class="fc" id="L200">  }</span>

  private GroupDto findDefaultGroup(DbSession dbSession) {
<span class="fc" id="L203">    return dbClient.groupDao().selectByName(dbSession, DefaultGroups.USERS)</span>
<span class="pc" id="L204">      .orElseThrow(() -&gt; new IllegalStateException(&quot;Default group cannot be found&quot;));</span>
  }

  private void checkNotTryingToDeleteLastAdminGroup(DbSession dbSession, GroupDto group) {
<span class="fc" id="L208">    int remaining = dbClient.authorizationDao().countUsersWithGlobalPermissionExcludingGroup(dbSession,</span>
<span class="fc" id="L209">      GlobalPermission.ADMINISTER.getKey(), group.getUuid());</span>

<span class="fc bfc" id="L211" title="All 2 branches covered.">    checkArgument(remaining &gt; 0, &quot;The last system admin group cannot be deleted&quot;);</span>
<span class="fc" id="L212">  }</span>

  private void removeGroupPermissions(DbSession dbSession, GroupDto group) {
<span class="fc" id="L215">    dbClient.roleDao().deleteGroupRolesByGroupUuid(dbSession, group.getUuid());</span>
<span class="fc" id="L216">  }</span>

  private void removeGroupFromPermissionTemplates(DbSession dbSession, GroupDto group) {
<span class="fc" id="L219">    dbClient.permissionTemplateDao().deleteByGroup(dbSession, group.getUuid(), group.getName());</span>
<span class="fc" id="L220">  }</span>

  private void removeGroupMembers(DbSession dbSession, GroupDto group) {
<span class="fc" id="L223">    dbClient.userGroupDao().deleteByGroupUuid(dbSession, group.getUuid(), group.getName());</span>
<span class="fc" id="L224">  }</span>

  private void removeGroupFromQualityProfileEdit(DbSession dbSession, GroupDto group) {
<span class="fc" id="L227">    dbClient.qProfileEditGroupsDao().deleteByGroup(dbSession, group);</span>
<span class="fc" id="L228">  }</span>

  private void removeGroupFromQualityGateEdit(DbSession dbSession, GroupDto group) {
<span class="fc" id="L231">    dbClient.qualityGateGroupPermissionsDao().deleteByGroup(dbSession, group);</span>
<span class="fc" id="L232">  }</span>

  private void removeGroupScimLink(DbSession dbSession, GroupDto group) {
<span class="fc" id="L235">    dbClient.scimGroupDao().deleteByGroupUuid(dbSession, group.getUuid());</span>
<span class="fc" id="L236">  }</span>

  private void removeExternalGroupMapping(DbSession dbSession, GroupDto group) {
<span class="fc" id="L239">    dbClient.externalGroupDao().deleteByGroupUuid(dbSession, group.getUuid());</span>
<span class="fc" id="L240">  }</span>

  private void removeGithubOrganizationGroup(DbSession dbSession, GroupDto group) {
<span class="fc" id="L243">    dbClient.githubOrganizationGroupDao().deleteByGroupUuid(dbSession, group.getUuid());</span>
<span class="fc" id="L244">  }</span>

  private void removeGroup(DbSession dbSession, GroupDto group) {
<span class="fc" id="L247">    dbClient.groupDao().deleteByUuid(dbSession, group.getUuid(), group.getName());</span>
<span class="fc" id="L248">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>