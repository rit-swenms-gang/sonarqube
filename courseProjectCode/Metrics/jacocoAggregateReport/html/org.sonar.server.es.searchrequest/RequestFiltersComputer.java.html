<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RequestFiltersComputer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.es.searchrequest</a> &gt; <span class="el_source">RequestFiltersComputer.java</span></div><h1>RequestFiltersComputer.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.es.searchrequest;

import com.google.common.collect.ImmutableSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiPredicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilder;
import org.sonar.server.es.searchrequest.TopAggregationDefinition.FilterScope;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.util.Objects.requireNonNull;
import static java.util.Optional.empty;
import static java.util.Optional.of;
import static org.elasticsearch.index.query.QueryBuilders.boolQuery;

/**
 * Computes filters of a given ES search request given all the filters to apply and the top-aggregations to include in
 * the request:
 * &lt;ul&gt;
 *     &lt;li&gt;the ones for the query (see {@link #computeQueryFilter(AllFiltersImpl, Map) computeQueryFilter})&lt;/li&gt;
 *     &lt;li&gt;the ones to apply as post filters (see {@link #computePostFilters(AllFiltersImpl, Set) computePostFilters})&lt;/li&gt;
 *     &lt;li&gt;the ones for each top-aggregation (see {@link #getTopAggregationFilter(TopAggregationDefinition) getTopAggregationFilter})&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * To be able to provide accurate filters, all {@link TopAggregationDefinition} instances for which
 * {@link #getTopAggregationFilter(TopAggregationDefinition)} may be called, must all be declared in the constructor.
 */
public class RequestFiltersComputer {

  private final Set&lt;TopAggregationDefinition&lt;?&gt;&gt; topAggregations;
  private final Map&lt;FilterNameAndScope, QueryBuilder&gt; postFilters;
  private final Map&lt;FilterNameAndScope, QueryBuilder&gt; queryFilters;

<span class="fc" id="L63">  public RequestFiltersComputer(AllFilters allFilters, Set&lt;TopAggregationDefinition&lt;?&gt;&gt; topAggregations) {</span>
<span class="fc" id="L64">    this.topAggregations = ImmutableSet.copyOf(topAggregations);</span>
<span class="fc" id="L65">    this.postFilters = computePostFilters((AllFiltersImpl) allFilters, topAggregations);</span>
<span class="fc" id="L66">    this.queryFilters = computeQueryFilter((AllFiltersImpl) allFilters, postFilters);</span>
<span class="fc" id="L67">  }</span>

  public static AllFilters newAllFilters() {
<span class="fc" id="L70">    return new AllFiltersImpl();</span>
  }

  /**
   * Any filter of the query which can not be applied to all top-aggregations must be applied as a PostFilter.
   * &lt;p&gt;
   * A filter with a given {@link FilterScope} can not be applied to the query when at least one sticky top-aggregation
   * is enabled which has the same {@link FilterScope}.
   */
  private static Map&lt;FilterNameAndScope, QueryBuilder&gt; computePostFilters(AllFiltersImpl allFilters,
    Set&lt;TopAggregationDefinition&lt;?&gt;&gt; topAggregations) {
<span class="fc" id="L81">    Set&lt;FilterScope&gt; enabledStickyTopAggregationtedFieldNames = topAggregations.stream()</span>
<span class="fc" id="L82">      .filter(TopAggregationDefinition::isSticky)</span>
<span class="fc" id="L83">      .map(TopAggregationDefinition::getFilterScope)</span>
<span class="fc" id="L84">      .collect(Collectors.toSet());</span>

    // use LinkedHashMap over MoreCollectors.uniqueIndex to preserve order and write UTs more easily
<span class="fc" id="L87">    Map&lt;FilterNameAndScope, QueryBuilder&gt; res = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L88">    allFilters.internalStream()</span>
<span class="fc" id="L89">      .filter(e -&gt; enabledStickyTopAggregationtedFieldNames.contains(e.getKey().getFilterScope()))</span>
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">      .forEach(e -&gt; checkState(res.put(e.getKey(), e.getValue()) == null, &quot;Duplicate: %s&quot;, e.getKey()));</span>
<span class="fc" id="L91">    return res;</span>
  }

  /**
   * Filters which can be applied directly to the query are only the filters which can also be applied to all
   * aggregations.
   * &lt;p&gt;
   * Aggregations are scoped by the filter of the query. If any top-aggregation need to not be applied a filter
   * (typical case is a filter on the field aggregated to implement sticky facet behavior), this filter can
   * not be applied to the query and therefor must be applied as PostFilter.
   */
  private static Map&lt;FilterNameAndScope, QueryBuilder&gt; computeQueryFilter(AllFiltersImpl allFilters,
    Map&lt;FilterNameAndScope, QueryBuilder&gt; postFilters) {
<span class="fc" id="L104">    Set&lt;FilterNameAndScope&gt; postFilterKeys = postFilters.keySet();</span>

    // use LinkedHashMap over MoreCollectors.uniqueIndex to preserve order and write UTs more easily
<span class="fc" id="L107">    Map&lt;FilterNameAndScope, QueryBuilder&gt; res = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L108">    allFilters.internalStream()</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">      .filter(e -&gt; !postFilterKeys.contains(e.getKey()))</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">      .forEach(e -&gt; checkState(res.put(e.getKey(), e.getValue()) == null, &quot;Duplicate: %s&quot;, e.getKey()));</span>
<span class="fc" id="L111">    return res;</span>
  }

  /**
   * The {@link BoolQueryBuilder} to apply directly to the query in the ES request.
   * &lt;p&gt;
   * There could be no filter to apply to the query in the (unexpected but supported) case where all filters
   * need to be applied as PostFilter because none of them can be applied to all top-aggregations.
   */
  public Optional&lt;BoolQueryBuilder&gt; getQueryFilters() {
<span class="fc" id="L121">    return toBoolQuery(this.queryFilters, (e, v) -&gt; true);</span>
  }

  /**
   * The {@link BoolQueryBuilder} to add to the ES request as PostFilter
   * (see {@link org.elasticsearch.action.search.SearchRequestBuilder#setPostFilter(QueryBuilder)}).
   * &lt;p&gt;
   * There may be no PostFilter to apply at all. Typical case is when all filters apply to both the query and
   * all aggregations. (corner case: when there is no filter at all...)
   */
  public Optional&lt;BoolQueryBuilder&gt; getPostFilters() {
<span class="fc" id="L132">    return toBoolQuery(postFilters, (e, v) -&gt; true);</span>
  }

  /**
   * The {@link BoolQueryBuilder} to apply to the top aggregation for the specified {@link SimpleFieldTopAggregationDefinition}.
   * &lt;p&gt;
   * The filter of the aggregations for a top-aggregation will either be:
   * &lt;ul&gt;
   *     &lt;li&gt;the same as PostFilter, if the top-aggregation is non-sticky or none have the same FilterScope as
   *         {@code topAggregation}&lt;/li&gt;
   *     &lt;li&gt;or the same as PostFilter minus any filter which applies to the same {@link FilterScope} of
   *         {@code topAggregation}for the (&lt;strong&gt;if it's sticky&lt;/strong&gt;)&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @throws IllegalArgumentException if specified {@link TopAggregationDefinition} has not been specified in the constructor
   */
  public Optional&lt;BoolQueryBuilder&gt; getTopAggregationFilter(TopAggregationDefinition&lt;?&gt; topAggregation) {
<span class="fc" id="L149">    checkArgument(topAggregations.contains(topAggregation), &quot;topAggregation must have been declared in constructor&quot;);</span>
<span class="fc" id="L150">    return toBoolQuery(</span>
      postFilters,
<span class="fc bfc" id="L152" title="All 4 branches covered.">      (e, v) -&gt; !topAggregation.isSticky() || !topAggregation.getFilterScope().intersect(e.getFilterScope()));</span>
  }

  private static Optional&lt;BoolQueryBuilder&gt; toBoolQuery(Map&lt;FilterNameAndScope, QueryBuilder&gt; queryFilters,
    BiPredicate&lt;FilterNameAndScope, QueryBuilder&gt; predicate) {
<span class="fc bfc" id="L157" title="All 2 branches covered.">    if (queryFilters.isEmpty()) {</span>
<span class="fc" id="L158">      return empty();</span>
    }

<span class="fc" id="L161">    List&lt;QueryBuilder&gt; selectQueryBuilders = queryFilters.entrySet().stream()</span>
<span class="fc" id="L162">      .filter(e -&gt; predicate.test(e.getKey(), e.getValue()))</span>
<span class="fc" id="L163">      .map(Map.Entry::getValue)</span>
<span class="fc" id="L164">      .toList();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (selectQueryBuilders.isEmpty()) {</span>
<span class="fc" id="L166">      return empty();</span>
    }

<span class="fc" id="L169">    BoolQueryBuilder res = boolQuery();</span>
<span class="fc" id="L170">    selectQueryBuilders.forEach(res::must);</span>
<span class="fc" id="L171">    return of(res);</span>
  }

  /**
   * A mean to put together all filters which apply to a given Search request.
   */
  public interface AllFilters {

    /**
     * @throws IllegalArgumentException if a filter with the specified name has already been added
     */
    AllFilters addFilter(String name, FilterScope filterScope, @Nullable QueryBuilder filter);

    Stream&lt;QueryBuilder&gt; stream();
  }

<span class="fc" id="L187">  private static class AllFiltersImpl implements AllFilters {</span>
    /**
     * Usage of LinkedHashMap only benefits unit tests by providing predictability of the order of the filters.
     * ES doesn't care of the order.
     */
<span class="fc" id="L192">    private final Map&lt;FilterNameAndScope, QueryBuilder&gt; filters = new LinkedHashMap&lt;&gt;();</span>

    @Override
    public AllFilters addFilter(String name, FilterScope filterScope, @Nullable QueryBuilder filter) {
<span class="fc" id="L196">      requireNonNull(name, &quot;name can't be null&quot;);</span>
<span class="fc" id="L197">      requireNonNull(filterScope, &quot;filterScope can't be null&quot;);</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">      if (filter == null) {</span>
<span class="fc" id="L200">        return this;</span>
      }

<span class="fc" id="L203">      checkArgument(</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        filters.put(new FilterNameAndScope(name, filterScope), filter) == null,</span>
        &quot;A filter with name %s has already been added&quot;, name);
<span class="fc" id="L206">      return this;</span>
    }

    @Override
    public Stream&lt;QueryBuilder&gt; stream() {
<span class="fc" id="L211">      return filters.values().stream();</span>
    }

    private Stream&lt;Map.Entry&lt;FilterNameAndScope, QueryBuilder&gt;&gt; internalStream() {
<span class="fc" id="L215">      return filters.entrySet().stream();</span>
    }
  }

  /**
   * Serves as a key in internal map of filters, it behaves the same as if the filterName was directly used as a key in
   * this map but also holds the name of the field each filter applies to.
   * &lt;p&gt;
   * This saves from using two internal maps.
   */
  @Immutable
  private static final class FilterNameAndScope {
    private final String filterName;
    private final FilterScope filterScope;

<span class="fc" id="L230">    private FilterNameAndScope(String filterName, FilterScope filterScope) {</span>
<span class="fc" id="L231">      this.filterName = filterName;</span>
<span class="fc" id="L232">      this.filterScope = filterScope;</span>
<span class="fc" id="L233">    }</span>

    public FilterScope getFilterScope() {
<span class="fc" id="L236">      return filterScope;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L242">        return true;</span>
      }
<span class="pc bpc" id="L244" title="2 of 4 branches missed.">      if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L245">        return false;</span>
      }
<span class="fc" id="L247">      FilterNameAndScope that = (FilterNameAndScope) o;</span>
<span class="fc" id="L248">      return filterName.equals(that.filterName);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L253">      return Objects.hash(filterName);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>