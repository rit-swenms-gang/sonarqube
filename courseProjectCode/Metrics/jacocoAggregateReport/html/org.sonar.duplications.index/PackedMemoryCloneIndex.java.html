<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PackedMemoryCloneIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.duplications.index</a> &gt; <span class="el_source">PackedMemoryCloneIndex.java</span></div><h1>PackedMemoryCloneIndex.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.duplications.index;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

import org.sonar.duplications.block.Block;
import org.sonar.duplications.block.ByteArray;
import org.sonar.duplications.utils.FastStringComparator;

import javax.annotation.Nullable;

/**
 * Provides an index optimized by memory.
 * &lt;p&gt;
 * Each object in Java has an overhead - see
 * &lt;a href=&quot;http://devblog.streamy.com/2009/07/24/determine-size-of-java-object-class/&quot;&gt;&quot;HOWTO: Determine the size of a Java Object or Class&quot;&lt;/a&gt;.
 * So to optimize memory consumption, we use flat arrays, however this increases time of queries.
 * During  usual detection of duplicates most time consuming method is a {@link #getByResourceId(String)}:
 * around 50% of time spent in this class and number of invocations of this method is 1% of total invocations,
 * however total time spent in this class less than 1 second for small projects and around 2 seconds for projects like JDK.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Note that this implementation currently does not support deletion, however it's possible to implement.
 * &lt;/p&gt;
 */
public class PackedMemoryCloneIndex extends AbstractCloneIndex {

  private static final int DEFAULT_INITIAL_CAPACITY = 1024;

  private static final int BLOCK_INTS = 5;

  private final int hashInts;

  private final int blockInts;

  /**
   * Indicates that index requires sorting to perform queries.
   */
  private boolean sorted;

  /**
   * Current number of blocks in index.
   */
  private int size;

  private String[] resourceIds;
  private int[] blockData;

  private int[] resourceIdsIndex;

<span class="fc" id="L73">  private final Block.Builder blockBuilder = Block.builder();</span>

  public PackedMemoryCloneIndex() {
<span class="fc" id="L76">    this(8, DEFAULT_INITIAL_CAPACITY);</span>
<span class="fc" id="L77">  }</span>

  /**
   * @param hashBytes size of hash in bytes
   * @param initialCapacity the initial capacity
   */
<span class="fc" id="L83">  public PackedMemoryCloneIndex(int hashBytes, int initialCapacity) {</span>
<span class="fc" id="L84">    this.sorted = false;</span>
<span class="fc" id="L85">    this.hashInts = hashBytes / 4;</span>
<span class="fc" id="L86">    this.blockInts = hashInts + BLOCK_INTS;</span>
<span class="fc" id="L87">    this.size = 0;</span>
<span class="fc" id="L88">    this.resourceIds = new String[initialCapacity];</span>
<span class="fc" id="L89">    this.blockData = new int[initialCapacity * blockInts];</span>
<span class="fc" id="L90">    this.resourceIdsIndex = new int[initialCapacity];</span>
<span class="fc" id="L91">  }</span>

  /**
   * {@inheritDoc}
   * &lt;p&gt;
   * &lt;strong&gt;Note that this implementation does not guarantee that blocks would be sorted by index.&lt;/strong&gt;
   * &lt;/p&gt;
   */
  @Override
  public Collection&lt;Block&gt; getByResourceId(String resourceId) {
<span class="fc" id="L101">    ensureSorted();</span>

    // prepare resourceId for binary search
<span class="fc" id="L104">    resourceIds[size] = resourceId;</span>
<span class="fc" id="L105">    resourceIdsIndex[size] = size;</span>

<span class="fc" id="L107">    int index = DataUtils.binarySearch(byResourceId);</span>

<span class="fc" id="L109">    List&lt;Block&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L110">    int realIndex = resourceIdsIndex[index];</span>
<span class="fc bfc" id="L111" title="All 4 branches covered.">    while (index &lt; size &amp;&amp; FastStringComparator.INSTANCE.compare(resourceIds[realIndex], resourceId) == 0) {</span>
<span class="fc" id="L112">      result.add(getBlock(realIndex, resourceId));</span>

<span class="fc" id="L114">      index++;</span>
<span class="fc" id="L115">      realIndex = resourceIdsIndex[index];</span>
    }
<span class="fc" id="L117">    return result;</span>
  }

  private Block createBlock(int index, String resourceId, @Nullable ByteArray byteHash) {
<span class="fc" id="L121">    int offset = index * blockInts;</span>
    ByteArray blockHash;

<span class="fc bfc" id="L124" title="All 2 branches covered.">    if (byteHash == null) {</span>
<span class="fc" id="L125">      int[] hash = new int[hashInts];</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">      for (int j = 0; j &lt; hashInts; j++) {</span>
<span class="fc" id="L127">        hash[j] = blockData[offset++];</span>
      }
<span class="fc" id="L129">      blockHash = new ByteArray(hash);</span>
<span class="fc" id="L130">    } else {</span>
<span class="fc" id="L131">      blockHash = byteHash;</span>
<span class="fc" id="L132">      offset += hashInts;</span>
    }

<span class="fc" id="L135">    int indexInFile = blockData[offset++];</span>
<span class="fc" id="L136">    int firstLineNumber = blockData[offset++];</span>
<span class="fc" id="L137">    int lastLineNumber = blockData[offset++];</span>
<span class="fc" id="L138">    int startUnit = blockData[offset++];</span>
<span class="fc" id="L139">    int endUnit = blockData[offset];</span>

<span class="fc" id="L141">    return blockBuilder</span>
<span class="fc" id="L142">      .setResourceId(resourceId)</span>
<span class="fc" id="L143">      .setBlockHash(blockHash)</span>
<span class="fc" id="L144">      .setIndexInFile(indexInFile)</span>
<span class="fc" id="L145">      .setLines(firstLineNumber, lastLineNumber)</span>
<span class="fc" id="L146">      .setUnit(startUnit, endUnit)</span>
<span class="fc" id="L147">      .build();</span>
  }

  private Block getBlock(int index, String resourceId) {
<span class="fc" id="L151">    return createBlock(index, resourceId, null);</span>
  }

<span class="fc" id="L154">  private class ResourceIterator implements Iterator&lt;ResourceBlocks&gt; {</span>
<span class="fc" id="L155">    private int index = 0;</span>

    @Override
    public boolean hasNext() {
<span class="fc bfc" id="L159" title="All 2 branches covered.">      return index &lt; size;</span>
    }

    @Override
    public ResourceBlocks next() {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">      if (!hasNext()) {</span>
<span class="nc" id="L165">        throw new NoSuchElementException();</span>
      }

<span class="fc" id="L168">      String resourceId = resourceIds[resourceIdsIndex[index]];</span>
<span class="fc" id="L169">      List&lt;Block&gt; blocks = new ArrayList&lt;&gt;();</span>

      // while we are at the same resource, keep going
      do {
<span class="fc" id="L173">        blocks.add(getBlock(resourceIdsIndex[index], resourceId));</span>
<span class="fc" id="L174">        index++;</span>
<span class="fc bfc" id="L175" title="All 4 branches covered.">      } while (hasNext() &amp;&amp; FastStringComparator.INSTANCE.compare(resourceIds[resourceIdsIndex[index]], resourceId) == 0);</span>

<span class="fc" id="L177">      return new ResourceBlocks(resourceId, blocks);</span>
    }

    @Override
    public void remove() {
<span class="nc" id="L182">      throw new UnsupportedOperationException();</span>
    }
  }

  public static class ResourceBlocks {
    private Collection&lt;Block&gt; blocks;
    private String resourceId;

<span class="fc" id="L190">    public ResourceBlocks(String resourceId, Collection&lt;Block&gt; blocks) {</span>
<span class="fc" id="L191">      this.resourceId = resourceId;</span>
<span class="fc" id="L192">      this.blocks = blocks;</span>
<span class="fc" id="L193">    }</span>

    public Collection&lt;Block&gt; blocks() {
<span class="fc" id="L196">      return blocks;</span>
    }

    public String resourceId() {
<span class="fc" id="L200">      return resourceId;</span>
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Iterator&lt;ResourceBlocks&gt; iterator() {
<span class="fc" id="L209">    ensureSorted();</span>
<span class="fc" id="L210">    return new ResourceIterator();</span>
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Collection&lt;Block&gt; getBySequenceHash(ByteArray sequenceHash) {
<span class="fc" id="L218">    ensureSorted();</span>

    // prepare hash for binary search
<span class="fc" id="L221">    int[] hash = sequenceHash.toIntArray();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">    if (hash.length != hashInts) {</span>
<span class="fc" id="L223">      throw new IllegalArgumentException(&quot;Expected &quot; + hashInts + &quot; ints in hash, but got &quot; + hash.length);</span>
    }
<span class="fc" id="L225">    int offset = size * blockInts;</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">    for (int i = 0; i &lt; hashInts; i++) {</span>
<span class="fc" id="L227">      blockData[offset++] = hash[i];</span>
    }

<span class="fc" id="L230">    int index = DataUtils.binarySearch(byBlockHash);</span>

<span class="fc" id="L232">    List&lt;Block&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L233" title="All 4 branches covered.">    while (index &lt; size &amp;&amp; !isLessByHash(size, index)) {</span>
      // extract block (note that there is no need to extract hash)
<span class="fc" id="L235">      String resourceId = resourceIds[index];</span>
<span class="fc" id="L236">      result.add(createBlock(index, resourceId, sequenceHash));</span>
<span class="fc" id="L237">      index++;</span>
<span class="fc" id="L238">    }</span>
<span class="fc" id="L239">    return result;</span>
  }

  /**
   * {@inheritDoc}
   * &lt;p&gt;
   * &lt;strong&gt;Note that this implementation allows insertion of two blocks with same index for one resource.&lt;/strong&gt;
   * &lt;/p&gt;
   */
  @Override
  public void insert(Block block) {
<span class="fc" id="L250">    sorted = false;</span>
<span class="fc" id="L251">    ensureCapacity();</span>

<span class="fc" id="L253">    resourceIds[size] = block.getResourceId();</span>

<span class="fc" id="L255">    int[] hash = block.getBlockHash().toIntArray();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">    if (hash.length != hashInts) {</span>
<span class="fc" id="L257">      throw new IllegalArgumentException(&quot;Expected &quot; + hashInts + &quot; ints in hash, but got &quot; + hash.length);</span>
    }
<span class="fc" id="L259">    int offset = size * blockInts;</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">    for (int i = 0; i &lt; hashInts; i++) {</span>
<span class="fc" id="L261">      blockData[offset++] = hash[i];</span>
    }
<span class="fc" id="L263">    blockData[offset++] = block.getIndexInFile();</span>
<span class="fc" id="L264">    blockData[offset++] = block.getStartLine();</span>
<span class="fc" id="L265">    blockData[offset++] = block.getEndLine();</span>
<span class="fc" id="L266">    blockData[offset++] = block.getStartUnit();</span>
<span class="fc" id="L267">    blockData[offset] = block.getEndUnit();</span>

<span class="fc" id="L269">    size++;</span>
<span class="fc" id="L270">  }</span>

  /**
   * Increases the capacity, if necessary.
   */
  private void ensureCapacity() {
<span class="fc bfc" id="L276" title="All 2 branches covered.">    if (size &lt; resourceIds.length) {</span>
<span class="fc" id="L277">      return;</span>
    }
<span class="fc" id="L279">    int newCapacity = (resourceIds.length * 3) / 2 + 1;</span>
    // Increase size of resourceIds
<span class="fc" id="L281">    String[] oldResourceIds = resourceIds;</span>
<span class="fc" id="L282">    resourceIds = new String[newCapacity];</span>
<span class="fc" id="L283">    System.arraycopy(oldResourceIds, 0, resourceIds, 0, oldResourceIds.length);</span>
    // Increase size of blockData
<span class="fc" id="L285">    int[] oldBlockData = blockData;</span>
<span class="fc" id="L286">    blockData = new int[newCapacity * blockInts];</span>
<span class="fc" id="L287">    System.arraycopy(oldBlockData, 0, blockData, 0, oldBlockData.length);</span>
    // Increase size of byResourceIndices (no need to copy old, because would be restored in method ensureSorted)
<span class="fc" id="L289">    resourceIdsIndex = new int[newCapacity];</span>
<span class="fc" id="L290">    sorted = false;</span>
<span class="fc" id="L291">  }</span>

  /**
   * Performs sorting, if necessary.
   */
  private void ensureSorted() {
<span class="fc bfc" id="L297" title="All 2 branches covered.">    if (sorted) {</span>
<span class="fc" id="L298">      return;</span>
    }

<span class="fc" id="L301">    ensureCapacity();</span>

<span class="fc" id="L303">    DataUtils.sort(byBlockHash);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">    for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L305">      resourceIdsIndex[i] = i;</span>
    }
<span class="fc" id="L307">    DataUtils.sort(byResourceId);</span>

<span class="fc" id="L309">    sorted = true;</span>
<span class="fc" id="L310">  }</span>

  private boolean isLessByHash(int i, int j) {
<span class="fc" id="L313">    int i2 = i * blockInts;</span>
<span class="fc" id="L314">    int j2 = j * blockInts;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">    for (int k = 0; k &lt; hashInts; k++, i2++, j2++) {</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">      if (blockData[i2] &lt; blockData[j2]) {</span>
<span class="fc" id="L317">        return true;</span>
      }
<span class="fc bfc" id="L319" title="All 2 branches covered.">      if (blockData[i2] &gt; blockData[j2]) {</span>
<span class="fc" id="L320">        return false;</span>
      }
    }
<span class="fc" id="L323">    return false;</span>
  }

<span class="fc" id="L326">  private final DataUtils.Sortable byBlockHash = new DataUtils.Sortable() {</span>
    @Override
    public void swap(int i, int j) {
<span class="fc" id="L329">      String tmp = resourceIds[i];</span>
<span class="fc" id="L330">      resourceIds[i] = resourceIds[j];</span>
<span class="fc" id="L331">      resourceIds[j] = tmp;</span>

<span class="fc" id="L333">      i *= blockInts;</span>
<span class="fc" id="L334">      j *= blockInts;</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">      for (int k = 0; k &lt; blockInts; k++, i++, j++) {</span>
<span class="fc" id="L336">        int x = blockData[i];</span>
<span class="fc" id="L337">        blockData[i] = blockData[j];</span>
<span class="fc" id="L338">        blockData[j] = x;</span>
      }
<span class="fc" id="L340">    }</span>

    @Override
    public boolean isLess(int i, int j) {
<span class="fc" id="L344">      return isLessByHash(i, j);</span>
    }

    @Override
    public int size() {
<span class="fc" id="L349">      return size;</span>
    }
  };

<span class="fc" id="L353">  private final DataUtils.Sortable byResourceId = new DataUtils.Sortable() {</span>
    @Override
    public void swap(int i, int j) {
<span class="fc" id="L356">      int tmp = resourceIdsIndex[i];</span>
<span class="fc" id="L357">      resourceIdsIndex[i] = resourceIdsIndex[j];</span>
<span class="fc" id="L358">      resourceIdsIndex[j] = tmp;</span>
<span class="fc" id="L359">    }</span>

    @Override
    public boolean isLess(int i, int j) {
<span class="fc" id="L363">      String s1 = resourceIds[resourceIdsIndex[i]];</span>
<span class="fc" id="L364">      String s2 = resourceIds[resourceIdsIndex[j]];</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">      return FastStringComparator.INSTANCE.compare(s1, s2) &lt; 0;</span>
    }

    @Override
    public int size() {
<span class="fc" id="L370">      return size;</span>
    }
  };

  @Override
  /**
   * Computation is O(N)
   */
  public int noResources() {
<span class="fc" id="L379">    ensureSorted();</span>
<span class="fc" id="L380">    int count = 0;</span>
<span class="fc" id="L381">    String lastResource = null;</span>

<span class="fc bfc" id="L383" title="All 2 branches covered.">    for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L384">      String resource = resourceIds[resourceIdsIndex[i]];</span>
<span class="pc bpc" id="L385" title="1 of 4 branches missed.">      if (resource != null &amp;&amp; !resource.equals(lastResource)) {</span>
<span class="fc" id="L386">        count++;</span>
<span class="fc" id="L387">        lastResource = resource;</span>
      }
    }
<span class="fc" id="L390">    return count;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>