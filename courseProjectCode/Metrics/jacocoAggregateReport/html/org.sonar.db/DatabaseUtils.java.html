<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatabaseUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.db</a> &gt; <span class="el_source">DatabaseUtils.java</span></div><h1>DatabaseUtils.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.db;

import com.google.common.base.Throwables;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Ordering;
import com.google.common.collect.Sets;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntSupplier;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import javax.annotation.CheckForNull;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.google.common.base.Preconditions.checkArgument;
import static java.lang.String.format;

public class DatabaseUtils {
  private static final String TABLE_NOT_EXIST_MESSAGE = &quot;Can not check that table %s exists&quot;;
  public static final int PARTITION_SIZE_FOR_ORACLE = 1000;
  public static final String ORACLE_DRIVER_NAME = &quot;Oracle JDBC driver&quot;;
<span class="fc" id="L63">  public static final Pattern ORACLE_OBJECT_NAME_RULE = Pattern.compile(&quot;\&quot;[^\&quot;\\u0000]+\&quot;|\\p{L}[\\p{L}\\p{N}_$#@]*&quot;);</span>
  public static final String INDEX_NAME_VARIATION = &quot;^idx_\\d+_%s$&quot;;
  /**
   * @see DatabaseMetaData#getTableTypes()
   */
<span class="fc" id="L68">  private static final String[] TABLE_TYPE = {&quot;TABLE&quot;};</span>

<span class="nc" id="L70">  protected DatabaseUtils() {</span>
<span class="nc" id="L71">    throw new IllegalStateException(&quot;Utility class&quot;);</span>
  }

  public static void closeQuietly(@Nullable Connection connection) {
<span class="fc bfc" id="L75" title="All 2 branches covered.">    if (connection != null) {</span>
      try {
<span class="fc" id="L77">        connection.close();</span>
<span class="fc" id="L78">      } catch (SQLException e) {</span>
<span class="fc" id="L79">        LoggerFactory.getLogger(DatabaseUtils.class).warn(&quot;Fail to close connection&quot;, e);</span>
        // ignore
<span class="fc" id="L81">      }</span>
    }
<span class="fc" id="L83">  }</span>

  public static void closeQuietly(@Nullable Statement stmt) {
<span class="fc bfc" id="L86" title="All 2 branches covered.">    if (stmt != null) {</span>
      try {
<span class="fc" id="L88">        stmt.close();</span>
<span class="fc" id="L89">      } catch (SQLException e) {</span>
<span class="fc" id="L90">        LoggerFactory.getLogger(DatabaseUtils.class).warn(&quot;Fail to close statement&quot;, e);</span>
        // ignore
<span class="fc" id="L92">      }</span>
    }
<span class="fc" id="L94">  }</span>

  public static void closeQuietly(@Nullable ResultSet rs) {
<span class="fc bfc" id="L97" title="All 2 branches covered.">    if (rs != null) {</span>
      try {
<span class="fc" id="L99">        rs.close();</span>
<span class="fc" id="L100">      } catch (SQLException e) {</span>
<span class="fc" id="L101">        LoggerFactory.getLogger(DatabaseUtils.class).warn(&quot;Fail to close result set&quot;, e);</span>
        // ignore
<span class="fc" id="L103">      }</span>
    }
<span class="fc" id="L105">  }</span>

  /**
   * Partition by 1000 elements a list of input and execute a function on each part.
   * &lt;p&gt;
   * The goal is to prevent issue with ORACLE when there's more than 1000 elements in a 'in ('X', 'Y', ...)'
   * and with MsSQL when there's more than 2000 parameters in a query
   */
  public static &lt;OUTPUT, INPUT extends Comparable&lt;INPUT&gt;&gt; List&lt;OUTPUT&gt; executeLargeInputs(Collection&lt;INPUT&gt; input, Function&lt;List&lt;INPUT&gt;, List&lt;OUTPUT&gt;&gt; function) {
<span class="fc" id="L114">    return executeLargeInputs(input, function, i -&gt; i);</span>
  }

  /**
   * Partition by 1000 elements a list of input and execute a function on each part.
   * &lt;p&gt;
   * The goal is to prevent issue with ORACLE when there's more than 1000 elements in a 'in ('X', 'Y', ...)'
   * and with MsSQL when there's more than 2000 parameters in a query
   */
  public static &lt;OUTPUT, INPUT extends Comparable&lt;INPUT&gt;&gt; List&lt;OUTPUT&gt; executeLargeInputs(Collection&lt;INPUT&gt; input, Function&lt;List&lt;INPUT&gt;, List&lt;OUTPUT&gt;&gt; function,
    IntFunction&lt;Integer&gt; partitionSizeManipulations) {
<span class="fc bfc" id="L125" title="All 2 branches covered.">    return executeLargeInputs(input, function, size -&gt; size == 0 ? Collections.emptyList() : new ArrayList&lt;&gt;(size), partitionSizeManipulations);</span>
  }

  public static &lt;OUTPUT, INPUT extends Comparable&lt;INPUT&gt;&gt; Set&lt;OUTPUT&gt; executeLargeInputsIntoSet(Collection&lt;INPUT&gt; input, Function&lt;List&lt;INPUT&gt;, Set&lt;OUTPUT&gt;&gt; function,
    IntFunction&lt;Integer&gt; partitionSizeManipulations) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">    return executeLargeInputs(input, function, size -&gt; size == 0 ? Collections.emptySet() : new HashSet&lt;&gt;(size), partitionSizeManipulations);</span>
  }

  private static &lt;OUTPUT, INPUT extends Comparable&lt;INPUT&gt;, RESULT extends Collection&lt;OUTPUT&gt;&gt; RESULT executeLargeInputs(Collection&lt;INPUT&gt; input,
    Function&lt;List&lt;INPUT&gt;, RESULT&gt; function, java.util.function.IntFunction&lt;RESULT&gt; outputInitializer, IntFunction&lt;Integer&gt; partitionSizeManipulations) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">    if (input.isEmpty()) {</span>
<span class="fc" id="L136">      return outputInitializer.apply(0);</span>
    }
<span class="fc" id="L138">    RESULT results = outputInitializer.apply(input.size());</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">    for (List&lt;INPUT&gt; partition : toUniqueAndSortedPartitions(input, partitionSizeManipulations)) {</span>
<span class="fc" id="L140">      RESULT subResults = function.apply(partition);</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">      if (subResults != null) {</span>
<span class="fc" id="L142">        results.addAll(subResults);</span>
      }
<span class="fc" id="L144">    }</span>
<span class="fc" id="L145">    return results;</span>
  }

  /**
   * Partition by 1000 elements a list of input and execute a consumer on each part.
   * &lt;p&gt;
   * The goal is to prevent issue with ORACLE when there's more than 1000 elements in a 'in ('X', 'Y', ...)'
   * and with MsSQL when there's more than 2000 parameters in a query
   */
  public static &lt;INPUT extends Comparable&lt;INPUT&gt;&gt; void executeLargeUpdates(Collection&lt;INPUT&gt; inputs, Consumer&lt;List&lt;INPUT&gt;&gt; consumer) {
<span class="fc" id="L155">    executeLargeUpdates(inputs, consumer, i -&gt; i);</span>
<span class="fc" id="L156">  }</span>

  /**
   * Partition by 1000 elements a list of input and execute a consumer on each part.
   * &lt;p&gt;
   * The goal is to prevent issue with ORACLE when there's more than 1000 elements in a 'in ('X', 'Y', ...)'
   * and with MsSQL when there's more than 2000 parameters in a query
   *
   * @param inputs                     the whole list of elements to be partitioned
   * @param consumer                   the mapper method to be executed, for example {@code mapper(dbSession)::selectByUuids}
   * @param partitionSizeManipulations the function that computes the number of usages of a partition, for example
   *                                   {@code partitionSize -&gt; partitionSize / 2} when the partition of elements
   *                                   in used twice in the SQL request.
   */
  public static &lt;INPUT extends Comparable&lt;INPUT&gt;&gt; void executeLargeUpdates(Collection&lt;INPUT&gt; inputs, Consumer&lt;List&lt;INPUT&gt;&gt; consumer,
    IntFunction&lt;Integer&gt; partitionSizeManipulations) {
<span class="fc" id="L172">    Iterable&lt;List&lt;INPUT&gt;&gt; partitions = toUniqueAndSortedPartitions(inputs, partitionSizeManipulations);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">    for (List&lt;INPUT&gt; partition : partitions) {</span>
<span class="fc" id="L174">      consumer.accept(partition);</span>
<span class="fc" id="L175">    }</span>
<span class="fc" id="L176">  }</span>

  /**
   * Ensure values {@code inputs} are unique (which avoids useless arguments) and sorted before creating the partition.
   */
  public static &lt;INPUT extends Comparable&lt;INPUT&gt;&gt; Iterable&lt;List&lt;INPUT&gt;&gt; toUniqueAndSortedPartitions(Collection&lt;INPUT&gt; inputs) {
<span class="fc" id="L182">    return toUniqueAndSortedPartitions(inputs, i -&gt; i);</span>
  }

  /**
   * Ensure values {@code inputs} are unique (which avoids useless arguments) and sorted before creating the partition.
   */
  public static &lt;INPUT extends Comparable&lt;INPUT&gt;&gt; Iterable&lt;List&lt;INPUT&gt;&gt; toUniqueAndSortedPartitions(Collection&lt;INPUT&gt; inputs, IntFunction&lt;Integer&gt; partitionSizeManipulations) {
<span class="fc" id="L189">    int partitionSize = partitionSizeManipulations.apply(PARTITION_SIZE_FOR_ORACLE);</span>
<span class="fc" id="L190">    return Iterables.partition(toUniqueAndSortedList(inputs), partitionSize);</span>
  }

  /**
   * Ensure values {@code inputs} are unique (which avoids useless arguments) and sorted so that there is little
   * variations of SQL requests over time as possible with a IN clause and/or a group of OR clauses. Such requests can
   * then be more easily optimized by the SGDB engine.
   */
  public static &lt;INPUT extends Comparable&lt;INPUT&gt;&gt; List&lt;INPUT&gt; toUniqueAndSortedList(Iterable&lt;INPUT&gt; inputs) {
<span class="fc bfc" id="L199" title="All 2 branches covered.">    if (inputs instanceof Set) {</span>
      // inputs are unique but order is not enforced
<span class="fc" id="L201">      return Ordering.natural().immutableSortedCopy(inputs);</span>
    }
    // inputs are not unique and order is not guaranteed
<span class="fc" id="L204">    return Ordering.natural().immutableSortedCopy(Sets.newHashSet(inputs));</span>
  }

  /**
   * Partition by 1000 elements a list of input and execute a consumer on each part.
   * &lt;p&gt;
   * The goal is to prevent issue with ORACLE when there's more than 1000 elements in a 'in ('X', 'Y', ...)'
   * and with MsSQL when there's more than 2000 parameters in a query
   */
  public static &lt;T&gt; void executeLargeInputsWithoutOutput(Collection&lt;T&gt; input, Consumer&lt;List&lt;T&gt;&gt; consumer) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (input.isEmpty()) {</span>
<span class="fc" id="L215">      return;</span>
    }

<span class="fc" id="L218">    List&lt;List&lt;T&gt;&gt; partitions = Lists.partition(new ArrayList&lt;&gt;(input), PARTITION_SIZE_FOR_ORACLE);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">    for (List&lt;T&gt; partition : partitions) {</span>
<span class="fc" id="L220">      consumer.accept(partition);</span>
<span class="fc" id="L221">    }</span>
<span class="fc" id="L222">  }</span>

  /**
   * Logback does not log exceptions associated to {@link java.sql.SQLException#getNextException()}.
   * See http://jira.qos.ch/browse/LOGBACK-775
   */
  public static void log(Logger logger, SQLException e) {
<span class="fc" id="L229">    SQLException next = e.getNextException();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">    while (next != null) {</span>
<span class="fc" id="L231">      logger.error(&quot;SQL error: {}. Message: {}&quot;, next.getSQLState(), next.getMessage());</span>
<span class="fc" id="L232">      next = next.getNextException();</span>
    }
<span class="fc" id="L234">  }</span>

  @CheckForNull
  public static Long getLong(ResultSet rs, String columnName) throws SQLException {
<span class="nc" id="L238">    long l = rs.getLong(columnName);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">    return rs.wasNull() ? null : l;</span>
  }

  @CheckForNull
  public static Double getDouble(ResultSet rs, String columnName) throws SQLException {
<span class="nc" id="L244">    double d = rs.getDouble(columnName);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">    return rs.wasNull() ? null : d;</span>
  }

  @CheckForNull
  public static Integer getInt(ResultSet rs, String columnName) throws SQLException {
<span class="nc" id="L250">    int i = rs.getInt(columnName);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">    return rs.wasNull() ? null : i;</span>
  }

  @CheckForNull
  public static String getString(ResultSet rs, String columnName) throws SQLException {
<span class="nc" id="L256">    String s = rs.getString(columnName);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">    return rs.wasNull() ? null : s;</span>
  }

  @CheckForNull
  public static Long getLong(ResultSet rs, int columnIndex) throws SQLException {
<span class="fc" id="L262">    long l = rs.getLong(columnIndex);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">    return rs.wasNull() ? null : l;</span>
  }

  @CheckForNull
  public static Double getDouble(ResultSet rs, int columnIndex) throws SQLException {
<span class="fc" id="L268">    double d = rs.getDouble(columnIndex);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">    return rs.wasNull() ? null : d;</span>
  }

  @CheckForNull
  public static Integer getInt(ResultSet rs, int columnIndex) throws SQLException {
<span class="nc" id="L274">    int i = rs.getInt(columnIndex);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">    return rs.wasNull() ? null : i;</span>
  }

  @CheckForNull
  public static String getString(ResultSet rs, int columnIndex) throws SQLException {
<span class="fc" id="L280">    String s = rs.getString(columnIndex);</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">    return rs.wasNull() ? null : s;</span>
  }

  @CheckForNull
  public static Date getDate(ResultSet rs, int columnIndex) throws SQLException {
<span class="nc" id="L286">    Timestamp t = rs.getTimestamp(columnIndex);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">    return rs.wasNull() ? null : new Date(t.getTime());</span>
  }

  /**
   * @param table case-insensitive name of table
   * @return true if a table exists with this name, otherwise false
   * @throws SQLException
   */
  public static boolean tableExists(String table, Connection connection) {
<span class="fc bfc" id="L296" title="All 2 branches covered.">    return doTableExists(table, connection) ||</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">      doTableExists(table.toLowerCase(Locale.ENGLISH), connection) ||</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">      doTableExists(table.toUpperCase(Locale.ENGLISH), connection);</span>

  }

  private static boolean doTableExists(String table, Connection connection) {
<span class="fc" id="L303">    String schema = getSchema(connection);</span>

    // table type is used to speed-up Oracle by removing introspection of system tables and aliases.
<span class="fc" id="L306">    try (ResultSet rs = connection.getMetaData().getTables(connection.getCatalog(), schema, table, TABLE_TYPE)) {</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">      while (rs.next()) {</span>
<span class="fc" id="L308">        String name = rs.getString(&quot;TABLE_NAME&quot;);</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if (table.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L310">          return true;</span>
        }
<span class="nc" id="L312">      }</span>
<span class="fc" id="L313">      return false;</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">    } catch (SQLException e) {</span>
<span class="nc" id="L315">      throw wrapSqlException(e, TABLE_NOT_EXIST_MESSAGE, table);</span>
    }
  }

  public static boolean indexExistsIgnoreCase(String table, String index, Connection connection) {
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    return doIndexExistsIgnoreIndexCase(table, index, connection) ||</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">      doIndexExistsIgnoreIndexCase(table.toLowerCase(Locale.ENGLISH), index, connection) ||</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">      doIndexExistsIgnoreIndexCase(table.toUpperCase(Locale.ENGLISH), index, connection);</span>
  }

  private static boolean doIndexExistsIgnoreIndexCase(String table, String index, Connection connection) {
<span class="fc" id="L326">    return findIndex(connection, table, index).isPresent();</span>
  }

  /**
   * Finds an index by searching by its lower case or upper case name. If an index is found, it's name is returned with the matching case.
   * This is useful when we need to drop an index that could exist with either lower case or upper case name.
   * See SONAR-13594
   * Related to ticket SONAR-17737, some index name can be changed to pattern idx_{number}_index_name. We also want to be able to identify and return them
   */
  public static Optional&lt;String&gt; findExistingIndex(Connection connection, String tableName, String indexName) {
<span class="fc bfc" id="L336" title="All 4 branches covered.">    Predicate&lt;String&gt; indexSelector = idx -&gt; indexName.equalsIgnoreCase(idx) || indexMatchesPattern(idx, format(INDEX_NAME_VARIATION, indexName));</span>

<span class="fc" id="L338">    return findIndex(connection, tableName.toLowerCase(Locale.US), indexSelector)</span>
<span class="fc" id="L339">      .or(() -&gt; findIndex(connection, tableName.toUpperCase(Locale.US), indexSelector));</span>
  }

  private static boolean indexMatchesPattern(@Nullable String idx, String pattern) {
<span class="pc bpc" id="L343" title="1 of 4 branches missed.">    return idx != null &amp;&amp; Pattern.compile(pattern, Pattern.CASE_INSENSITIVE).matcher(idx).matches();</span>
  }

  private static Optional&lt;String&gt; findIndex(Connection connection, String tableName, String indexName) {
<span class="fc" id="L347">    return findIndex(connection, tableName, indexName::equalsIgnoreCase);</span>
  }

  private static Optional&lt;String&gt; findIndex(Connection connection, String tableName, Predicate&lt;String&gt; indexMatcher) {
<span class="fc" id="L351">    String schema = getSchema(connection);</span>

<span class="fc bfc" id="L353" title="All 2 branches covered.">    if (StringUtils.isNotEmpty(schema)) {</span>
<span class="fc" id="L354">      String driverName = getDriver(connection);</span>
//      Fix for double quoted schema name in Oracle
<span class="fc bfc" id="L356" title="All 4 branches covered.">      if (ORACLE_DRIVER_NAME.equals(driverName) &amp;&amp; !ORACLE_OBJECT_NAME_RULE.matcher(schema).matches()) {</span>
<span class="fc" id="L357">        return getOracleIndex(connection, tableName, indexMatcher, schema);</span>
      }
    }

<span class="fc" id="L361">    return getIndex(connection, tableName, indexMatcher, schema);</span>
  }

  private static Optional&lt;String&gt; getIndex(Connection connection, String tableName, Predicate&lt;String&gt; indexMatcher, @Nullable String schema) {
<span class="fc" id="L365">    try (ResultSet rs = connection.getMetaData().getIndexInfo(connection.getCatalog(), schema, tableName, false, true)) {</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">      while (rs.next()) {</span>
<span class="fc" id="L367">        String idx = rs.getString(&quot;INDEX_NAME&quot;);</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        if (indexMatcher.test(idx)) {</span>
<span class="fc" id="L369">          return Optional.of(idx);</span>
        }
<span class="fc" id="L371">      }</span>
<span class="fc" id="L372">      return Optional.empty();</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">    } catch (SQLException e) {</span>
<span class="nc" id="L374">      throw wrapSqlException(e, TABLE_NOT_EXIST_MESSAGE, tableName);</span>
    }
  }

  private static Optional&lt;String&gt; getOracleIndex(Connection connection, String tableName, Predicate&lt;String&gt; indexMatcher, @Nonnull String schema) {
<span class="fc" id="L379">    try (ResultSet rs = connection.getMetaData().getIndexInfo(connection.getCatalog(), null, tableName, false, true)) {</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">      while (rs.next()) {</span>
<span class="fc" id="L381">        String idx = rs.getString(&quot;INDEX_NAME&quot;);</span>
<span class="fc" id="L382">        String tableSchema = rs.getString(&quot;TABLE_SCHEM&quot;);</span>
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">        if (schema.equalsIgnoreCase(tableSchema) &amp;&amp; indexMatcher.test(idx)) {</span>
<span class="fc" id="L384">          return Optional.of(idx);</span>
        }
<span class="fc" id="L386">      }</span>
<span class="fc" id="L387">      return Optional.empty();</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">    } catch (SQLException e) {</span>
<span class="fc" id="L389">      throw wrapSqlException(e, TABLE_NOT_EXIST_MESSAGE, tableName);</span>
    }
  }

  public static boolean tableColumnExists(Connection connection, String tableName, String columnName) {
    try {
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">      return columnExists(connection, tableName.toLowerCase(Locale.US), columnName)</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        || columnExists(connection, tableName.toUpperCase(Locale.US), columnName);</span>
<span class="nc" id="L397">    } catch (SQLException e) {</span>
<span class="nc" id="L398">      throw wrapSqlException(e, &quot;Can not check that column %s exists&quot;, columnName);</span>
    }
  }

  private static boolean columnExists(Connection connection, String tableName, String columnName) throws SQLException {
<span class="fc" id="L403">    String schema = getSchema(connection);</span>
<span class="fc" id="L404">    try (ResultSet rs = connection.getMetaData().getColumns(connection.getCatalog(), schema, tableName, null)) {</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">      while (rs.next()) {</span>
        // this is wrong and could lead to bugs, there is no point of going through each column - only one column contains column name
        // see the contract (javadoc) of java.sql.DatabaseMetaData.getColumns
<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (int i = 1; i &lt;= rs.getMetaData().getColumnCount(); i++) {</span>
<span class="fc" id="L409">          String name = rs.getString(i);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">          if (columnName.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L411">            return true;</span>
          }
        }
      }
<span class="fc" id="L415">      return false;</span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">    }</span>
  }
  @CheckForNull
  public static ColumnMetadata getColumnMetadata(Connection connection, String tableName, String columnName) throws SQLException {
<span class="fc" id="L420">    ColumnMetadata columnMetadataLowerCase = getColumnMetadataWithCaseSensitiveTableName(connection, tableName.toLowerCase(Locale.US), columnName);</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">    if (columnMetadataLowerCase != null) {</span>
<span class="nc" id="L422">      return columnMetadataLowerCase;</span>
    }
<span class="fc" id="L424">    return getColumnMetadataWithCaseSensitiveTableName(connection, tableName.toUpperCase(Locale.US), columnName);</span>
  }

  @CheckForNull
  public static ColumnMetadata getColumnMetadataWithCaseSensitiveTableName(Connection connection, String tableName, String columnName) throws SQLException {
<span class="fc" id="L429">    String schema = getSchema(connection);</span>
<span class="fc" id="L430">    try (ResultSet rs = connection.getMetaData().getColumns(connection.getCatalog(), schema, tableName, null)) {</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">      while (rs.next()) {</span>
<span class="fc" id="L432">        String name = rs.getString(4);</span>
<span class="fc" id="L433">        int type = rs.getInt(5);</span>
<span class="fc" id="L434">        int limit = rs.getInt(7);</span>
<span class="fc" id="L435">        boolean nullable = rs.getBoolean(11);</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        if (columnName.equalsIgnoreCase(name)) {</span>
<span class="fc" id="L437">          return new ColumnMetadata(name, nullable, type, limit);</span>
        }
<span class="fc" id="L439">      }</span>
<span class="fc" id="L440">      return null;</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">    }</span>
  }

  @CheckForNull
  static String getDriver(Connection connection) {
    try {
<span class="fc" id="L447">      return connection.getMetaData().getDriverName();</span>
<span class="fc" id="L448">    } catch (SQLException e) {</span>
<span class="fc" id="L449">      LoggerFactory.getLogger(DatabaseUtils.class).warn(&quot;Fail to determine database driver.&quot;, e);</span>
<span class="fc" id="L450">      return null;</span>
    }
  }

  @CheckForNull
  private static String getSchema(Connection connection) {
<span class="fc" id="L456">    String schema = null;</span>

    try {
      // Using H2 with a JDBC TCP connection is throwing an exception
      // See org.h2.engine.SessionRemote#getCurrentSchemaName()
<span class="fc bfc" id="L461" title="All 2 branches covered.">      if (!&quot;H2 JDBC Driver&quot;.equals(connection.getMetaData().getDriverName())) {</span>
<span class="fc" id="L462">        schema = connection.getSchema();</span>
      }
<span class="nc" id="L464">    } catch (SQLException e) {</span>
<span class="nc" id="L465">      LoggerFactory.getLogger(DatabaseUtils.class).warn(&quot;Fail to determine schema. Keeping it null for searching tables&quot;, e);</span>
<span class="fc" id="L466">    }</span>
<span class="fc" id="L467">    return schema;</span>
  }

  public static IllegalStateException wrapSqlException(SQLException e, String message, Object... messageArgs) {
<span class="fc" id="L471">    return new IllegalStateException(format(message, messageArgs), e);</span>
  }

  /**
   * This method can be used as a method reference, for not to have to handle the checked exception {@link SQLException}
   */
  public static Consumer&lt;String&gt; setStrings(PreparedStatement stmt, IntSupplier index) {
<span class="nc" id="L478">    return value -&gt; {</span>
      try {
<span class="nc" id="L480">        stmt.setString(index.getAsInt(), value);</span>
<span class="nc" id="L481">      } catch (SQLException e) {</span>
<span class="nc" id="L482">        Throwables.propagate(e);</span>
<span class="nc" id="L483">      }</span>
<span class="nc" id="L484">    };</span>
  }

  /**
   * @throws IllegalArgumentException if the collection is not null and has strictly more
   *                                  than {@link #PARTITION_SIZE_FOR_ORACLE} values.
   */
  public static void checkThatNotTooManyConditions(@Nullable Collection&lt;?&gt; values, String message) {
<span class="fc bfc" id="L492" title="All 2 branches covered.">    if (values != null) {</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">      checkArgument(values.size() &lt;= PARTITION_SIZE_FOR_ORACLE, message);</span>
    }
<span class="fc" id="L495">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>