<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StartupRuleUpdater.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.rule.registration</a> &gt; <span class="el_source">StartupRuleUpdater.java</span></div><h1>StartupRuleUpdater.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.rule.registration;

import com.google.common.collect.Sets;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;
import org.sonar.api.issue.impact.Severity;
import org.sonar.api.issue.impact.SoftwareQuality;
import org.sonar.api.rule.RuleStatus;
import org.sonar.api.rules.CleanCodeAttribute;
import org.sonar.core.rule.RuleType;
import org.sonar.api.server.debt.DebtRemediationFunction;
import org.sonar.api.server.rule.RulesDefinition;
import org.sonar.api.utils.System2;
import org.sonar.api.utils.log.Logger;
import org.sonar.api.utils.log.Loggers;
import org.sonar.api.utils.log.Profiler;
import org.sonar.core.util.UuidFactory;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.issue.ImpactDto;
import org.sonar.db.qualityprofile.ActiveRuleDto;
import org.sonar.db.qualityprofile.ActiveRuleParamDto;
import org.sonar.db.rule.DeprecatedRuleKeyDto;
import org.sonar.db.rule.RuleDescriptionSectionDto;
import org.sonar.db.rule.RuleDto;
import org.sonar.db.rule.RuleParamDto;
import org.sonar.server.rule.PluginRuleUpdate;
import org.sonar.server.rule.RuleDescriptionSectionsGeneratorResolver;

import static com.google.common.collect.Sets.difference;
import static java.lang.String.format;
import static java.util.Collections.emptySet;
import static org.apache.commons.lang3.StringUtils.isNotEmpty;

/**
 * The class detects changes between the rule definition coming from plugins during startup and rule from database.
 * In case any changes are detected the rule is updated with the new information from plugin.
 */
public class StartupRuleUpdater {

<span class="fc" id="L67">  private static final Logger LOG = Loggers.get(StartupRuleUpdater.class);</span>

  private final DbClient dbClient;
  private final System2 system2;
  private final UuidFactory uuidFactory;
  private final RuleDescriptionSectionsGeneratorResolver sectionsGeneratorResolver;

  public StartupRuleUpdater(DbClient dbClient, System2 system2, UuidFactory uuidFactory,
<span class="fc" id="L75">    RuleDescriptionSectionsGeneratorResolver sectionsGeneratorResolver) {</span>
<span class="fc" id="L76">    this.dbClient = dbClient;</span>
<span class="fc" id="L77">    this.system2 = system2;</span>
<span class="fc" id="L78">    this.uuidFactory = uuidFactory;</span>
<span class="fc" id="L79">    this.sectionsGeneratorResolver = sectionsGeneratorResolver;</span>
<span class="fc" id="L80">  }</span>

  /**
   * Returns true in case there was any change detected between rule in the database and rule from the plugin.
   */
  RuleChange findChangesAndUpdateRule(RulesDefinition.Rule ruleDef, RuleDto ruleDto) {
<span class="fc" id="L86">    RuleChange ruleChange = new RuleChange(ruleDto);</span>
<span class="fc" id="L87">    boolean ruleMerged = mergeRule(ruleDef, ruleDto, ruleChange);</span>
<span class="fc" id="L88">    boolean debtDefinitionsMerged = mergeDebtDefinitions(ruleDef, ruleDto);</span>
<span class="fc" id="L89">    boolean tagsMerged = mergeTags(ruleDef, ruleDto);</span>
<span class="fc" id="L90">    boolean securityStandardsMerged = mergeSecurityStandards(ruleDef, ruleDto);</span>
<span class="fc" id="L91">    boolean educationPrinciplesMerged = mergeEducationPrinciples(ruleDef, ruleDto);</span>
<span class="pc bpc" id="L92" title="2 of 10 branches missed.">    ruleChange.ruleDefinitionChanged = ruleMerged || debtDefinitionsMerged || tagsMerged || securityStandardsMerged || educationPrinciplesMerged;</span>
<span class="fc" id="L93">    return ruleChange;</span>
  }

  void updateDeprecatedKeys(RulesRegistrationContext context, RulesDefinition.Rule ruleDef, RuleDto rule, DbSession dbSession) {
<span class="fc" id="L97">    Set&lt;SingleDeprecatedRuleKey&gt; deprecatedRuleKeysFromDefinition = SingleDeprecatedRuleKey.from(ruleDef);</span>
<span class="fc" id="L98">    Set&lt;SingleDeprecatedRuleKey&gt; deprecatedRuleKeysFromDB = context.getDBDeprecatedKeysFor(rule);</span>

    // DeprecatedKeys that must be deleted
<span class="fc" id="L101">    List&lt;String&gt; uuidsToBeDeleted = difference(deprecatedRuleKeysFromDB, deprecatedRuleKeysFromDefinition).stream()</span>
<span class="fc" id="L102">      .map(SingleDeprecatedRuleKey::getUuid)</span>
<span class="fc" id="L103">      .toList();</span>

<span class="fc" id="L105">    dbClient.ruleDao().deleteDeprecatedRuleKeys(dbSession, uuidsToBeDeleted);</span>

    // DeprecatedKeys that must be created
<span class="fc" id="L108">    Sets.SetView&lt;SingleDeprecatedRuleKey&gt; deprecatedRuleKeysToBeCreated = difference(deprecatedRuleKeysFromDefinition, deprecatedRuleKeysFromDB);</span>

<span class="fc" id="L110">    deprecatedRuleKeysToBeCreated</span>
<span class="fc" id="L111">      .forEach(r -&gt; dbClient.ruleDao().insert(dbSession, new DeprecatedRuleKeyDto()</span>
<span class="fc" id="L112">        .setUuid(uuidFactory.create())</span>
<span class="fc" id="L113">        .setRuleUuid(rule.getUuid())</span>
<span class="fc" id="L114">        .setOldRepositoryKey(r.getOldRepositoryKey())</span>
<span class="fc" id="L115">        .setOldRuleKey(r.getOldRuleKey())</span>
<span class="fc" id="L116">        .setCreatedAt(system2.now())));</span>
<span class="fc" id="L117">  }</span>

  private boolean mergeRule(RulesDefinition.Rule def, RuleDto dto, RuleChange ruleChange) {
<span class="fc" id="L120">    boolean changed = false;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (!Objects.equals(dto.getName(), def.name())) {</span>
<span class="fc" id="L122">      dto.setName(def.name());</span>
<span class="fc" id="L123">      changed = true;</span>
    }
<span class="fc bfc" id="L125" title="All 2 branches covered.">    if (mergeDescription(def, dto)) {</span>
<span class="fc" id="L126">      changed = true;</span>
    }
<span class="fc bfc" id="L128" title="All 2 branches covered.">    if (!Objects.equals(dto.getPluginKey(), def.pluginKey())) {</span>
<span class="fc" id="L129">      dto.setPluginKey(def.pluginKey());</span>
<span class="fc" id="L130">      changed = true;</span>
    }
<span class="fc bfc" id="L132" title="All 2 branches covered.">    if (!Objects.equals(dto.getConfigKey(), def.internalKey())) {</span>
<span class="fc" id="L133">      dto.setConfigKey(def.internalKey());</span>
<span class="fc" id="L134">      changed = true;</span>
    }
<span class="fc" id="L136">    String severity = def.severity();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">    if (!Objects.equals(dto.getSeverityString(), severity)) {</span>
<span class="fc" id="L138">      dto.setSeverity(severity);</span>
<span class="fc" id="L139">      changed = true;</span>
    }
<span class="fc" id="L141">    boolean isTemplate = def.template();</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">    if (isTemplate != dto.isTemplate()) {</span>
<span class="nc" id="L143">      dto.setIsTemplate(isTemplate);</span>
<span class="nc" id="L144">      changed = true;</span>
    }
<span class="fc bfc" id="L146" title="All 2 branches covered.">    if (def.status() != dto.getStatus()) {</span>
<span class="fc" id="L147">      dto.setStatus(def.status());</span>
<span class="fc" id="L148">      changed = true;</span>
    }
<span class="fc bfc" id="L150" title="All 2 branches covered.">    if (!Objects.equals(dto.getScope().name(), def.scope().name())) {</span>
<span class="fc" id="L151">      dto.setScope(RuleDto.Scope.valueOf(def.scope().name()));</span>
<span class="fc" id="L152">      changed = true;</span>
    }
<span class="fc bfc" id="L154" title="All 2 branches covered.">    if (!Objects.equals(dto.getLanguage(), def.repository().language())) {</span>
<span class="fc" id="L155">      dto.setLanguage(def.repository().language());</span>
<span class="fc" id="L156">      changed = true;</span>
    }
<span class="fc" id="L158">    RuleType type = RuleType.valueOf(def.type().name());</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">    if (!Objects.equals(dto.getType(), type.getDbConstant())) {</span>
<span class="fc" id="L160">      dto.setType(type);</span>
<span class="fc" id="L161">      changed = true;</span>
    }
<span class="fc" id="L163">    changed |= mergeCleanCodeAttribute(def, dto, ruleChange);</span>
<span class="fc" id="L164">    changed |= mergeImpacts(def, dto, ruleChange);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (dto.isAdHoc()) {</span>
<span class="fc" id="L166">      dto.setIsAdHoc(false);</span>
<span class="fc" id="L167">      changed = true;</span>
    }
<span class="fc" id="L169">    return changed;</span>
  }

  private static boolean mergeCleanCodeAttribute(RulesDefinition.Rule def, RuleDto dto, RuleChange ruleChange) {
<span class="fc bfc" id="L173" title="All 2 branches covered.">    if (dto.getEnumType() == RuleType.SECURITY_HOTSPOT) {</span>
<span class="fc" id="L174">      return false;</span>
    }
<span class="fc" id="L176">    boolean changed = false;</span>
<span class="fc" id="L177">    CleanCodeAttribute defCleanCodeAttribute = def.cleanCodeAttribute();</span>
<span class="fc bfc" id="L178" title="All 4 branches covered.">    if (!Objects.equals(dto.getCleanCodeAttribute(), defCleanCodeAttribute) &amp;&amp; (defCleanCodeAttribute != null)) {</span>
<span class="fc" id="L179">      ruleChange.addCleanCodeAttributeChange(dto.getCleanCodeAttribute(), defCleanCodeAttribute);</span>
<span class="fc" id="L180">      dto.setCleanCodeAttribute(defCleanCodeAttribute);</span>
<span class="fc" id="L181">      changed = true;</span>
    }
    // apply non-nullable default
<span class="fc bfc" id="L184" title="All 2 branches covered.">    if (dto.getCleanCodeAttribute() == null) {</span>
<span class="fc" id="L185">      dto.setCleanCodeAttribute(CleanCodeAttribute.defaultCleanCodeAttribute());</span>
<span class="fc" id="L186">      changed = true;</span>
    }
<span class="fc" id="L188">    return changed;</span>
  }

  boolean mergeImpacts(RulesDefinition.Rule def, RuleDto dto, RuleChange ruleChange) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">    if (dto.getEnumType() == RuleType.SECURITY_HOTSPOT) {</span>
<span class="fc" id="L193">      return false;</span>
    }

<span class="fc" id="L196">    Map&lt;SoftwareQuality, Severity&gt; impactsFromPlugin = def.defaultImpacts();</span>
<span class="fc" id="L197">    Map&lt;SoftwareQuality, Severity&gt; impactsFromDb = dto.getDefaultImpacts().stream().collect(Collectors.toMap(ImpactDto::getSoftwareQuality, ImpactDto::getSeverity));</span>

<span class="pc bpc" id="L199" title="1 of 2 branches missed.">    if (impactsFromPlugin.isEmpty()) {</span>
<span class="nc" id="L200">      throw new IllegalStateException(&quot;There should be at least one impact defined for the rule &quot; + def.key());</span>
    }

<span class="fc bfc" id="L203" title="All 2 branches covered.">    if (!Objects.equals(impactsFromDb, impactsFromPlugin)) {</span>
<span class="fc" id="L204">      dto.replaceAllDefaultImpacts(impactsFromPlugin.entrySet()</span>
<span class="fc" id="L205">        .stream()</span>
<span class="fc" id="L206">        .map(e -&gt; new ImpactDto().setSoftwareQuality(e.getKey()).setSeverity(e.getValue()))</span>
<span class="fc" id="L207">        .collect(Collectors.toSet()));</span>
<span class="fc" id="L208">      ruleChange.addImpactsChange(removeDuplicatedImpacts(impactsFromDb, impactsFromPlugin), removeDuplicatedImpacts(impactsFromPlugin, impactsFromDb));</span>

<span class="fc" id="L210">      return true;</span>
    }

<span class="fc" id="L213">    return false;</span>
  }

  /**
   * Returns a new map that contains only the impacts from the first map that are not present in the map passed as a second argument.
   */
  private static Map&lt;SoftwareQuality, Severity&gt; removeDuplicatedImpacts(Map&lt;SoftwareQuality, Severity&gt; impactsA, Map&lt;SoftwareQuality, Severity&gt; impactsB) {
<span class="fc" id="L220">    return impactsA.entrySet().stream()</span>
<span class="fc bfc" id="L221" title="All 4 branches covered.">      .filter(entry -&gt; !impactsB.containsKey(entry.getKey()) || !impactsB.get(entry.getKey()).equals(entry.getValue()))</span>
<span class="fc" id="L222">      .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span>
  }

  private static boolean mergeEducationPrinciples(RulesDefinition.Rule ruleDef, RuleDto dto) {
<span class="fc" id="L226">    boolean changed = false;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">    if (dto.getEducationPrinciples().size() != ruleDef.educationPrincipleKeys().size() ||</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">      !dto.getEducationPrinciples().containsAll(ruleDef.educationPrincipleKeys())) {</span>
<span class="fc" id="L229">      dto.setEducationPrinciples(ruleDef.educationPrincipleKeys());</span>
<span class="fc" id="L230">      changed = true;</span>
    }
<span class="fc" id="L232">    return changed;</span>
  }

  private static boolean mergeTags(RulesDefinition.Rule ruleDef, RuleDto dto) {
<span class="fc" id="L236">    boolean changed = false;</span>

<span class="pc bpc" id="L238" title="1 of 2 branches missed.">    if (RuleStatus.REMOVED == ruleDef.status()) {</span>
<span class="nc" id="L239">      dto.setSystemTags(emptySet());</span>
<span class="nc" id="L240">      changed = true;</span>
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">    } else if (dto.getSystemTags().size() != ruleDef.tags().size() || !dto.getSystemTags().containsAll(ruleDef.tags())) {</span>
<span class="fc" id="L242">      dto.setSystemTags(ruleDef.tags());</span>
<span class="fc" id="L243">      changed = true;</span>
    }
<span class="fc" id="L245">    return changed;</span>
  }

  private static boolean mergeSecurityStandards(RulesDefinition.Rule ruleDef, RuleDto dto) {
<span class="fc" id="L249">    boolean changed = false;</span>
<span class="fc" id="L250">    Set&lt;String&gt; securityStandards = dto.getSecurityStandards();</span>

<span class="pc bpc" id="L252" title="1 of 2 branches missed.">    if (RuleStatus.REMOVED == ruleDef.status()) {</span>
<span class="nc" id="L253">      dto.setSecurityStandards(emptySet());</span>
<span class="nc" id="L254">      changed = true;</span>
<span class="pc bpc" id="L255" title="1 of 4 branches missed.">    } else if (securityStandards.size() != ruleDef.securityStandards().size() || !securityStandards.containsAll(ruleDef.securityStandards())) {</span>
<span class="fc" id="L256">      dto.setSecurityStandards(ruleDef.securityStandards());</span>
<span class="fc" id="L257">      changed = true;</span>
    }
<span class="fc" id="L259">    return changed;</span>
  }

  private static boolean containsHtmlDescription(RulesDefinition.Rule rule) {
<span class="pc bpc" id="L263" title="1 of 4 branches missed.">    return isNotEmpty(rule.htmlDescription()) || !rule.ruleDescriptionSections().isEmpty();</span>
  }

  private static boolean ruleDescriptionSectionsUnchanged(RuleDto ruleDto, Set&lt;RuleDescriptionSectionDto&gt; newRuleDescriptionSectionDtos) {
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">    if (ruleDto.getRuleDescriptionSectionDtos().size() != newRuleDescriptionSectionDtos.size()) {</span>
<span class="nc" id="L268">      return false;</span>
    }
<span class="fc" id="L270">    return ruleDto.getRuleDescriptionSectionDtos().stream()</span>
<span class="fc" id="L271">      .allMatch(sectionDto -&gt; contains(newRuleDescriptionSectionDtos, sectionDto));</span>
  }

  private static boolean contains(Set&lt;RuleDescriptionSectionDto&gt; sectionDtos, RuleDescriptionSectionDto sectionDto) {
<span class="fc" id="L275">    return sectionDtos.stream()</span>
<span class="fc bfc" id="L276" title="All 4 branches covered.">      .filter(s -&gt; s.getKey().equals(sectionDto.getKey()) &amp;&amp; s.getContent().equals(sectionDto.getContent()))</span>
<span class="fc" id="L277">      .anyMatch(s -&gt; Objects.equals(s.getContext(), sectionDto.getContext()));</span>
  }

  private static boolean mergeDebtDefinitions(RuleDto dto, @Nullable String remediationFunction,
    @Nullable String remediationCoefficient, @Nullable String remediationOffset, @Nullable String gapDescription) {
<span class="fc" id="L282">    boolean changed = false;</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">    if (!Objects.equals(dto.getDefRemediationFunction(), remediationFunction)) {</span>
<span class="fc" id="L285">      dto.setDefRemediationFunction(remediationFunction);</span>
<span class="fc" id="L286">      changed = true;</span>
    }
<span class="fc bfc" id="L288" title="All 2 branches covered.">    if (!Objects.equals(dto.getDefRemediationGapMultiplier(), remediationCoefficient)) {</span>
<span class="fc" id="L289">      dto.setDefRemediationGapMultiplier(remediationCoefficient);</span>
<span class="fc" id="L290">      changed = true;</span>
    }
<span class="fc bfc" id="L292" title="All 2 branches covered.">    if (!Objects.equals(dto.getDefRemediationBaseEffort(), remediationOffset)) {</span>
<span class="fc" id="L293">      dto.setDefRemediationBaseEffort(remediationOffset);</span>
<span class="fc" id="L294">      changed = true;</span>
    }
<span class="fc bfc" id="L296" title="All 2 branches covered.">    if (!Objects.equals(dto.getGapDescription(), gapDescription)) {</span>
<span class="fc" id="L297">      dto.setGapDescription(gapDescription);</span>
<span class="fc" id="L298">      changed = true;</span>
    }
<span class="fc" id="L300">    return changed;</span>
  }

  private static boolean mergeDebtDefinitions(RulesDefinition.Rule def, RuleDto dto) {
    // Debt definitions are set to null if the sub-characteristic and the remediation function are null
<span class="fc" id="L305">    DebtRemediationFunction debtRemediationFunction = def.debtRemediationFunction();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">    boolean hasDebt = debtRemediationFunction != null;</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">    if (hasDebt) {</span>
<span class="fc" id="L308">      return mergeDebtDefinitions(dto,</span>
<span class="fc" id="L309">        debtRemediationFunction.type().name(),</span>
<span class="fc" id="L310">        debtRemediationFunction.gapMultiplier(),</span>
<span class="fc" id="L311">        debtRemediationFunction.baseEffort(),</span>
<span class="fc" id="L312">        def.gapDescription());</span>
    }
<span class="fc" id="L314">    return mergeDebtDefinitions(dto, null, null, null, null);</span>
  }

  private boolean mergeDescription(RulesDefinition.Rule rule, RuleDto ruleDto) {
<span class="fc" id="L318">    Set&lt;RuleDescriptionSectionDto&gt; newRuleDescriptionSectionDtos = sectionsGeneratorResolver.generateFor(rule);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">    if (ruleDescriptionSectionsUnchanged(ruleDto, newRuleDescriptionSectionDtos)) {</span>
<span class="fc" id="L320">      return false;</span>
    }
<span class="fc" id="L322">    ruleDto.replaceRuleDescriptionSectionDtos(newRuleDescriptionSectionDtos);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">    if (containsHtmlDescription(rule)) {</span>
<span class="fc" id="L324">      ruleDto.setDescriptionFormat(RuleDto.Format.HTML);</span>
<span class="fc" id="L325">      return true;</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">    } else if (isNotEmpty(rule.markdownDescription())) {</span>
<span class="fc" id="L327">      ruleDto.setDescriptionFormat(RuleDto.Format.MARKDOWN);</span>
<span class="fc" id="L328">      return true;</span>
    }
<span class="nc" id="L330">    return false;</span>
  }

  void mergeParams(RulesRegistrationContext context, RulesDefinition.Rule ruleDef, RuleDto rule, DbSession session) {
<span class="fc" id="L334">    List&lt;RuleParamDto&gt; paramDtos = context.getRuleParametersFor(rule.getUuid());</span>
<span class="fc" id="L335">    Map&lt;String, RuleParamDto&gt; existingParamsByName = new HashMap&lt;&gt;();</span>

<span class="fc" id="L337">    Profiler profiler = Profiler.create(LOG);</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">    for (RuleParamDto paramDto : paramDtos) {</span>
<span class="fc" id="L339">      RulesDefinition.Param paramDef = ruleDef.param(paramDto.getName());</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">      if (paramDef == null) {</span>
<span class="nc" id="L341">        profiler.start();</span>
<span class="nc" id="L342">        dbClient.activeRuleDao().deleteParamsByRuleParam(session, paramDto);</span>
<span class="nc" id="L343">        profiler.stopDebug(format(&quot;Propagate deleted param with name %s to active rules of rule %s&quot;, paramDto.getName(), rule.getKey()));</span>
<span class="nc" id="L344">        dbClient.ruleDao().deleteRuleParam(session, paramDto.getUuid());</span>
      } else {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (mergeParam(paramDto, paramDef)) {</span>
<span class="fc" id="L347">          dbClient.ruleDao().updateRuleParam(session, rule, paramDto);</span>
        }
<span class="fc" id="L349">        existingParamsByName.put(paramDto.getName(), paramDto);</span>
      }
<span class="fc" id="L351">    }</span>

    // Create newly parameters
<span class="fc bfc" id="L354" title="All 2 branches covered.">    for (RulesDefinition.Param param : ruleDef.params()) {</span>
<span class="fc" id="L355">      RuleParamDto paramDto = existingParamsByName.get(param.key());</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">      if (paramDto != null) {</span>
<span class="fc" id="L357">        continue;</span>
      }
<span class="fc" id="L359">      paramDto = RuleParamDto.createFor(rule)</span>
<span class="fc" id="L360">        .setName(param.key())</span>
<span class="fc" id="L361">        .setDescription(param.description())</span>
<span class="fc" id="L362">        .setDefaultValue(param.defaultValue())</span>
<span class="fc" id="L363">        .setType(param.type().toString());</span>
<span class="fc" id="L364">      dbClient.ruleDao().insertRuleParam(session, rule, paramDto);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">      if (StringUtils.isEmpty(param.defaultValue())) {</span>
<span class="fc" id="L366">        continue;</span>
      }
      // Propagate the default value to existing active rule parameters
<span class="fc" id="L369">      profiler.start();</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">      for (ActiveRuleDto activeRule : dbClient.activeRuleDao().selectByRuleUuid(session, rule.getUuid())) {</span>
<span class="nc" id="L371">        ActiveRuleParamDto activeParam = ActiveRuleParamDto.createFor(paramDto).setValue(param.defaultValue());</span>
<span class="nc" id="L372">        dbClient.activeRuleDao().insertParam(session, activeRule, activeParam);</span>
<span class="nc" id="L373">      }</span>
<span class="fc" id="L374">      profiler.stopDebug(format(&quot;Propagate new param with name %s to active rules of rule %s&quot;, paramDto.getName(), rule.getKey()));</span>
<span class="fc" id="L375">    }</span>
<span class="fc" id="L376">  }</span>

  private static boolean mergeParam(RuleParamDto paramDto, RulesDefinition.Param paramDef) {
<span class="fc" id="L379">    boolean changed = false;</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">    if (!Objects.equals(paramDto.getType(), paramDef.type().toString())) {</span>
<span class="nc" id="L381">      paramDto.setType(paramDef.type().toString());</span>
<span class="nc" id="L382">      changed = true;</span>
    }
<span class="fc bfc" id="L384" title="All 2 branches covered.">    if (!Objects.equals(paramDto.getDefaultValue(), paramDef.defaultValue())) {</span>
<span class="fc" id="L385">      paramDto.setDefaultValue(paramDef.defaultValue());</span>
<span class="fc" id="L386">      changed = true;</span>
    }
<span class="fc bfc" id="L388" title="All 2 branches covered.">    if (!Objects.equals(paramDto.getDescription(), paramDef.description())) {</span>
<span class="fc" id="L389">      paramDto.setDescription(paramDef.description());</span>
<span class="fc" id="L390">      changed = true;</span>
    }
<span class="fc" id="L392">    return changed;</span>
  }

  public static class RuleChange {
<span class="fc" id="L396">    private boolean ruleDefinitionChanged = false;</span>
    private final String ruleUuid;
    private PluginRuleUpdate pluginRuleUpdate;

<span class="fc" id="L400">    public RuleChange(RuleDto ruleDto) {</span>
<span class="fc" id="L401">      this.ruleUuid = ruleDto.getUuid();</span>
<span class="fc" id="L402">    }</span>

    private void createPluginRuleUpdateIfNeeded() {
<span class="fc bfc" id="L405" title="All 2 branches covered.">      if (pluginRuleUpdate == null) {</span>
<span class="fc" id="L406">        pluginRuleUpdate = new PluginRuleUpdate();</span>
<span class="fc" id="L407">        pluginRuleUpdate.setRuleUuid(ruleUuid);</span>
      }
<span class="fc" id="L409">    }</span>

    public void addImpactsChange(Map&lt;SoftwareQuality, Severity&gt; oldImpacts, Map&lt;SoftwareQuality, Severity&gt; newImpacts) {
<span class="fc" id="L412">      createPluginRuleUpdateIfNeeded();</span>
<span class="fc" id="L413">      oldImpacts.forEach(pluginRuleUpdate::addOldImpact);</span>
<span class="fc" id="L414">      newImpacts.forEach(pluginRuleUpdate::addNewImpact);</span>
<span class="fc" id="L415">    }</span>

    public void addCleanCodeAttributeChange(@Nullable CleanCodeAttribute oldAttribute, @Nullable CleanCodeAttribute newAttribute) {
<span class="fc" id="L418">      createPluginRuleUpdateIfNeeded();</span>
<span class="fc" id="L419">      pluginRuleUpdate.setOldCleanCodeAttribute(oldAttribute);</span>
<span class="fc" id="L420">      pluginRuleUpdate.setNewCleanCodeAttribute(newAttribute);</span>
<span class="fc" id="L421">    }</span>

    public boolean hasRuleDefinitionChanged() {
<span class="fc" id="L424">      return ruleDefinitionChanged;</span>
    }

    @CheckForNull
    public PluginRuleUpdate getPluginRuleUpdate() {
<span class="fc" id="L429">      return pluginRuleUpdate;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>