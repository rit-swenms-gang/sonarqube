<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserUpdater.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.user</a> &gt; <span class="el_source">UserUpdater.java</span></div><h1>UserUpdater.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.user;

import com.google.common.base.Joiner;
import com.google.common.base.Strings;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Random;
import java.util.function.Consumer;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import jakarta.inject.Inject;
import org.sonar.api.config.Configuration;
import org.sonar.api.platform.NewUserHandler;
import org.sonar.api.server.ServerSide;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.audit.AuditPersister;
import org.sonar.db.audit.model.SecretNewValue;
import org.sonar.db.user.GroupDto;
import org.sonar.db.user.UserDto;
import org.sonar.db.user.UserGroupDto;
import org.sonar.server.authentication.CredentialsLocalAuthentication;
import org.sonar.server.usergroups.DefaultGroupFinder;
import org.sonar.server.util.Validation;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Strings.isNullOrEmpty;
import static com.google.common.collect.Lists.newArrayList;
import static java.lang.String.format;
import static java.util.Collections.emptyList;
import static org.sonar.api.CoreProperties.DEFAULT_ISSUE_ASSIGNEE;
import static org.sonar.core.util.Slug.slugify;
import static org.sonar.server.exceptions.BadRequestException.checkRequest;

@ServerSide
public class UserUpdater {
  private static final String SQ_AUTHORITY = &quot;sonarqube&quot;;

  private static final String LOGIN_PARAM = &quot;Login&quot;;
  private static final String PASSWORD_PARAM = &quot;Password&quot;;
  private static final String NAME_PARAM = &quot;Name&quot;;
  private static final String EMAIL_PARAM = &quot;Email&quot;;
<span class="fc" id="L66">  private static final Pattern START_WITH_SPECIFIC_AUTHORIZED_CHARACTERS = Pattern.compile(&quot;\\w+&quot;);</span>
<span class="fc" id="L67">  private static final Pattern CONTAINS_ONLY_AUTHORIZED_CHARACTERS = Pattern.compile(&quot;\\A\\w[\\w\\.\\-@]+\\z&quot;);</span>

  public static final int LOGIN_MIN_LENGTH = 2;
  public static final int LOGIN_MAX_LENGTH = 255;
  public static final int EMAIL_MAX_LENGTH = 100;
  public static final int NAME_MAX_LENGTH = 200;

  private final NewUserNotifier newUserNotifier;
  private final DbClient dbClient;
  private final DefaultGroupFinder defaultGroupFinder;
  private final AuditPersister auditPersister;
  private final CredentialsLocalAuthentication localAuthentication;
<span class="fc" id="L79">  private final Random random = new SecureRandom();</span>


  @Inject
  public UserUpdater(NewUserNotifier newUserNotifier, DbClient dbClient, DefaultGroupFinder defaultGroupFinder, Configuration config,
<span class="fc" id="L84">    AuditPersister auditPersister, CredentialsLocalAuthentication localAuthentication) {</span>
<span class="fc" id="L85">    this.newUserNotifier = newUserNotifier;</span>
<span class="fc" id="L86">    this.dbClient = dbClient;</span>
<span class="fc" id="L87">    this.defaultGroupFinder = defaultGroupFinder;</span>
<span class="fc" id="L88">    this.auditPersister = auditPersister;</span>
<span class="fc" id="L89">    this.localAuthentication = localAuthentication;</span>
<span class="fc" id="L90">  }</span>

  public UserDto createAndCommit(DbSession dbSession, NewUser newUser, Consumer&lt;UserDto&gt; beforeCommit, UserDto... otherUsersToIndex) {
<span class="fc" id="L93">    UserDto userDto = saveUser(dbSession, createDto(dbSession, newUser));</span>
<span class="fc" id="L94">    return commitUser(dbSession, userDto, beforeCommit, otherUsersToIndex);</span>
  }

  public UserDto reactivateAndCommit(DbSession dbSession, UserDto disabledUser, NewUser newUser, Consumer&lt;UserDto&gt; beforeCommit, UserDto... otherUsersToIndex) {
<span class="fc bfc" id="L98" title="All 2 branches covered.">    checkArgument(!disabledUser.isActive(), &quot;An active user with login '%s' already exists&quot;, disabledUser.getLogin());</span>
<span class="fc" id="L99">    reactivateUser(dbSession, disabledUser, newUser);</span>
<span class="fc" id="L100">    return commitUser(dbSession, disabledUser, beforeCommit, otherUsersToIndex);</span>
  }

  private void reactivateUser(DbSession dbSession, UserDto reactivatedUser, NewUser newUser) {
<span class="fc" id="L104">    UpdateUser updateUser = new UpdateUser()</span>
<span class="fc" id="L105">      .setName(newUser.name())</span>
<span class="fc" id="L106">      .setEmail(newUser.email())</span>
<span class="fc" id="L107">      .setScmAccounts(newUser.scmAccounts());</span>

<span class="fc" id="L109">    Optional&lt;ExternalIdentity&gt; externalIdentity = Optional.ofNullable(newUser.externalIdentity());</span>
<span class="fc" id="L110">    updateUser.setExternalIdentityProvider(externalIdentity.map(ExternalIdentity::getProvider).orElse(null));</span>
<span class="fc" id="L111">    updateUser.setExternalIdentityProviderId(externalIdentity.map(ExternalIdentity::getId).orElse(null));</span>
<span class="fc" id="L112">    updateUser.setExternalIdentityProviderLogin(externalIdentity.map(ExternalIdentity::getLogin).orElse(null));</span>

<span class="fc" id="L114">    String login = newUser.login();</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">    if (login != null) {</span>
<span class="fc" id="L116">      updateUser.setLogin(login);</span>
    }
<span class="fc" id="L118">    String password = newUser.password();</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">    if (password != null) {</span>
<span class="fc" id="L120">      updateUser.setPassword(password);</span>
    }
<span class="fc" id="L122">    updateDto(dbSession, updateUser, reactivatedUser);</span>
<span class="fc" id="L123">    updateUser(dbSession, reactivatedUser);</span>
<span class="fc" id="L124">    addUserToDefaultGroup(dbSession, reactivatedUser);</span>
<span class="fc" id="L125">  }</span>

  public void updateAndCommit(DbSession dbSession, UserDto dto, UpdateUser updateUser, Consumer&lt;UserDto&gt; beforeCommit, UserDto... otherUsersToIndex) {
<span class="fc" id="L128">    boolean isUserUpdated = updateDto(dbSession, updateUser, dto);</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">    if (isUserUpdated) {</span>
      // at least one change. Database must be updated and Elasticsearch re-indexed
<span class="fc" id="L131">      updateUser(dbSession, dto);</span>
<span class="fc" id="L132">      commitUser(dbSession, dto, beforeCommit, otherUsersToIndex);</span>
    } else {
      // no changes but still execute the consumer
<span class="fc" id="L135">      beforeCommit.accept(dto);</span>
<span class="fc" id="L136">      dbSession.commit();</span>
    }
<span class="fc" id="L138">  }</span>

  private UserDto commitUser(DbSession dbSession, UserDto userDto, Consumer&lt;UserDto&gt; beforeCommit, UserDto... otherUsersToIndex) {
<span class="fc" id="L141">    beforeCommit.accept(userDto);</span>
<span class="fc" id="L142">    dbSession.commit();</span>
<span class="fc" id="L143">    notifyNewUser(userDto.getLogin(), userDto.getName(), userDto.getEmail());</span>
<span class="fc" id="L144">    return userDto;</span>
  }

  private UserDto createDto(DbSession dbSession, NewUser newUser) {
<span class="fc" id="L148">    UserDto userDto = new UserDto();</span>
<span class="fc" id="L149">    List&lt;String&gt; messages = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L151">    String login = newUser.login();</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    if (isNullOrEmpty(login)) {</span>
<span class="fc" id="L153">      userDto.setLogin(generateUniqueLogin(dbSession, newUser.name()));</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">    } else if (validateLoginFormat(login, messages)) {</span>
<span class="fc" id="L155">      checkLoginUniqueness(dbSession, login);</span>
<span class="fc" id="L156">      userDto.setLogin(login);</span>
    }

<span class="fc" id="L159">    String name = newUser.name();</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (validateNameFormat(name, messages)) {</span>
<span class="fc" id="L161">      userDto.setName(name);</span>
    }

<span class="fc" id="L164">    String email = newUser.email();</span>
<span class="fc bfc" id="L165" title="All 4 branches covered.">    if (email != null &amp;&amp; validateEmailFormat(email, messages)) {</span>
<span class="fc" id="L166">      userDto.setEmail(email);</span>
    }

<span class="fc" id="L169">    String password = newUser.password();</span>
<span class="fc bfc" id="L170" title="All 4 branches covered.">    if (password != null &amp;&amp; validatePasswords(password, messages)) {</span>
<span class="fc" id="L171">      localAuthentication.storeHashPassword(userDto, password);</span>
    }

<span class="fc" id="L174">    List&lt;String&gt; scmAccounts = sanitizeScmAccounts(newUser.scmAccounts());</span>
<span class="pc bpc" id="L175" title="1 of 6 branches missed.">    if (scmAccounts != null &amp;&amp; !scmAccounts.isEmpty() &amp;&amp; validateScmAccounts(dbSession, scmAccounts, login, email, null, messages)) {</span>
<span class="fc" id="L176">      userDto.setScmAccounts(scmAccounts);</span>
    }

<span class="fc" id="L179">    setExternalIdentity(dbSession, userDto, ExternalIdentityLocal.fromExternalIdentity(newUser.externalIdentity()));</span>

<span class="fc" id="L181">    checkRequest(messages.isEmpty(), messages);</span>
<span class="fc" id="L182">    return userDto;</span>
  }

  private String generateUniqueLogin(DbSession dbSession, String userName) {
<span class="fc" id="L186">    String slugName = slugify(userName);</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">    for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L188">      String login = slugName + random.nextInt(100_000);</span>
<span class="fc" id="L189">      UserDto existingUser = dbClient.userDao().selectByLogin(dbSession, login);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">      if (existingUser == null) {</span>
<span class="fc" id="L191">        return login;</span>
      }
    }
<span class="nc" id="L194">    throw new IllegalStateException(&quot;Cannot create unique login for user name &quot; + userName);</span>
  }

  private boolean updateDto(DbSession dbSession, UpdateUser update, UserDto dto) {
<span class="fc" id="L198">    List&lt;String&gt; messages = newArrayList();</span>
<span class="fc" id="L199">    boolean changed = updateLogin(dbSession, update, dto, messages);</span>
<span class="fc" id="L200">    changed |= updateName(update, dto, messages);</span>
<span class="fc" id="L201">    changed |= updateEmail(update, dto, messages);</span>
<span class="fc" id="L202">    changed |= updateExternalIdentity(dbSession, update, dto);</span>
<span class="fc" id="L203">    changed |= updatePassword(dbSession, update, dto, messages);</span>
<span class="fc" id="L204">    changed |= updateScmAccounts(dbSession, update, dto, messages);</span>
<span class="fc" id="L205">    checkRequest(messages.isEmpty(), messages);</span>
<span class="fc" id="L206">    return changed;</span>
  }

  private boolean updateLogin(DbSession dbSession, UpdateUser updateUser, UserDto userDto, List&lt;String&gt; messages) {
<span class="fc" id="L210">    String newLogin = updateUser.login();</span>
<span class="fc bfc" id="L211" title="All 6 branches covered.">    if (!updateUser.isLoginChanged() || !validateLoginFormat(newLogin, messages) || Objects.equals(userDto.getLogin(), newLogin)) {</span>
<span class="fc" id="L212">      return false;</span>
    }
<span class="fc" id="L214">    checkLoginUniqueness(dbSession, newLogin);</span>
<span class="fc" id="L215">    dbClient.propertiesDao().selectByKeyAndMatchingValue(dbSession, DEFAULT_ISSUE_ASSIGNEE, userDto.getLogin())</span>
<span class="fc" id="L216">      .forEach(p -&gt; dbClient.propertiesDao().saveProperty(p.setValue(newLogin)));</span>
<span class="fc" id="L217">    userDto.setLogin(newLogin);</span>
<span class="fc bfc" id="L218" title="All 4 branches covered.">    if (userDto.isLocal() || SQ_AUTHORITY.equals(userDto.getExternalIdentityProvider())) {</span>
<span class="fc" id="L219">      userDto.setExternalLogin(newLogin);</span>
<span class="fc" id="L220">      userDto.setExternalId(newLogin);</span>
    }
<span class="fc" id="L222">    return true;</span>
  }

  private static boolean updateName(UpdateUser updateUser, UserDto userDto, List&lt;String&gt; messages) {
<span class="fc" id="L226">    String name = updateUser.name();</span>
<span class="pc bpc" id="L227" title="1 of 6 branches missed.">    if (updateUser.isNameChanged() &amp;&amp; validateNameFormat(name, messages) &amp;&amp; !Objects.equals(userDto.getName(), name)) {</span>
<span class="fc" id="L228">      userDto.setName(name);</span>
<span class="fc" id="L229">      return true;</span>
    }
<span class="fc" id="L231">    return false;</span>
  }

  private static boolean updateEmail(UpdateUser updateUser, UserDto userDto, List&lt;String&gt; messages) {
<span class="fc" id="L235">    String email = updateUser.email();</span>
<span class="pc bpc" id="L236" title="1 of 6 branches missed.">    if (updateUser.isEmailChanged() &amp;&amp; validateEmailFormat(email, messages) &amp;&amp; !Objects.equals(userDto.getEmail(), email)) {</span>
<span class="fc" id="L237">      userDto.setEmail(email);</span>
<span class="fc" id="L238">      return true;</span>
    }
<span class="fc" id="L240">    return false;</span>
  }

  private boolean updateExternalIdentity(DbSession dbSession, UpdateUser updateUser, UserDto userDto) {
<span class="fc bfc" id="L244" title="All 2 branches covered.">    if (externalIdentityChanged(updateUser)) {</span>
<span class="fc" id="L245">      ExternalIdentityLocal externalIdentityLocal = ExternalIdentityLocal.fromUpdateUser(updateUser);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">      if (!externalIdentityLocal.isSameExternalIdentity(userDto)) {</span>
<span class="fc" id="L247">        setExternalIdentity(dbSession, userDto, externalIdentityLocal);</span>
<span class="fc" id="L248">        return true;</span>
      }
    }
<span class="fc" id="L251">    return false;</span>
  }

  private static boolean externalIdentityChanged(UpdateUser updateUser) {
<span class="pc bpc" id="L255" title="1 of 6 branches missed.">    return updateUser.isExternalIdentityProviderChanged() || updateUser.isExternalIdentityProviderIdChanged() || updateUser.isExternalIdentityProviderLoginChanged();</span>
  }


  private boolean updatePassword(DbSession dbSession, UpdateUser updateUser, UserDto userDto, List&lt;String&gt; messages) {
<span class="fc" id="L260">    String password = updateUser.password();</span>
<span class="fc bfc" id="L261" title="All 6 branches covered.">    if (updateUser.isPasswordChanged() &amp;&amp; validatePasswords(password, messages) &amp;&amp; checkPasswordChangeAllowed(userDto, messages)) {</span>
<span class="fc" id="L262">      localAuthentication.storeHashPassword(userDto, password);</span>
<span class="fc" id="L263">      userDto.setResetPassword(false);</span>
<span class="fc" id="L264">      auditPersister.updateUserPassword(dbSession, new SecretNewValue(&quot;userLogin&quot;, userDto.getLogin()));</span>
<span class="fc" id="L265">      return true;</span>
    }
<span class="fc" id="L267">    return false;</span>
  }

  private boolean updateScmAccounts(DbSession dbSession, UpdateUser updateUser, UserDto userDto, List&lt;String&gt; messages) {
<span class="fc" id="L271">    String email = updateUser.email();</span>
<span class="fc" id="L272">    List&lt;String&gt; scmAccounts = sanitizeScmAccounts(updateUser.scmAccounts());</span>
<span class="fc" id="L273">    List&lt;String&gt; existingScmAccounts = userDto.getSortedScmAccounts();</span>
<span class="fc bfc" id="L274" title="All 6 branches covered.">    if (updateUser.isScmAccountsChanged() &amp;&amp; !(existingScmAccounts.containsAll(scmAccounts) &amp;&amp; scmAccounts.containsAll(existingScmAccounts))) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">      if (!scmAccounts.isEmpty()) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        String newOrOldEmail = email != null ? email : userDto.getEmail();</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (validateScmAccounts(dbSession, scmAccounts, userDto.getLogin(), newOrOldEmail, userDto, messages)) {</span>
<span class="fc" id="L278">          userDto.setScmAccounts(scmAccounts);</span>
        }
<span class="fc" id="L280">      } else {</span>
<span class="fc" id="L281">        userDto.setScmAccounts(emptyList());</span>
      }
<span class="fc" id="L283">      return true;</span>
    }
<span class="fc" id="L285">    return false;</span>
  }


  private void setExternalIdentity(DbSession dbSession, UserDto dto, ExternalIdentityLocal externalIdentity) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">    if (externalIdentity.isEmpty()) {</span>
<span class="fc" id="L291">      dto.setExternalLogin(dto.getLogin());</span>
<span class="fc" id="L292">      dto.setExternalIdentityProvider(SQ_AUTHORITY);</span>
<span class="fc" id="L293">      dto.setExternalId(dto.getLogin());</span>
<span class="fc" id="L294">      dto.setLocal(true);</span>
    } else {
<span class="fc" id="L296">      dto.setExternalLogin(Optional.ofNullable(externalIdentity.login()).orElse(dto.getExternalLogin()));</span>
<span class="fc" id="L297">      dto.setExternalIdentityProvider(Optional.ofNullable(externalIdentity.provider()).orElse(dto.getExternalIdentityProvider()));</span>
<span class="fc" id="L298">      dto.setExternalId(Optional.ofNullable(externalIdentity.id()).orElse(dto.getExternalId()));</span>
<span class="fc" id="L299">      dto.setLocal(false);</span>
<span class="fc" id="L300">      dto.setSalt(null);</span>
<span class="fc" id="L301">      dto.setCryptedPassword(null);</span>
    }
<span class="fc" id="L303">    UserDto existingUser = dbClient.userDao().selectByExternalIdAndIdentityProvider(dbSession, dto.getExternalId(),</span>
<span class="fc" id="L304">      dto.getExternalIdentityProvider());</span>
<span class="fc bfc" id="L305" title="All 4 branches covered.">    checkArgument(existingUser == null || Objects.equals(dto.getUuid(), existingUser.getUuid()),</span>
<span class="fc" id="L306">      &quot;A user with provider id '%s' and identity provider '%s' already exists&quot;, dto.getExternalId(), dto.getExternalIdentityProvider());</span>
<span class="fc" id="L307">  }</span>

  private static boolean checkNotEmptyParam(@Nullable String value, String param, List&lt;String&gt; messages) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">    if (isNullOrEmpty(value)) {</span>
<span class="fc" id="L311">      messages.add(format(Validation.CANT_BE_EMPTY_MESSAGE, param));</span>
<span class="fc" id="L312">      return false;</span>
    }
<span class="fc" id="L314">    return true;</span>
  }

  private static boolean validateLoginFormat(@Nullable String login, List&lt;String&gt; messages) {
<span class="fc" id="L318">    boolean isValid = checkNotEmptyParam(login, LOGIN_PARAM, messages);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">    if (isValid) {</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">      if (login.length() &lt; LOGIN_MIN_LENGTH) {</span>
<span class="fc" id="L321">        messages.add(format(Validation.IS_TOO_SHORT_MESSAGE, LOGIN_PARAM, LOGIN_MIN_LENGTH));</span>
<span class="fc" id="L322">        return false;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">      } else if (login.length() &gt; LOGIN_MAX_LENGTH) {</span>
<span class="fc" id="L324">        messages.add(format(Validation.IS_TOO_LONG_MESSAGE, LOGIN_PARAM, LOGIN_MAX_LENGTH));</span>
<span class="fc" id="L325">        return false;</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">      } else if (!startWithUnderscoreOrAlphanumeric(login)) {</span>
<span class="fc" id="L327">        messages.add(&quot;Login should start with _ or alphanumeric.&quot;);</span>
<span class="fc" id="L328">        return false;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">      } else if (!CONTAINS_ONLY_AUTHORIZED_CHARACTERS.matcher(login).matches()) {</span>
<span class="fc" id="L330">        messages.add(&quot;Login should contain only letters, numbers, and .-_@&quot;);</span>
<span class="fc" id="L331">        return false;</span>
      }
    }
<span class="fc" id="L334">    return isValid;</span>
  }

  private static boolean startWithUnderscoreOrAlphanumeric(String login) {
<span class="fc" id="L338">    String firstCharacter = login.substring(0, 1);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">    if (&quot;_&quot;.equals(firstCharacter)) {</span>
<span class="fc" id="L340">      return true;</span>
    }
<span class="fc" id="L342">    return START_WITH_SPECIFIC_AUTHORIZED_CHARACTERS.matcher(firstCharacter).matches();</span>
  }

  private static boolean validateNameFormat(@Nullable String name, List&lt;String&gt; messages) {
<span class="fc" id="L346">    boolean isValid = checkNotEmptyParam(name, NAME_PARAM, messages);</span>
<span class="fc bfc" id="L347" title="All 4 branches covered.">    if (name != null &amp;&amp; name.length() &gt; NAME_MAX_LENGTH) {</span>
<span class="fc" id="L348">      messages.add(format(Validation.IS_TOO_LONG_MESSAGE, NAME_PARAM, 200));</span>
<span class="fc" id="L349">      return false;</span>
    }
<span class="fc" id="L351">    return isValid;</span>
  }

  private static boolean validateEmailFormat(@Nullable String email, List&lt;String&gt; messages) {
<span class="fc bfc" id="L355" title="All 4 branches covered.">    if (email != null &amp;&amp; email.length() &gt; EMAIL_MAX_LENGTH) {</span>
<span class="fc" id="L356">      messages.add(format(Validation.IS_TOO_LONG_MESSAGE, EMAIL_PARAM, 100));</span>
<span class="fc" id="L357">      return false;</span>
    }
<span class="fc" id="L359">    return true;</span>
  }

  private static boolean checkPasswordChangeAllowed(UserDto userDto, List&lt;String&gt; messages) {
<span class="fc bfc" id="L363" title="All 2 branches covered.">    if (!userDto.isLocal()) {</span>
<span class="fc" id="L364">      messages.add(&quot;Password cannot be changed when external authentication is used&quot;);</span>
<span class="fc" id="L365">      return false;</span>
    }
<span class="fc" id="L367">    return true;</span>
  }

  private static boolean validatePasswords(@Nullable String password, List&lt;String&gt; messages) {
<span class="fc bfc" id="L371" title="All 4 branches covered.">    if (password == null || password.length() == 0) {</span>
<span class="fc" id="L372">      messages.add(format(Validation.CANT_BE_EMPTY_MESSAGE, PASSWORD_PARAM));</span>
<span class="fc" id="L373">      return false;</span>
    }
<span class="fc" id="L375">    return true;</span>
  }

  private boolean validateScmAccounts(DbSession dbSession, List&lt;String&gt; scmAccounts, @Nullable String login, @Nullable String email, @Nullable UserDto existingUser,
    List&lt;String&gt; messages) {
<span class="fc" id="L380">    boolean isValid = true;</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">    for (String scmAccount : scmAccounts) {</span>
<span class="fc bfc" id="L382" title="All 4 branches covered.">      if (scmAccount.equals(login) || scmAccount.equals(email)) {</span>
<span class="fc" id="L383">        messages.add(&quot;Login and email are automatically considered as SCM accounts&quot;);</span>
<span class="fc" id="L384">        isValid = false;</span>
      } else {
<span class="fc" id="L386">        List&lt;UserDto&gt; matchingUsers = dbClient.userDao().selectByScmAccountOrLoginOrEmail(dbSession, scmAccount);</span>
<span class="fc" id="L387">        List&lt;String&gt; matchingUsersWithoutExistingUser = newArrayList();</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">        for (UserDto matchingUser : matchingUsers) {</span>
<span class="pc bpc" id="L389" title="1 of 4 branches missed.">          if (existingUser != null &amp;&amp; matchingUser.getUuid().equals(existingUser.getUuid())) {</span>
<span class="nc" id="L390">            continue;</span>
          }
<span class="fc" id="L392">          matchingUsersWithoutExistingUser.add(getNameOrLogin(matchingUser) + &quot; (&quot; + matchingUser.getLogin() + &quot;)&quot;);</span>
<span class="fc" id="L393">        }</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (!matchingUsersWithoutExistingUser.isEmpty()) {</span>
<span class="fc" id="L395">          messages.add(format(&quot;The scm account '%s' is already used by user(s) : '%s'&quot;, scmAccount, Joiner.on(&quot;, &quot;).join(matchingUsersWithoutExistingUser)));</span>
<span class="fc" id="L396">          isValid = false;</span>
        }
      }
<span class="fc" id="L399">    }</span>
<span class="fc" id="L400">    return isValid;</span>
  }

  private static String getNameOrLogin(UserDto user) {
<span class="fc" id="L404">    String name = user.getName();</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">    return name != null ? name : user.getLogin();</span>
  }

  private static List&lt;String&gt; sanitizeScmAccounts(@Nullable List&lt;String&gt; scmAccounts) {
<span class="fc bfc" id="L409" title="All 2 branches covered.">    if (scmAccounts != null) {</span>
<span class="fc" id="L410">      return new HashSet&lt;&gt;(scmAccounts).stream()</span>
<span class="fc" id="L411">        .map(Strings::emptyToNull)</span>
<span class="fc" id="L412">        .filter(Objects::nonNull)</span>
<span class="fc" id="L413">        .sorted(String::compareToIgnoreCase)</span>
<span class="fc" id="L414">        .toList();</span>
    }
<span class="fc" id="L416">    return emptyList();</span>
  }

  private void checkLoginUniqueness(DbSession dbSession, String login) {
<span class="fc" id="L420">    UserDto existingUser = dbClient.userDao().selectByLogin(dbSession, login);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">    checkArgument(existingUser == null, &quot;A user with login '%s' already exists&quot;, login);</span>
<span class="fc" id="L422">  }</span>

  private UserDto saveUser(DbSession dbSession, UserDto userDto) {
<span class="fc" id="L425">    userDto.setActive(true);</span>
<span class="fc" id="L426">    UserDto res = dbClient.userDao().insert(dbSession, userDto);</span>
<span class="fc" id="L427">    addUserToDefaultGroup(dbSession, userDto);</span>
<span class="fc" id="L428">    return res;</span>
  }

  private void updateUser(DbSession dbSession, UserDto dto) {
<span class="fc" id="L432">    dto.setActive(true);</span>
<span class="fc" id="L433">    dbClient.userDao().update(dbSession, dto);</span>
<span class="fc" id="L434">  }</span>

  private void notifyNewUser(String login, String name, @Nullable String email) {
<span class="fc" id="L437">    newUserNotifier.onNewUser(NewUserHandler.Context.builder()</span>
<span class="fc" id="L438">      .setLogin(login)</span>
<span class="fc" id="L439">      .setName(name)</span>
<span class="fc" id="L440">      .setEmail(email)</span>
<span class="fc" id="L441">      .build());</span>
<span class="fc" id="L442">  }</span>

  private static boolean isUserAlreadyMemberOfDefaultGroup(GroupDto defaultGroup, List&lt;GroupDto&gt; userGroups) {
<span class="fc" id="L445">    return userGroups.stream().anyMatch(group -&gt; defaultGroup.getUuid().equals(group.getUuid()));</span>
  }

  private void addUserToDefaultGroup(DbSession dbSession, UserDto userDto) {
<span class="fc" id="L449">    addDefaultGroup(dbSession, userDto);</span>
<span class="fc" id="L450">  }</span>

  private void addDefaultGroup(DbSession dbSession, UserDto userDto) {
<span class="fc" id="L453">    List&lt;GroupDto&gt; userGroups = dbClient.groupDao().selectByUserLogin(dbSession, userDto.getLogin());</span>
<span class="fc" id="L454">    GroupDto defaultGroup = defaultGroupFinder.findDefaultGroup(dbSession);</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">    if (isUserAlreadyMemberOfDefaultGroup(defaultGroup, userGroups)) {</span>
<span class="nc" id="L456">      return;</span>
    }
<span class="fc" id="L458">    dbClient.userGroupDao().insert(dbSession, new UserGroupDto().setUserUuid(userDto.getUuid()).setGroupUuid(defaultGroup.getUuid()),</span>
<span class="fc" id="L459">      defaultGroup.getName(), userDto.getLogin());</span>
<span class="fc" id="L460">  }</span>

<span class="fc" id="L462">  private record ExternalIdentityLocal(@Nullable String provider, @Nullable String id, @Nullable String login) {</span>
    private static ExternalIdentityLocal fromUpdateUser(UpdateUser updateUser) {
<span class="fc" id="L464">      return new ExternalIdentityLocal(updateUser.externalIdentityProvider(), updateUser.externalIdentityProviderId(),</span>
<span class="fc" id="L465">        updateUser.externalIdentityProviderLogin());</span>
    }

    private static ExternalIdentityLocal fromExternalIdentity(@Nullable ExternalIdentity externalIdentity) {
<span class="fc bfc" id="L469" title="All 2 branches covered.">      if (externalIdentity == null) {</span>
<span class="fc" id="L470">        return new ExternalIdentityLocal(null, null, null);</span>
      }
<span class="fc" id="L472">      return new ExternalIdentityLocal(externalIdentity.getProvider(), externalIdentity.getId(), externalIdentity.getLogin());</span>
    }

    boolean isEmpty() {
<span class="pc bpc" id="L476" title="1 of 6 branches missed.">      return provider == null &amp;&amp; id == null &amp;&amp; login == null;</span>
    }

    private boolean isSameExternalIdentity(UserDto userDto) {
<span class="pc bpc" id="L480" title="1 of 6 branches missed.">      return !(provider == null &amp;&amp; id == null &amp;&amp; login == null)</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">        &amp;&amp; !userDto.isLocal()</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">        &amp;&amp; Objects.equals(userDto.getExternalIdentityProvider(), provider)</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        &amp;&amp; Objects.equals(userDto.getExternalLogin(), login)</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">        &amp;&amp; Objects.equals(userDto.getExternalId(), id);</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>