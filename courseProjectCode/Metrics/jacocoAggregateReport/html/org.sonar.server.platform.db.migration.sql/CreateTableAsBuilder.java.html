<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CreateTableAsBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.platform.db.migration.sql</a> &gt; <span class="el_source">CreateTableAsBuilder.java</span></div><h1>CreateTableAsBuilder.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.platform.db.migration.sql;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.sonar.db.dialect.Dialect;
import org.sonar.db.dialect.MsSql;
import org.sonar.server.platform.db.migration.def.ColumnDef;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.util.Objects.requireNonNull;
import static org.sonar.server.platform.db.migration.def.Validations.validateTableName;

/**
 * Creates a new table based on an existing table.
 * With Oracle, H2 and PSQL it uses the 'CREATE TABLE [...] AS' statement. This is not supported in SQL Server, so we use 'SELECT [...] INTO [new_table] FROM [old_table]'.
 * Note that indexes are not kept. Constraints are also not kept except for 'NOT NULL' in some dbs and under certain conditions. Some dbs also allow to specify 'NOT NULL'
 * constraint or even data type when specifying the new table.
 * For simplicity, we explicitly add NOT NULL constrains with separate statements for all DBs, since it's a fast operation.
 */
public class CreateTableAsBuilder {
  private final Dialect dialect;
  private final String tableName;
  private final String fromTableName;
<span class="fc" id="L46">  private final List&lt;Column&gt; columns = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L48">  public CreateTableAsBuilder(Dialect dialect, String tableName, String fromTableName) {</span>
<span class="fc" id="L49">    this.dialect = requireNonNull(dialect, &quot;dialect can't be null&quot;);</span>
<span class="fc" id="L50">    this.tableName = validateTableName(tableName);</span>
<span class="fc" id="L51">    this.fromTableName = validateTableName(fromTableName);</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">    checkArgument(!tableName.equals(fromTableName), &quot;Table names must be different&quot;);</span>
<span class="fc" id="L53">  }</span>

  public CreateTableAsBuilder addColumn(ColumnDef column) {
<span class="fc" id="L56">    columns.add(new Column(column, null));</span>
<span class="fc" id="L57">    return this;</span>
  }

  public CreateTableAsBuilder addColumnWithCast(ColumnDef column, String castFrom) {
<span class="fc" id="L61">    columns.add(new Column(column, castFrom));</span>
<span class="fc" id="L62">    return this;</span>
  }

  public List&lt;String&gt; build() {
<span class="fc bfc" id="L66" title="All 2 branches covered.">    checkState(!columns.isEmpty(), &quot;Columns need to be specified&quot;);</span>

<span class="fc" id="L68">    List&lt;String&gt; sql = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L70">    String select = columns.stream().map(this::toSelect).collect(Collectors.joining(&quot;, &quot;));</span>

<span class="fc bfc" id="L72" title="All 2 branches covered.">    if (dialect.getId().equals(MsSql.ID)) {</span>
<span class="fc" id="L73">      sql.add(&quot;SELECT &quot; + select + &quot; INTO &quot; + tableName + &quot; FROM &quot; + fromTableName);</span>
    } else {
<span class="fc" id="L75">      StringBuilder sb = new StringBuilder(&quot;CREATE TABLE &quot; + tableName + &quot; (&quot;);</span>
<span class="fc" id="L76">      appendColumnNames(sb);</span>
<span class="fc" id="L77">      sb.append(&quot;) AS (SELECT &quot;).append(select).append(&quot; FROM &quot;).append(fromTableName).append(&quot;)&quot;);</span>
<span class="fc" id="L78">      sql.add(sb.toString());</span>
    }

<span class="pc bpc" id="L81" title="1 of 2 branches missed.">    List&lt;Column&gt; notNullColumns = columns.stream().filter(c -&gt; !c.definition().isNullable()).toList();</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">    for (Column c : notNullColumns) {</span>
<span class="fc" id="L83">      sql.addAll(new AlterColumnsBuilder(dialect, tableName).updateColumn(c.definition()).build());</span>
<span class="fc" id="L84">    }</span>

<span class="fc" id="L86">    return sql;</span>
  }

  private String toSelect(Column column) {
<span class="fc bfc" id="L90" title="All 2 branches covered.">    if (column.castFrom() == null) {</span>
<span class="fc" id="L91">      return column.definition().getName();</span>
    }
    // Example: CAST (metric_id AS VARCHAR(40)) AS metric_uuid
<span class="fc" id="L94">    return &quot;CAST (&quot; + column.castFrom() + &quot; AS &quot; + column.definition().generateSqlType(dialect) + &quot;) AS &quot; + column.definition().getName();</span>
  }

  private void appendColumnNames(StringBuilder res) {
<span class="fc" id="L98">    res.append(columns.stream().map(c -&gt; c.definition().getName()).collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="fc" id="L99">  }</span>

  private static class Column {
    private final ColumnDef columnDef;
    private final String castFrom;

<span class="fc" id="L105">    public Column(ColumnDef columnDef, @Nullable String castFrom) {</span>
<span class="fc" id="L106">      this.columnDef = columnDef;</span>
<span class="fc" id="L107">      this.castFrom = castFrom;</span>
<span class="fc" id="L108">    }</span>

    private ColumnDef definition() {
<span class="fc" id="L111">      return columnDef;</span>
    }

    private String castFrom() {
<span class="fc" id="L115">      return castFrom;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>