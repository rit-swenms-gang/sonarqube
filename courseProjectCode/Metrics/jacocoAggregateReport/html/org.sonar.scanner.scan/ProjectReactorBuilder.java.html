<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProjectReactorBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.scanner.scan</a> &gt; <span class="el_source">ProjectReactorBuilder.java</span></div><h1>ProjectReactorBuilder.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.scanner.scan;

import com.google.common.annotations.VisibleForTesting;
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.MessageFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.sonar.api.CoreProperties;
import org.sonar.api.batch.bootstrap.ProjectDefinition;
import org.sonar.api.batch.bootstrap.ProjectReactor;
import org.sonar.api.impl.utils.ScannerUtils;
import org.sonar.api.notifications.AnalysisWarnings;
import org.sonar.api.utils.MessageException;
import org.sonar.api.utils.log.Logger;
import org.sonar.api.utils.log.Loggers;
import org.sonar.api.utils.log.Profiler;
import org.sonar.core.config.IssueExclusionProperties;
import org.sonar.scanner.bootstrap.ScannerProperties;
import org.sonar.scanner.issue.ignore.pattern.IssueExclusionPatternInitializer;
import org.sonar.scanner.issue.ignore.pattern.IssueInclusionPatternInitializer;

import static java.util.Arrays.asList;
import static org.sonar.api.config.internal.MultivalueProperty.parseAsCsv;

/**
 * Class that creates a project definition based on a set of properties.
 */
public class ProjectReactorBuilder {

  private static final String INVALID_VALUE_OF_X_FOR_Y = &quot;Invalid value of {0} for {1}&quot;;

<span class="fc" id="L63">  private static final Logger LOG = Loggers.get(ProjectReactorBuilder.class);</span>

  @VisibleForTesting
  static final String WILDCARDS_NOT_SUPPORTED = &quot;Wildcards ** and * are not supported in \&quot;sonar.sources\&quot; and \&quot;sonar.tests\&quot; properties. &quot; +
    &quot;\&quot;sonar.sources\&quot; and \&quot;sonar.tests\&quot; properties support only comma separated list of directories. &quot; +
    &quot;Use \&quot;sonar.exclusions/sonar.inclusions\&quot; and \&quot;sonar.test.exclusions/sonar.test.inclusions\&quot; &quot; +
    &quot;to further filter files in \&quot;sonar.sources\&quot; and \&quot;sonar.tests\&quot; respectively. Please refer to SonarQube documentation for more details.&quot;;

  /**
   * @since 4.1 but not yet exposed in {@link CoreProperties}
   */
  private static final String MODULE_KEY_PROPERTY = &quot;sonar.moduleKey&quot;;

  protected static final String PROPERTY_PROJECT_BASEDIR = &quot;sonar.projectBaseDir&quot;;
  private static final String PROPERTY_MODULES = &quot;sonar.modules&quot;;

  /**
   * New properties, to be consistent with Sonar naming conventions
   *
   * @since 1.5
   */
  private static final String PROPERTY_SOURCES = ProjectDefinition.SOURCES_PROPERTY;
  private static final String PROPERTY_TESTS = ProjectDefinition.TESTS_PROPERTY;

  /**
   * Array of all mandatory properties required for a project without child.
   */
<span class="fc" id="L90">  private static final String[] MANDATORY_PROPERTIES_FOR_SIMPLE_PROJECT = {</span>
    PROPERTY_PROJECT_BASEDIR, CoreProperties.PROJECT_KEY_PROPERTY
  };

  /**
   * Array of all mandatory properties required for a project with children.
   */
<span class="fc" id="L97">  private static final String[] MANDATORY_PROPERTIES_FOR_MULTIMODULE_PROJECT = {PROPERTY_PROJECT_BASEDIR, CoreProperties.PROJECT_KEY_PROPERTY};</span>

  /**
   * Array of all mandatory properties required for a child project before its properties get merged with its parent ones.
   */
<span class="fc" id="L102">  private static final String[] MANDATORY_PROPERTIES_FOR_CHILD = {MODULE_KEY_PROPERTY};</span>

<span class="fc" id="L104">  private static final Collection&lt;String&gt; UNSUPPORTED_PROPS_FOR_MODULES = asList(IssueExclusionPatternInitializer.CONFIG_KEY, IssueInclusionPatternInitializer.CONFIG_KEY,</span>
    IssueExclusionProperties.PATTERNS_BLOCK_KEY, IssueExclusionProperties.PATTERNS_ALLFILE_KEY);

  /**
   * Properties that must not be passed from the parent project to its children.
   */
<span class="fc" id="L110">  private static final List&lt;String&gt; NON_HERITED_PROPERTIES_FOR_CHILD = Stream.concat(Stream.of(PROPERTY_PROJECT_BASEDIR, CoreProperties.WORKING_DIRECTORY, PROPERTY_MODULES,</span>
<span class="fc" id="L111">    CoreProperties.PROJECT_DESCRIPTION_PROPERTY), UNSUPPORTED_PROPS_FOR_MODULES.stream()).toList();</span>

  private final ScannerProperties scannerProps;
  private final AnalysisWarnings analysisWarnings;
  private File rootProjectWorkDir;
  private boolean warnExclusionsAlreadyLogged;

<span class="fc" id="L118">  public ProjectReactorBuilder(ScannerProperties props, AnalysisWarnings analysisWarnings) {</span>
<span class="fc" id="L119">    this.scannerProps = props;</span>
<span class="fc" id="L120">    this.analysisWarnings = analysisWarnings;</span>
<span class="fc" id="L121">  }</span>

  public ProjectReactor execute() {
<span class="fc" id="L124">    Profiler profiler = Profiler.create(LOG).startInfo(&quot;Process project properties&quot;);</span>
<span class="fc" id="L125">    Map&lt;String, Map&lt;String, String&gt;&gt; propertiesByModuleIdPath = new HashMap&lt;&gt;();</span>
<span class="fc" id="L126">    extractPropertiesByModule(propertiesByModuleIdPath, &quot;&quot;, &quot;&quot;, new HashMap&lt;&gt;(scannerProps.properties()));</span>
<span class="fc" id="L127">    var rootModuleProperties = propertiesByModuleIdPath.get(&quot;&quot;);</span>
<span class="fc" id="L128">    setBaseDirIfNeeded(rootModuleProperties);</span>
<span class="fc" id="L129">    ProjectDefinition rootProject = createModuleDefinition(rootModuleProperties, null);</span>
<span class="fc" id="L130">    rootProjectWorkDir = rootProject.getWorkDir();</span>
<span class="fc" id="L131">    defineChildren(rootProject, propertiesByModuleIdPath, &quot;&quot;);</span>
<span class="fc" id="L132">    cleanAndCheckProjectDefinitions(rootProject);</span>
<span class="fc" id="L133">    profiler.stopInfo();</span>
<span class="fc" id="L134">    return new ProjectReactor(rootProject);</span>
  }

  private static void setBaseDirIfNeeded(Map&lt;String, String&gt; rootModuleProperties) {
<span class="fc" id="L138">    var baseDir = rootModuleProperties.get(PROPERTY_PROJECT_BASEDIR);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">    if (StringUtils.isBlank(baseDir)) {</span>
<span class="fc" id="L140">      rootModuleProperties.put(PROPERTY_PROJECT_BASEDIR, Paths.get(&quot;&quot;).toAbsolutePath().toString());</span>
    }
<span class="fc" id="L142">  }</span>

  private static void extractPropertiesByModule(Map&lt;String, Map&lt;String, String&gt;&gt; propertiesByModuleIdPath, String currentModuleId, String currentModuleIdPath,
    Map&lt;String, String&gt; parentProperties) {
<span class="fc bfc" id="L146" title="All 2 branches covered.">    if (propertiesByModuleIdPath.containsKey(currentModuleIdPath)) {</span>
<span class="fc" id="L147">      throw MessageException.of(String.format(&quot;Two modules have the same id: '%s'. Each module must have a unique id.&quot;, currentModuleId));</span>
    }

<span class="fc" id="L150">    Map&lt;String, String&gt; currentModuleProperties = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">    String prefix = !currentModuleId.isEmpty() ? (currentModuleId + &quot;.&quot;) : &quot;&quot;;</span>
<span class="fc" id="L152">    int prefixLength = prefix.length();</span>

    // By default all properties starting with module prefix belong to current module
<span class="fc" id="L155">    Iterator&lt;Entry&lt;String, String&gt;&gt; it = parentProperties.entrySet().iterator();</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    while (it.hasNext()) {</span>
<span class="fc" id="L157">      Map.Entry&lt;String, String&gt; e = it.next();</span>
<span class="fc" id="L158">      String key = e.getKey();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">      if (key.startsWith(prefix)) {</span>
<span class="fc" id="L160">        currentModuleProperties.put(key.substring(prefixLength), e.getValue());</span>
<span class="fc" id="L161">        it.remove();</span>
      }
<span class="fc" id="L163">    }</span>
<span class="fc" id="L164">    String[] moduleIds = getListFromProperty(currentModuleProperties, PROPERTY_MODULES);</span>
    // Sort modules by reverse lexicographic order to avoid issue when one module id is a prefix of another one
<span class="fc" id="L166">    Arrays.sort(moduleIds);</span>
<span class="fc" id="L167">    ArrayUtils.reverse(moduleIds);</span>

<span class="fc" id="L169">    propertiesByModuleIdPath.put(currentModuleIdPath, currentModuleProperties);</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">    for (String moduleId : moduleIds) {</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">      if (&quot;sonar&quot;.equals(moduleId)) {</span>
<span class="fc" id="L173">        throw MessageException.of(&quot;'sonar' is not a valid module id. Please check property '&quot; + PROPERTY_MODULES + &quot;'.&quot;);</span>
      }
<span class="fc bfc" id="L175" title="All 2 branches covered.">      String subModuleIdPath = currentModuleIdPath.isEmpty() ? moduleId : (currentModuleIdPath + &quot;.&quot; + moduleId);</span>
<span class="fc" id="L176">      extractPropertiesByModule(propertiesByModuleIdPath, moduleId, subModuleIdPath, currentModuleProperties);</span>
    }
<span class="fc" id="L178">  }</span>

  protected ProjectDefinition createModuleDefinition(Map&lt;String, String&gt; moduleProperties, @Nullable ProjectDefinition parent) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">    if (moduleProperties.containsKey(PROPERTY_MODULES)) {</span>
<span class="fc" id="L182">      checkMandatoryProperties(moduleProperties, MANDATORY_PROPERTIES_FOR_MULTIMODULE_PROJECT);</span>
    } else {
<span class="fc" id="L184">      checkMandatoryProperties(moduleProperties, MANDATORY_PROPERTIES_FOR_SIMPLE_PROJECT);</span>
    }
<span class="fc" id="L186">    File baseDir = new File(moduleProperties.get(PROPERTY_PROJECT_BASEDIR));</span>
<span class="fc" id="L187">    final String projectKey = moduleProperties.get(CoreProperties.PROJECT_KEY_PROPERTY);</span>
    File workDir;
<span class="fc bfc" id="L189" title="All 2 branches covered.">    if (parent == null) {</span>
<span class="fc" id="L190">      validateDirectories(moduleProperties, baseDir, projectKey);</span>
<span class="fc" id="L191">      workDir = initRootProjectWorkDir(baseDir, moduleProperties);</span>
    } else {
<span class="fc" id="L193">      workDir = initModuleWorkDir(baseDir, moduleProperties);</span>
<span class="fc" id="L194">      checkUnsupportedIssueExclusions(moduleProperties, parent.properties());</span>
    }

<span class="fc" id="L197">    return ProjectDefinition.create().setProperties(moduleProperties)</span>
<span class="fc" id="L198">      .setBaseDir(baseDir)</span>
<span class="fc" id="L199">      .setWorkDir(workDir);</span>
  }

  private void checkUnsupportedIssueExclusions(Map&lt;String, String&gt; moduleProperties, Map&lt;String, String&gt; parentProps) {
<span class="fc" id="L203">    UNSUPPORTED_PROPS_FOR_MODULES.forEach(p -&gt; {</span>
<span class="fc bfc" id="L204" title="All 4 branches covered.">      if (moduleProperties.containsKey(p) &amp;&amp; !Objects.equals(moduleProperties.get(p), parentProps.get(p))) {</span>
<span class="fc" id="L205">        warnOnceUnsupportedIssueExclusions(</span>
          &quot;Specifying issue exclusions at module level is not supported anymore. Configure the property '&quot; + p + &quot;' and any other issue exclusions at project level.&quot;);
      }
<span class="fc" id="L208">    });</span>
<span class="fc" id="L209">  }</span>

  private void warnOnceUnsupportedIssueExclusions(String msg) {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">    if (!warnExclusionsAlreadyLogged) {</span>
<span class="fc" id="L213">      LOG.warn(msg);</span>
<span class="fc" id="L214">      analysisWarnings.addUnique(msg);</span>
<span class="fc" id="L215">      warnExclusionsAlreadyLogged = true;</span>
    }
<span class="fc" id="L217">  }</span>

  protected File initRootProjectWorkDir(File baseDir, Map&lt;String, String&gt; rootProperties) {
<span class="fc" id="L220">    String workDir = rootProperties.get(CoreProperties.WORKING_DIRECTORY);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">    if (StringUtils.isBlank(workDir)) {</span>
<span class="fc" id="L222">      return new File(baseDir, CoreProperties.WORKING_DIRECTORY_DEFAULT_VALUE);</span>
    }

<span class="fc" id="L225">    File customWorkDir = new File(workDir);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">    if (customWorkDir.isAbsolute()) {</span>
<span class="fc" id="L227">      return customWorkDir;</span>
    }
<span class="fc" id="L229">    return new File(baseDir, customWorkDir.getPath());</span>
  }

  protected File initModuleWorkDir(File moduleBaseDir, Map&lt;String, String&gt; moduleProperties) {
<span class="fc" id="L233">    String workDir = moduleProperties.get(CoreProperties.WORKING_DIRECTORY);</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">    if (StringUtils.isBlank(workDir)) {</span>
<span class="fc" id="L235">      return new File(rootProjectWorkDir, ScannerUtils.cleanKeyForFilename(moduleProperties.get(CoreProperties.PROJECT_KEY_PROPERTY)));</span>
    }

<span class="nc" id="L238">    File customWorkDir = new File(workDir);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">    if (customWorkDir.isAbsolute()) {</span>
<span class="nc" id="L240">      return customWorkDir;</span>
    }
<span class="nc" id="L242">    return new File(moduleBaseDir, customWorkDir.getPath());</span>
  }

  private void defineChildren(ProjectDefinition parentProject, Map&lt;String, Map&lt;String, String&gt;&gt; propertiesByModuleIdPath, String parentModuleIdPath) {
<span class="fc" id="L246">    Map&lt;String, String&gt; parentProps = parentProject.properties();</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">    if (parentProps.containsKey(PROPERTY_MODULES)) {</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">      for (String moduleId : getListFromProperty(parentProps, PROPERTY_MODULES)) {</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        String moduleIdPath = parentModuleIdPath.isEmpty() ? moduleId : (parentModuleIdPath + &quot;.&quot; + moduleId);</span>
<span class="fc" id="L250">        Map&lt;String, String&gt; moduleProps = propertiesByModuleIdPath.get(moduleIdPath);</span>
<span class="fc" id="L251">        ProjectDefinition childProject = loadChildProject(parentProject, moduleProps, moduleId);</span>
        // check the uniqueness of the child key
<span class="fc" id="L253">        checkUniquenessOfChildKey(childProject, parentProject);</span>
        // the child project may have children as well
<span class="fc" id="L255">        defineChildren(childProject, propertiesByModuleIdPath, moduleIdPath);</span>
        // and finally add this child project to its parent
<span class="fc" id="L257">        parentProject.addSubProject(childProject);</span>
      }
    }
<span class="fc" id="L260">  }</span>

  protected ProjectDefinition loadChildProject(ProjectDefinition parentProject, Map&lt;String, String&gt; moduleProps, String moduleId) {
    final File baseDir;
<span class="fc bfc" id="L264" title="All 2 branches covered.">    if (moduleProps.containsKey(PROPERTY_PROJECT_BASEDIR)) {</span>
<span class="fc" id="L265">      baseDir = resolvePath(parentProject.getBaseDir(), moduleProps.get(PROPERTY_PROJECT_BASEDIR));</span>
<span class="fc" id="L266">      setProjectBaseDir(baseDir, moduleProps, moduleId);</span>
    } else {
<span class="fc" id="L268">      baseDir = new File(parentProject.getBaseDir(), moduleId);</span>
<span class="fc" id="L269">      setProjectBaseDir(baseDir, moduleProps, moduleId);</span>
    }

<span class="fc" id="L272">    setModuleKeyAndNameIfNotDefined(moduleProps, moduleId, parentProject.getKey());</span>

    // and finish
<span class="fc" id="L275">    checkMandatoryProperties(moduleProps, MANDATORY_PROPERTIES_FOR_CHILD);</span>
<span class="fc" id="L276">    validateDirectories(moduleProps, baseDir, moduleId);</span>

<span class="fc" id="L278">    mergeParentProperties(moduleProps, parentProject.properties());</span>

<span class="fc" id="L280">    return createModuleDefinition(moduleProps, parentProject);</span>
  }

  protected static void setModuleKeyAndNameIfNotDefined(Map&lt;String, String&gt; childProps, String moduleId, String parentKey) {
<span class="fc bfc" id="L284" title="All 2 branches covered.">    if (!childProps.containsKey(MODULE_KEY_PROPERTY)) {</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">      if (!childProps.containsKey(CoreProperties.PROJECT_KEY_PROPERTY)) {</span>
<span class="fc" id="L286">        childProps.put(MODULE_KEY_PROPERTY, parentKey + &quot;:&quot; + moduleId);</span>
      } else {
<span class="fc" id="L288">        String childKey = childProps.get(CoreProperties.PROJECT_KEY_PROPERTY);</span>
<span class="fc" id="L289">        childProps.put(MODULE_KEY_PROPERTY, parentKey + &quot;:&quot; + childKey);</span>
      }
    }
<span class="fc" id="L292">    childProps.putIfAbsent(CoreProperties.PROJECT_NAME_PROPERTY, moduleId);</span>
    // For backward compatibility with ProjectDefinition
<span class="fc" id="L294">    childProps.put(CoreProperties.PROJECT_KEY_PROPERTY, childProps.get(MODULE_KEY_PROPERTY));</span>
<span class="fc" id="L295">  }</span>

  protected static void checkUniquenessOfChildKey(ProjectDefinition childProject, ProjectDefinition parentProject) {
<span class="fc bfc" id="L298" title="All 2 branches covered.">    for (ProjectDefinition definition : parentProject.getSubProjects()) {</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">      if (definition.getKey().equals(childProject.getKey())) {</span>
<span class="fc" id="L300">        throw MessageException.of(&quot;Project '&quot; + parentProject.getKey() + &quot;' can't have 2 modules with the following key: &quot; + childProject.getKey());</span>
      }
<span class="fc" id="L302">    }</span>
<span class="fc" id="L303">  }</span>

  protected static void setProjectBaseDir(File baseDir, Map&lt;String, String&gt; childProps, String moduleId) {
<span class="fc bfc" id="L306" title="All 2 branches covered.">    if (!baseDir.isDirectory()) {</span>
<span class="fc" id="L307">      throw MessageException.of(&quot;The base directory of the module '&quot; + moduleId + &quot;' does not exist: &quot; + baseDir.getAbsolutePath());</span>
    }
<span class="fc" id="L309">    childProps.put(PROPERTY_PROJECT_BASEDIR, baseDir.getAbsolutePath());</span>
<span class="fc" id="L310">  }</span>

  protected static void checkMandatoryProperties(Map&lt;String, String&gt; props, String[] mandatoryProps) {
<span class="fc" id="L313">    StringBuilder missing = new StringBuilder();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">    for (String mandatoryProperty : mandatoryProps) {</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">      if (!props.containsKey(mandatoryProperty)) {</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (missing.length() &gt; 0) {</span>
<span class="fc" id="L317">          missing.append(&quot;, &quot;);</span>
        }
<span class="fc" id="L319">        missing.append(mandatoryProperty);</span>
      }
    }
<span class="fc" id="L322">    String moduleKey = StringUtils.defaultIfBlank(props.get(MODULE_KEY_PROPERTY), props.get(CoreProperties.PROJECT_KEY_PROPERTY));</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">    if (missing.length() != 0) {</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">      throw MessageException.of(&quot;You must define the following mandatory properties for '&quot; + (moduleKey == null ? &quot;Unknown&quot; : moduleKey) + &quot;': &quot; + missing);</span>
    }
<span class="fc" id="L326">  }</span>

  protected static void validateDirectories(Map&lt;String, String&gt; props, File baseDir, String projectId) {
<span class="fc bfc" id="L329" title="All 2 branches covered.">    if (!props.containsKey(PROPERTY_MODULES)) {</span>
      // SONARPLUGINS-2285 Not an aggregator project so we can validate that paths are correct if defined

      // Check sonar.tests
<span class="fc" id="L333">      String[] testPaths = getListFromProperty(props, PROPERTY_TESTS);</span>
<span class="fc" id="L334">      checkExistenceAndValidateSourcePaths(projectId, baseDir, testPaths, PROPERTY_TESTS);</span>
    }
<span class="fc" id="L336">  }</span>

  protected static void cleanAndCheckProjectDefinitions(ProjectDefinition project) {
<span class="fc bfc" id="L339" title="All 2 branches covered.">    if (project.getSubProjects().isEmpty()) {</span>
<span class="fc" id="L340">      cleanAndCheckModuleProperties(project);</span>
    } else {
<span class="fc" id="L342">      logMissingSourcesAndTests(project);</span>

      // clean modules properties as well
<span class="fc bfc" id="L345" title="All 2 branches covered.">      for (ProjectDefinition module : project.getSubProjects()) {</span>
<span class="fc" id="L346">        cleanAndCheckProjectDefinitions(module);</span>
<span class="fc" id="L347">      }</span>
    }
<span class="fc" id="L349">  }</span>

  private static void logMissingSourcesAndTests(ProjectDefinition project) {
<span class="fc" id="L352">    Map&lt;String, String&gt; properties = project.properties();</span>

<span class="fc" id="L354">    File baseDir = project.getBaseDir();</span>
<span class="fc" id="L355">    logMissingPaths(&quot;source&quot;, baseDir, getListFromProperty(properties, PROPERTY_SOURCES));</span>
<span class="fc" id="L356">    logMissingPaths(&quot;test&quot;, baseDir, getListFromProperty(properties, PROPERTY_TESTS));</span>
<span class="fc" id="L357">  }</span>

  private static void logMissingPaths(String label, File baseDir, String[] paths) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">    for (String path : paths) {</span>
<span class="fc" id="L361">      File file = resolvePath(baseDir, path);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">      if (!file.exists()) {</span>
<span class="fc" id="L363">        LOG.debug(&quot;Path '{}' does not exist, will not be used as {}&quot;, file, label);</span>
      }
    }
<span class="fc" id="L366">  }</span>

  protected static void cleanAndCheckModuleProperties(ProjectDefinition project) {
<span class="fc" id="L369">    Map&lt;String, String&gt; properties = project.properties();</span>

    // We need to check the existence of source directories
<span class="fc" id="L372">    String[] sourcePaths = getListFromProperty(properties, PROPERTY_SOURCES);</span>
<span class="fc" id="L373">    checkExistenceAndValidateSourcePaths(project.getKey(), project.getBaseDir(), sourcePaths, PROPERTY_SOURCES);</span>
<span class="fc" id="L374">  }</span>

  protected static void mergeParentProperties(Map&lt;String, String&gt; childProps, Map&lt;String, String&gt; parentProps) {
<span class="fc bfc" id="L377" title="All 2 branches covered.">    for (Map.Entry&lt;String, String&gt; entry : parentProps.entrySet()) {</span>
<span class="fc" id="L378">      String key = entry.getKey();</span>
<span class="fc bfc" id="L379" title="All 4 branches covered.">      if ((!childProps.containsKey(key) || childProps.get(key).equals(entry.getValue()))</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        &amp;&amp; !NON_HERITED_PROPERTIES_FOR_CHILD.contains(key)) {</span>
<span class="fc" id="L381">        childProps.put(entry.getKey(), entry.getValue());</span>
      }
<span class="fc" id="L383">    }</span>
<span class="fc" id="L384">  }</span>

  protected static void checkExistenceAndValidateSourcePaths(String moduleRef, File baseDir, String[] paths, String propName) {
<span class="fc bfc" id="L387" title="All 2 branches covered.">    for (String path : paths) {</span>
<span class="fc" id="L388">      validateNoAsterisksInSourcePath(path, propName, moduleRef);</span>
<span class="fc" id="L389">      File sourceFolder = resolvePath(baseDir, path);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">      if (!sourceFolder.exists()) {</span>
<span class="fc" id="L391">        LOG.error(MessageFormat.format(INVALID_VALUE_OF_X_FOR_Y, propName, moduleRef));</span>
<span class="fc" id="L392">        throw MessageException.of(&quot;The folder '&quot; + path + &quot;' does not exist for '&quot; + moduleRef +</span>
<span class="fc" id="L393">          &quot;' (base directory = &quot; + baseDir.getAbsolutePath() + &quot;)&quot;);</span>
      }
    }
<span class="fc" id="L396">  }</span>

  private static void validateNoAsterisksInSourcePath(String path, String propName, String moduleRef) {
<span class="fc bfc" id="L399" title="All 2 branches covered.">    if (path.contains(&quot;*&quot;)) {</span>
<span class="fc" id="L400">      LOG.error(MessageFormat.format(INVALID_VALUE_OF_X_FOR_Y, propName, moduleRef));</span>
<span class="fc" id="L401">      throw MessageException.of(WILDCARDS_NOT_SUPPORTED);</span>
    }
<span class="fc" id="L403">  }</span>

  protected static File resolvePath(File baseDir, String path) {
<span class="fc" id="L406">    Path filePath = Paths.get(path);</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">    if (!filePath.isAbsolute()) {</span>
<span class="fc" id="L408">      filePath = baseDir.toPath().resolve(path);</span>
    }
<span class="fc" id="L410">    return filePath.normalize().toFile();</span>
  }

  /**
   * Transforms a comma-separated list String property in to a array of trimmed strings.
   * &lt;p&gt;
   * This works even if they are separated by whitespace characters (space char, EOL, ...)
   */
  static String[] getListFromProperty(Map&lt;String, String&gt; properties, String key) {
<span class="fc" id="L419">    String propValue = properties.get(key);</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">    if (propValue != null) {</span>
<span class="fc" id="L421">      return parseAsCsv(key, propValue);</span>
    }
<span class="fc" id="L423">    return new String[0];</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>