<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebServiceEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.ws</a> &gt; <span class="el_source">WebServiceEngine.java</span></div><h1>WebServiceEngine.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.ws;

import com.google.common.base.Throwables;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Locale;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.apache.catalina.connector.ClientAbortException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.Startable;
import org.sonar.api.impl.ws.ValidatingRequest;
import org.sonar.api.server.ServerSide;
import org.sonar.api.server.ws.LocalConnector;
import org.sonar.api.server.ws.Request;
import org.sonar.api.server.ws.Response;
import org.sonar.api.server.ws.WebService;
import org.sonar.api.utils.text.JsonWriter;
import org.sonar.server.exceptions.BadConfigurationException;
import org.sonar.server.exceptions.BadRequestException;
import org.sonar.server.exceptions.ServerException;
import org.sonarqube.ws.MediaTypes;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Strings.isNullOrEmpty;
import static java.util.Collections.singletonList;
import static java.util.Objects.requireNonNull;
import static org.apache.commons.lang3.StringUtils.substring;
import static org.apache.commons.lang3.StringUtils.substringAfterLast;
import static org.apache.commons.lang3.StringUtils.substringBeforeLast;
import static org.sonar.server.exceptions.NotFoundException.checkFound;
import static org.sonar.server.ws.RequestVerifier.verifyRequest;
import static org.sonar.server.ws.ServletRequest.SUPPORTED_MEDIA_TYPES_BY_URL_SUFFIX;

/**
 * @since 4.2
 */
@ServerSide
public class WebServiceEngine implements LocalConnector, Startable {

<span class="fc" id="L62">  private static final Logger LOGGER = LoggerFactory.getLogger(WebServiceEngine.class);</span>

  private final WebService[] webServices;
  private final ActionInterceptor[] actionInterceptors;

  private WebService.Context context;

<span class="fc" id="L69">  public WebServiceEngine(WebService[] webServices, ActionInterceptor[] actionInterceptors) {</span>
<span class="fc" id="L70">    this.webServices = webServices;</span>
<span class="fc" id="L71">    this.actionInterceptors = actionInterceptors;</span>
<span class="fc" id="L72">  }</span>

  @Override
  public void start() {
<span class="fc" id="L76">    context = new WebService.Context();</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">    for (WebService webService : webServices) {</span>
<span class="fc" id="L78">      webService.define(context);</span>
    }
<span class="fc" id="L80">  }</span>

  @Override
  public void stop() {
    // nothing
<span class="fc" id="L85">  }</span>

  private WebService.Context getContext() {
<span class="fc" id="L88">    return requireNonNull(context, &quot;Web services has not yet been initialized&quot;);</span>
  }

  public List&lt;WebService.Controller&gt; controllers() {
<span class="fc" id="L92">    return getContext().controllers();</span>
  }

  @Override
  public LocalResponse call(LocalRequest request) {
<span class="nc" id="L97">    DefaultLocalResponse localResponse = new DefaultLocalResponse();</span>
<span class="nc" id="L98">    execute(new LocalRequestAdapter(request), localResponse);</span>
<span class="nc" id="L99">    return localResponse;</span>
  }

  public void execute(Request request, Response response) {
    try {
<span class="fc" id="L104">      ActionExtractor actionExtractor = new ActionExtractor(request.getPath());</span>
<span class="fc" id="L105">      WebService.Action foundAction = getAction(actionExtractor);</span>
<span class="fc" id="L106">      WebService.Action action = checkFound(foundAction, &quot;Unknown url : %s&quot;, request.getPath());</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">      if (request instanceof ValidatingRequest validatingRequest) {</span>
<span class="fc" id="L108">        validatingRequest.setAction(action);</span>
<span class="fc" id="L109">        validatingRequest.setLocalConnector(this);</span>
      }
<span class="fc" id="L111">      checkActionExtension(actionExtractor.getExtension());</span>
<span class="fc" id="L112">      verifyRequest(action, request);</span>
<span class="fc" id="L113">      preAction(action, request);</span>
<span class="fc" id="L114">      action.handler().handle(request, response);</span>
<span class="fc" id="L115">    } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L116">      sendErrors(request, response, e, 400, singletonList(e.getMessage()));</span>
<span class="fc" id="L117">    } catch (BadConfigurationException e) {</span>
<span class="fc" id="L118">      sendErrors(request, response, e, 400, e.errors(), e.scope());</span>
<span class="fc" id="L119">    } catch (BadRequestException e) {</span>
<span class="fc" id="L120">      sendErrors(request, response, e, 400, e.errors());</span>
<span class="fc" id="L121">    } catch (ServerException e) {</span>
<span class="fc" id="L122">      sendErrors(request, response, e, e.httpCode(), singletonList(e.getMessage()));</span>
<span class="fc" id="L123">    } catch (Exception e) {</span>
<span class="fc" id="L124">      sendErrors(request, response, e, 500, singletonList(&quot;An error has occurred. Please contact your administrator&quot;));</span>
<span class="fc" id="L125">    }</span>
<span class="fc" id="L126">  }</span>

  private void preAction(WebService.Action action, Request request) {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">    for (ActionInterceptor interceptor : actionInterceptors) {</span>
<span class="nc" id="L130">      interceptor.preAction(action, request);</span>
    }
<span class="fc" id="L132">  }</span>

  @CheckForNull
  private WebService.Action getAction(ActionExtractor actionExtractor) {
<span class="fc" id="L136">    String controllerPath = actionExtractor.getController();</span>
<span class="fc" id="L137">    String actionKey = actionExtractor.getAction();</span>
<span class="fc" id="L138">    WebService.Controller controller = getContext().controller(controllerPath);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">    return controller == null ? null : controller.action(actionKey);</span>
  }

  private static void sendErrors(Request request, Response response, Exception exception, int status, List&lt;String&gt; errors) {
<span class="fc" id="L143">    sendErrors(request, response, exception, status, errors, null);</span>
<span class="fc" id="L144">  }</span>

  private static void sendErrors(Request request, Response response, Exception exception, int status, List&lt;String&gt; errors, @Nullable String scope) {
<span class="fc bfc" id="L147" title="All 2 branches covered.">    if (isRequestAbortedByClient(exception)) {</span>
      // do not pollute logs. We can't do anything -&gt; use DEBUG level
      // see org.sonar.server.ws.ServletResponse#output()
<span class="fc" id="L150">      LOGGER.debug(&quot;Request {} has been aborted by client&quot;, request, exception);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">      if (!isResponseCommitted(response)) {</span>
        // can be useful for access.log
<span class="fc" id="L153">        response.stream().setStatus(299);</span>
      }
<span class="fc" id="L155">      return;</span>
    }

<span class="fc bfc" id="L158" title="All 2 branches covered.">    if (status == 500) {</span>
      // Sending exception message into response is a vulnerability. Error must be
      // displayed only in logs.
<span class="fc" id="L161">      LOGGER.error(&quot;Fail to process request {}&quot;, request, exception);</span>
    }

<span class="fc" id="L164">    Response.Stream stream = response.stream();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">    if (isResponseCommitted(response)) {</span>
      // status can't be changed
<span class="fc" id="L167">      LOGGER.debug(&quot;Request {} failed during response streaming&quot;, request, exception);</span>
<span class="fc" id="L168">      return;</span>
    }

    // response is not committed, status and content can be changed to return the error
<span class="fc bfc" id="L172" title="All 2 branches covered.">    if (stream instanceof ServletResponse.ServletStream servletStream) {</span>
<span class="fc" id="L173">      servletStream.reset();</span>
    }
<span class="fc" id="L175">    stream.setStatus(status);</span>
<span class="fc" id="L176">    stream.setMediaType(MediaTypes.JSON);</span>
<span class="fc" id="L177">    try (JsonWriter json = JsonWriter.of(new OutputStreamWriter(stream.output(), StandardCharsets.UTF_8))) {</span>
<span class="fc" id="L178">      json.beginObject();</span>
<span class="fc" id="L179">      writeScope(scope, json);</span>
<span class="fc" id="L180">      writeErrors(json, errors);</span>
<span class="fc" id="L181">      json.endObject();</span>
<span class="nc" id="L182">    } catch (Exception e) {</span>
      // Do not hide the potential exception raised in the try block.
<span class="nc" id="L184">      throw Throwables.propagate(e);</span>
<span class="fc" id="L185">    }</span>
<span class="fc" id="L186">  }</span>

  private static void writeScope(@Nullable String scope, JsonWriter json) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">    if (scope != null) {</span>
<span class="fc" id="L190">      json.prop(&quot;scope&quot;, scope);</span>
    }
<span class="fc" id="L192">  }</span>

  private static boolean isRequestAbortedByClient(Exception exception) {
<span class="fc" id="L195">    return Throwables.getCausalChain(exception).stream().anyMatch(ClientAbortException.class::isInstance);</span>
  }

  private static boolean isResponseCommitted(Response response) {
<span class="fc" id="L199">    Response.Stream stream = response.stream();</span>
    // Request has been aborted by the client or the response was partially streamed, nothing can been done as Tomcat has committed the response
<span class="fc bfc" id="L201" title="All 4 branches covered.">    return stream instanceof ServletResponse.ServletStream servletStream &amp;&amp; servletStream.response().isCommitted();</span>
  }

  public static void writeErrors(JsonWriter json, List&lt;String&gt; errorMessages) {
<span class="fc bfc" id="L205" title="All 2 branches covered.">    if (errorMessages.isEmpty()) {</span>
<span class="fc" id="L206">      return;</span>
    }
<span class="fc" id="L208">    json.name(&quot;errors&quot;).beginArray();</span>
<span class="fc" id="L209">    errorMessages.forEach(message -&gt; {</span>
<span class="fc" id="L210">      json.beginObject();</span>
<span class="fc" id="L211">      json.prop(&quot;msg&quot;, message);</span>
<span class="fc" id="L212">      json.endObject();</span>
<span class="fc" id="L213">    });</span>
<span class="fc" id="L214">    json.endArray();</span>
<span class="fc" id="L215">  }</span>

  private static void checkActionExtension(@Nullable String actionExtension) {
<span class="fc bfc" id="L218" title="All 2 branches covered.">    if (isNullOrEmpty(actionExtension)) {</span>
<span class="fc" id="L219">      return;</span>
    }
<span class="fc bfc" id="L221" title="All 2 branches covered.">    checkArgument(SUPPORTED_MEDIA_TYPES_BY_URL_SUFFIX.get(actionExtension.toLowerCase(Locale.ENGLISH)) != null, &quot;Unknown action extension: %s&quot;, actionExtension);</span>
<span class="fc" id="L222">  }</span>

  private static class ActionExtractor {
    private static final String SLASH = &quot;/&quot;;
    private static final String POINT = &quot;.&quot;;

    private final String controller;
    private final String action;
    private final String extension;
    private final String path;

<span class="fc" id="L233">    ActionExtractor(String path) {</span>
<span class="fc" id="L234">      this.path = path;</span>
<span class="fc" id="L235">      String pathWithoutExtension = substringBeforeLast(path, POINT);</span>
<span class="fc" id="L236">      this.controller = extractController(pathWithoutExtension);</span>
<span class="fc" id="L237">      this.action = substringAfterLast(pathWithoutExtension, SLASH);</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">      checkArgument(!action.isEmpty(), &quot;Url is incorrect : '%s'&quot;, path);</span>
<span class="fc" id="L239">      this.extension = substringAfterLast(path, POINT);</span>
<span class="fc" id="L240">    }</span>

    private static String extractController(String path) {
<span class="fc" id="L243">      String controller = substringBeforeLast(path, SLASH);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">      if (controller.startsWith(SLASH)) {</span>
<span class="fc" id="L245">        return substring(controller, 1);</span>
      }
<span class="fc" id="L247">      return controller;</span>
    }

    String getController() {
<span class="fc" id="L251">      return controller;</span>
    }

    String getAction() {
<span class="fc" id="L255">      return action;</span>
    }

    @CheckForNull
    String getExtension() {
<span class="fc" id="L260">      return extension;</span>
    }

    String getPath() {
<span class="nc" id="L264">      return path;</span>
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>