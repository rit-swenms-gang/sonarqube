<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TextLineNumber.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.scanner.protocol.viewer</a> &gt; <span class="el_source">TextLineNumber.java</span></div><h1>TextLineNumber.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.scanner.protocol.viewer;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.Rectangle;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.HashMap;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.Element;
import javax.swing.text.JTextComponent;
import javax.swing.text.StyleConstants;
import javax.swing.text.Utilities;

/**
 *  This class will display line numbers for a related text component. The text
 *  component must use the same line height for each line. TextLineNumber
 *  supports wrapped lines and will highlight the line number of the current
 *  line in the text component.
 *
 *  This class was designed to be used as a component added to the row header
 *  of a JScrollPane.
 */
public class TextLineNumber extends JPanel implements CaretListener, DocumentListener, PropertyChangeListener {
  public static final float LEFT = 0.0f;
  public static final float CENTER = 0.5f;
  public static final float RIGHT = 1.0f;

<span class="nc" id="L64">  private static final Border OUTER = new MatteBorder(0, 0, 0, 2, Color.GRAY);</span>

  private static final int HEIGHT = Integer.MAX_VALUE - 1000000;

  // Text component this TextTextLineNumber component is in sync with

  private JTextComponent component;

  // Properties that can be changed

  private boolean updateFont;
  private int borderGap;
  private Color currentLineForeground;
  private float digitAlignment;
  private int minimumDisplayDigits;

  // Keep history information to reduce the number of times the component
  // needs to be repainted

  private int lastDigits;
  private int lastHeight;
  private int lastLine;

  private HashMap&lt;String, FontMetrics&gt; fonts;

  /**
   *  Create a line number component for a text component. This minimum
   *  display width will be based on 3 digits.
   *
   *  @param component  the related text component
   */
  public TextLineNumber(JTextComponent component) {
<span class="nc" id="L96">    this(component, 3);</span>
<span class="nc" id="L97">  }</span>

  /**
   *  Create a line number component for a text component.
   *
   *  @param component  the related text component
   *  @param minimumDisplayDigits  the number of digits used to calculate
   *                               the minimum width of the component
   */
<span class="nc" id="L106">  public TextLineNumber(JTextComponent component, int minimumDisplayDigits) {</span>
<span class="nc" id="L107">    this.component = component;</span>

<span class="nc" id="L109">    setFont(component.getFont());</span>

<span class="nc" id="L111">    setBorderGap(5);</span>
<span class="nc" id="L112">    setCurrentLineForeground(Color.RED);</span>
<span class="nc" id="L113">    setDigitAlignment(RIGHT);</span>
<span class="nc" id="L114">    setMinimumDisplayDigits(minimumDisplayDigits);</span>

<span class="nc" id="L116">    component.getDocument().addDocumentListener(this);</span>
<span class="nc" id="L117">    component.addCaretListener(this);</span>
<span class="nc" id="L118">    component.addPropertyChangeListener(&quot;font&quot;, this);</span>
<span class="nc" id="L119">  }</span>

  /**
   *  Gets the update font property
   *
   *  @return the update font property
   */
  public boolean getUpdateFont() {
<span class="nc" id="L127">    return updateFont;</span>
  }

  /**
   *  Set the update font property. Indicates whether this Font should be
   *  updated automatically when the Font of the related text component
   *  is changed.
   *
   *  @param updateFont  when true update the Font and repaint the line
   *                     numbers, otherwise just repaint the line numbers.
   */
  public void setUpdateFont(boolean updateFont) {
<span class="nc" id="L139">    this.updateFont = updateFont;</span>
<span class="nc" id="L140">  }</span>

  /**
   *  Gets the border gap
   *
   *  @return the border gap in pixels
   */
  public int getBorderGap() {
<span class="nc" id="L148">    return borderGap;</span>
  }

  /**
   *  The border gap is used in calculating the left and right insets of the
   *  border. Default value is 5.
   *
   *  @param borderGap  the gap in pixels
   */
  public void setBorderGap(int borderGap) {
<span class="nc" id="L158">    this.borderGap = borderGap;</span>
<span class="nc" id="L159">    Border inner = new EmptyBorder(0, borderGap, 0, borderGap);</span>
<span class="nc" id="L160">    setBorder(new CompoundBorder(OUTER, inner));</span>
<span class="nc" id="L161">    lastDigits = 0;</span>
<span class="nc" id="L162">    setPreferredWidth();</span>
<span class="nc" id="L163">  }</span>

  /**
   *  Gets the current line rendering Color
   *
   *  @return the Color used to render the current line number
   */
  public Color getCurrentLineForeground() {
<span class="nc bnc" id="L171" title="All 2 branches missed.">    return currentLineForeground == null ? getForeground() : currentLineForeground;</span>
  }

  /**
   *  The Color used to render the current line digits. Default is Coolor.RED.
   *
   *  @param currentLineForeground  the Color used to render the current line
   */
  public void setCurrentLineForeground(Color currentLineForeground) {
<span class="nc" id="L180">    this.currentLineForeground = currentLineForeground;</span>
<span class="nc" id="L181">  }</span>

  /**
   *  Gets the digit alignment
   *
   *  @return the alignment of the painted digits
   */
  public float getDigitAlignment() {
<span class="nc" id="L189">    return digitAlignment;</span>
  }

  /**
   *  Specify the horizontal alignment of the digits within the component.
   *  Common values would be:
   *  &lt;ul&gt;
   *  &lt;li&gt;TextLineNumber.LEFT
   *  &lt;li&gt;TextLineNumber.CENTER
   *  &lt;li&gt;TextLineNumber.RIGHT (default)
   *  &lt;/ul&gt;
   */
  public void setDigitAlignment(float digitAlignment) {
<span class="nc bnc" id="L202" title="All 4 branches missed.">    this.digitAlignment = digitAlignment &gt; 1.0f ? 1.0f : digitAlignment &lt; 0.0f ? -1.0f : digitAlignment;</span>
<span class="nc" id="L203">  }</span>

  /**
   *  Gets the minimum display digits
   *
   *  @return the minimum display digits
   */
  public int getMinimumDisplayDigits() {
<span class="nc" id="L211">    return minimumDisplayDigits;</span>
  }

  /**
   *  Specify the mimimum number of digits used to calculate the preferred
   *  width of the component. Default is 3.
   *
   *  @param minimumDisplayDigits  the number digits used in the preferred
   *                               width calculation
   */
  public void setMinimumDisplayDigits(int minimumDisplayDigits) {
<span class="nc" id="L222">    this.minimumDisplayDigits = minimumDisplayDigits;</span>
<span class="nc" id="L223">    setPreferredWidth();</span>
<span class="nc" id="L224">  }</span>

  /**
   *  Calculate the width needed to display the maximum line number
   */
  private void setPreferredWidth() {
<span class="nc" id="L230">    Element root = component.getDocument().getDefaultRootElement();</span>
<span class="nc" id="L231">    int lines = root.getElementCount();</span>
<span class="nc" id="L232">    int digits = Math.max(String.valueOf(lines).length(), minimumDisplayDigits);</span>

    // Update sizes when number of digits in the line number changes

<span class="nc bnc" id="L236" title="All 2 branches missed.">    if (lastDigits != digits) {</span>
<span class="nc" id="L237">      lastDigits = digits;</span>
<span class="nc" id="L238">      FontMetrics fontMetrics = getFontMetrics(getFont());</span>
<span class="nc" id="L239">      int width = fontMetrics.charWidth('0') * digits;</span>
<span class="nc" id="L240">      Insets insets = getInsets();</span>
<span class="nc" id="L241">      int preferredWidth = insets.left + insets.right + width;</span>

<span class="nc" id="L243">      Dimension d = getPreferredSize();</span>
<span class="nc" id="L244">      d.setSize(preferredWidth, HEIGHT);</span>
<span class="nc" id="L245">      setPreferredSize(d);</span>
<span class="nc" id="L246">      setSize(d);</span>
    }
<span class="nc" id="L248">  }</span>

  /**
   *  Draw the line numbers
   */
  @Override
  public void paintComponent(Graphics g) {
<span class="nc" id="L255">    super.paintComponent(g);</span>

    // Determine the width of the space available to draw the line number

<span class="nc" id="L259">    FontMetrics fontMetrics = component.getFontMetrics(component.getFont());</span>
<span class="nc" id="L260">    Insets insets = getInsets();</span>
<span class="nc" id="L261">    int availableWidth = getSize().width - insets.left - insets.right;</span>

    // Determine the rows to draw within the clipped bounds.

<span class="nc" id="L265">    Rectangle clip = g.getClipBounds();</span>
<span class="nc" id="L266">    int rowStartOffset = component.viewToModel(new Point(0, clip.y));</span>
<span class="nc" id="L267">    int endOffset = component.viewToModel(new Point(0, clip.y + clip.height));</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">    while (rowStartOffset &lt;= endOffset) {</span>
      try {
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (isCurrentLine(rowStartOffset))</span>
<span class="nc" id="L272">          g.setColor(getCurrentLineForeground());</span>
        else
<span class="nc" id="L274">          g.setColor(getForeground());</span>

        // Get the line number as a string and then determine the
        // &quot;X&quot; and &quot;Y&quot; offsets for drawing the string.

<span class="nc" id="L279">        String lineNumber = getTextLineNumber(rowStartOffset);</span>
<span class="nc" id="L280">        int stringWidth = fontMetrics.stringWidth(lineNumber);</span>
<span class="nc" id="L281">        int x = getOffsetX(availableWidth, stringWidth) + insets.left;</span>
<span class="nc" id="L282">        int y = getOffsetY(rowStartOffset, fontMetrics);</span>
<span class="nc" id="L283">        g.drawString(lineNumber, x, y);</span>

        // Move to the next row

<span class="nc" id="L287">        rowStartOffset = Utilities.getRowEnd(component, rowStartOffset) + 1;</span>
<span class="nc" id="L288">      } catch (Exception e) {</span>
<span class="nc" id="L289">        break;</span>
<span class="nc" id="L290">      }</span>
    }
<span class="nc" id="L292">  }</span>

  /*
   * We need to know if the caret is currently positioned on the line we
   * are about to paint so the line number can be highlighted.
   */
  private boolean isCurrentLine(int rowStartOffset) {
<span class="nc" id="L299">    int caretPosition = component.getCaretPosition();</span>
<span class="nc" id="L300">    Element root = component.getDocument().getDefaultRootElement();</span>

<span class="nc bnc" id="L302" title="All 2 branches missed.">    return root.getElementIndex(rowStartOffset) == root.getElementIndex(caretPosition);</span>
  }

  /*
   * Get the line number to be drawn. The empty string will be returned
   * when a line of text has wrapped.
   */
  protected String getTextLineNumber(int rowStartOffset) {
<span class="nc" id="L310">    Element root = component.getDocument().getDefaultRootElement();</span>
<span class="nc" id="L311">    int index = root.getElementIndex(rowStartOffset);</span>
<span class="nc" id="L312">    Element line = root.getElement(index);</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (line.getStartOffset() == rowStartOffset)</span>
<span class="nc" id="L315">      return String.valueOf(index + 1);</span>
    else
<span class="nc" id="L317">      return &quot;&quot;;</span>
  }

  /*
   * Determine the X offset to properly align the line number when drawn
   */
  private int getOffsetX(int availableWidth, int stringWidth) {
<span class="nc" id="L324">    return (int) ((availableWidth - stringWidth) * digitAlignment);</span>
  }

  /*
   * Determine the Y offset for the current row
   */
  private int getOffsetY(int rowStartOffset, FontMetrics fontMetrics)
    throws BadLocationException {
    // Get the bounding rectangle of the row

<span class="nc" id="L334">    Rectangle r = component.modelToView(rowStartOffset);</span>
<span class="nc" id="L335">    int lineHeight = fontMetrics.getHeight();</span>
<span class="nc" id="L336">    int y = r.y + r.height;</span>
<span class="nc" id="L337">    int descent = 0;</span>

    // The text needs to be positioned above the bottom of the bounding
    // rectangle based on the descent of the font(s) contained on the row.

<span class="nc bnc" id="L342" title="All 2 branches missed.">    if (r.height == lineHeight) // default font is being used</span>
    {
<span class="nc" id="L344">      descent = fontMetrics.getDescent();</span>
    } else // We need to check all the attributes for font changes
    {
<span class="nc bnc" id="L347" title="All 2 branches missed.">      if (fonts == null)</span>
<span class="nc" id="L348">        fonts = new HashMap&lt;&gt;();</span>

<span class="nc" id="L350">      Element root = component.getDocument().getDefaultRootElement();</span>
<span class="nc" id="L351">      int index = root.getElementIndex(rowStartOffset);</span>
<span class="nc" id="L352">      Element line = root.getElement(index);</span>

<span class="nc bnc" id="L354" title="All 2 branches missed.">      for (int i = 0; i &lt; line.getElementCount(); i++) {</span>
<span class="nc" id="L355">        Element child = line.getElement(i);</span>
<span class="nc" id="L356">        AttributeSet as = child.getAttributes();</span>
<span class="nc" id="L357">        String fontFamily = (String) as.getAttribute(StyleConstants.FontFamily);</span>
<span class="nc" id="L358">        Integer fontSize = (Integer) as.getAttribute(StyleConstants.FontSize);</span>
<span class="nc" id="L359">        String key = fontFamily + fontSize;</span>

<span class="nc" id="L361">        FontMetrics fm = fonts.get(key);</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (fm == null) {</span>
<span class="nc" id="L364">          Font font = new Font(fontFamily, Font.PLAIN, fontSize);</span>
<span class="nc" id="L365">          fm = component.getFontMetrics(font);</span>
<span class="nc" id="L366">          fonts.put(key, fm);</span>
        }

<span class="nc" id="L369">        descent = Math.max(descent, fm.getDescent());</span>
      }
    }

<span class="nc" id="L373">    return y - descent;</span>
  }

  //
  // Implement CaretListener interface
  //
  @Override
  public void caretUpdate(CaretEvent e) {
    // Get the line the caret is positioned on

<span class="nc" id="L383">    int caretPosition = component.getCaretPosition();</span>
<span class="nc" id="L384">    Element root = component.getDocument().getDefaultRootElement();</span>
<span class="nc" id="L385">    int currentLine = root.getElementIndex(caretPosition);</span>

    // Need to repaint so the correct line number can be highlighted

<span class="nc bnc" id="L389" title="All 2 branches missed.">    if (lastLine != currentLine) {</span>
<span class="nc" id="L390">      repaint();</span>
<span class="nc" id="L391">      lastLine = currentLine;</span>
    }
<span class="nc" id="L393">  }</span>

  //
  // Implement DocumentListener interface
  //
  @Override
  public void changedUpdate(DocumentEvent e) {
<span class="nc" id="L400">    documentChanged();</span>
<span class="nc" id="L401">  }</span>

  @Override
  public void insertUpdate(DocumentEvent e) {
<span class="nc" id="L405">    documentChanged();</span>
<span class="nc" id="L406">  }</span>

  @Override
  public void removeUpdate(DocumentEvent e) {
<span class="nc" id="L410">    documentChanged();</span>
<span class="nc" id="L411">  }</span>

  /*
   * A document change may affect the number of displayed lines of text.
   * Therefore the lines numbers will also change.
   */
  private void documentChanged() {
    // View of the component has not been updated at the time
    // the DocumentEvent is fired

<span class="nc" id="L421">    SwingUtilities.invokeLater(new Runnable() {</span>
      @Override
      public void run() {
        try {
<span class="nc" id="L425">          int endPos = component.getDocument().getLength();</span>
<span class="nc" id="L426">          Rectangle rect = component.modelToView(endPos);</span>

<span class="nc bnc" id="L428" title="All 4 branches missed.">          if (rect != null &amp;&amp; rect.y != lastHeight) {</span>
<span class="nc" id="L429">            setPreferredWidth();</span>
<span class="nc" id="L430">            repaint();</span>
<span class="nc" id="L431">            lastHeight = rect.y;</span>
          }
<span class="nc" id="L433">        } catch (BadLocationException ex) {</span>
          /* nothing to do */
<span class="nc" id="L435">        }</span>
<span class="nc" id="L436">      }</span>
    });
<span class="nc" id="L438">  }</span>

  //
  // Implement PropertyChangeListener interface
  //
  @Override
  public void propertyChange(PropertyChangeEvent evt) {
<span class="nc bnc" id="L445" title="All 2 branches missed.">    if (evt.getNewValue() instanceof Font) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">      if (updateFont) {</span>
<span class="nc" id="L447">        Font newFont = (Font) evt.getNewValue();</span>
<span class="nc" id="L448">        setFont(newFont);</span>
<span class="nc" id="L449">        lastDigits = 0;</span>
<span class="nc" id="L450">        setPreferredWidth();</span>
<span class="nc" id="L451">      } else {</span>
<span class="nc" id="L452">        repaint();</span>
      }
    }
<span class="nc" id="L455">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>