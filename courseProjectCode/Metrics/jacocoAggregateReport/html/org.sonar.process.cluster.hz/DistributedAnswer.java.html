<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DistributedAnswer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.process.cluster.hz</a> &gt; <span class="el_source">DistributedAnswer.java</span></div><h1>DistributedAnswer.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.process.cluster.hz;

import com.hazelcast.cluster.Member;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static org.sonar.process.cluster.hz.HazelcastMember.Attribute.NODE_NAME;

/**
 * Answer of {@link DistributedCall}, aggregating the answers from
 * all the target members.
 */
<span class="fc" id="L39">public class DistributedAnswer&lt;T&gt; {</span>

<span class="fc" id="L41">  private final Map&lt;Member, T&gt; answers = new HashMap&lt;&gt;();</span>
<span class="fc" id="L42">  private final Set&lt;Member&gt; timedOutMembers = new HashSet&lt;&gt;();</span>
<span class="fc" id="L43">  private final Map&lt;Member, Exception&gt; failedMembers = new HashMap&lt;&gt;();</span>

  public Optional&lt;T&gt; getAnswer(Member member) {
<span class="fc" id="L46">    return Optional.ofNullable(answers.get(member));</span>
  }

  public boolean hasTimedOut(Member member) {
<span class="fc" id="L50">    return timedOutMembers.contains(member);</span>
  }

  public Optional&lt;Exception&gt; getFailed(Member member) {
<span class="fc" id="L54">    return Optional.ofNullable(failedMembers.get(member));</span>
  }

  public Collection&lt;Member&gt; getMembers() {
<span class="fc" id="L58">    List&lt;Member&gt; members = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L59">    members.addAll(answers.keySet());</span>
<span class="fc" id="L60">    members.addAll(timedOutMembers);</span>
<span class="fc" id="L61">    members.addAll(failedMembers.keySet());</span>
<span class="fc" id="L62">    return members;</span>
  }

  public void setAnswer(Member member, T answer) {
<span class="fc" id="L66">    this.answers.put(member, answer);</span>
<span class="fc" id="L67">  }</span>

  public void setTimedOut(Member member) {
<span class="fc" id="L70">    this.timedOutMembers.add(member);</span>
<span class="fc" id="L71">  }</span>

  public void setFailed(Member member, Exception e) {
<span class="fc" id="L74">    failedMembers.put(member, e);</span>
<span class="fc" id="L75">  }</span>

  public void propagateExceptions() {
<span class="fc bfc" id="L78" title="All 2 branches covered.">    if (!failedMembers.isEmpty()) {</span>
<span class="fc" id="L79">      String failedMemberNames = failedMembers.keySet().stream()</span>
<span class="fc" id="L80">        .map(m -&gt; m.getAttribute(NODE_NAME.getKey()))</span>
<span class="fc" id="L81">        .collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L82">      throw new IllegalStateException(&quot;Distributed cluster action in cluster nodes &quot; + failedMemberNames + &quot; (other nodes may have timed out)&quot;,</span>
<span class="fc" id="L83">        failedMembers.values().iterator().next());</span>
    }

<span class="fc bfc" id="L86" title="All 2 branches covered.">    if (!timedOutMembers.isEmpty()) {</span>
<span class="fc" id="L87">      String timedOutMemberNames = timedOutMembers.stream()</span>
<span class="fc" id="L88">        .map(m -&gt; m.getAttribute(NODE_NAME.getKey()))</span>
<span class="fc" id="L89">        .collect(Collectors.joining(&quot;, &quot;));</span>
<span class="fc" id="L90">      throw new IllegalStateException(&quot;Distributed cluster action timed out in cluster nodes &quot; + timedOutMemberNames);</span>
    }
<span class="fc" id="L92">  }</span>

  /**
   * Returns any answer. No guarantees are made on the order. Use this method if you only expect exactly one answer.
   * @return the first answer, if any
   */
  public Optional&lt;T&gt; getSingleAnswer() {
<span class="fc" id="L99">    return answers.values().stream().findFirst();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>