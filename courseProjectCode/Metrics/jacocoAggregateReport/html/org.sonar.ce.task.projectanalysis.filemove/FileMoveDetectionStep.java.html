<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileMoveDetectionStep.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.ce.task.projectanalysis.filemove</a> &gt; <span class="el_source">FileMoveDetectionStep.java</span></div><h1>FileMoveDetectionStep.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.ce.task.projectanalysis.filemove;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.apache.ibatis.session.ResultContext;
import org.apache.ibatis.session.ResultHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.ce.task.projectanalysis.analysis.AnalysisMetadataHolder;
import org.sonar.ce.task.projectanalysis.component.Component;
import org.sonar.ce.task.projectanalysis.component.CrawlerDepthLimit;
import org.sonar.ce.task.projectanalysis.component.DepthTraversalTypeAwareCrawler;
import org.sonar.ce.task.projectanalysis.component.TreeRootHolder;
import org.sonar.ce.task.projectanalysis.component.TypeAwareVisitorAdapter;
import org.sonar.ce.task.projectanalysis.filemove.FileSimilarity.File;
import org.sonar.ce.task.projectanalysis.filemove.FileSimilarity.FileImpl;
import org.sonar.ce.task.projectanalysis.filemove.FileSimilarity.LazyFileImpl;
import org.sonar.ce.task.projectanalysis.source.SourceLinesHashRepository;
import org.sonar.ce.task.step.ComputationStep;
import org.sonar.core.util.logs.Profiler;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.component.FileMoveRowDto;
import org.sonar.db.source.LineHashesWithUuidDto;

import static org.sonar.ce.task.projectanalysis.component.ComponentVisitor.Order.POST_ORDER;

public class FileMoveDetectionStep implements ComputationStep {
  static final int MIN_REQUIRED_SCORE = 85;
<span class="fc" id="L65">  private static final Logger LOG = LoggerFactory.getLogger(FileMoveDetectionStep.class);</span>
<span class="fc" id="L66">  private static final Comparator&lt;ScoreMatrix.ScoreFile&gt; SCORE_FILE_COMPARATOR = (o1, o2) -&gt; -1 * Integer.compare(o1.getLineCount(), o2.getLineCount());</span>
  private static final double LOWER_BOUND_RATIO = 0.84;
  private static final double UPPER_BOUND_RATIO = 1.18;

  private final AnalysisMetadataHolder analysisMetadataHolder;
  private final TreeRootHolder rootHolder;
  private final DbClient dbClient;
  private final FileSimilarity fileSimilarity;
  private final MutableMovedFilesRepository movedFilesRepository;
  private final SourceLinesHashRepository sourceLinesHash;
  private final ScoreMatrixDumper scoreMatrixDumper;
  private final MutableAddedFileRepository addedFileRepository;

  public FileMoveDetectionStep(AnalysisMetadataHolder analysisMetadataHolder, TreeRootHolder rootHolder, DbClient dbClient,
    FileSimilarity fileSimilarity, MutableMovedFilesRepository movedFilesRepository, SourceLinesHashRepository sourceLinesHash,
<span class="fc" id="L81">    ScoreMatrixDumper scoreMatrixDumper, MutableAddedFileRepository addedFileRepository) {</span>
<span class="fc" id="L82">    this.analysisMetadataHolder = analysisMetadataHolder;</span>
<span class="fc" id="L83">    this.rootHolder = rootHolder;</span>
<span class="fc" id="L84">    this.dbClient = dbClient;</span>
<span class="fc" id="L85">    this.fileSimilarity = fileSimilarity;</span>
<span class="fc" id="L86">    this.movedFilesRepository = movedFilesRepository;</span>
<span class="fc" id="L87">    this.sourceLinesHash = sourceLinesHash;</span>
<span class="fc" id="L88">    this.scoreMatrixDumper = scoreMatrixDumper;</span>
<span class="fc" id="L89">    this.addedFileRepository = addedFileRepository;</span>
<span class="fc" id="L90">  }</span>

  @Override
  public String getDescription() {
<span class="fc" id="L94">    return &quot;Detect file moves&quot;;</span>
  }

  @Override
  public void execute(ComputationStep.Context context) {
<span class="fc bfc" id="L99" title="All 2 branches covered.">    if (analysisMetadataHolder.isPullRequest()) {</span>
<span class="fc" id="L100">      LOG.debug(&quot;Currently within Pull Request scope. Do nothing.&quot;);</span>
<span class="fc" id="L101">      return;</span>
    }

    // do nothing if no files in db (first analysis)
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">    if (analysisMetadataHolder.isFirstAnalysis()) {</span>
<span class="nc" id="L106">      LOG.debug(&quot;First analysis. Do nothing.&quot;);</span>
<span class="nc" id="L107">      return;</span>
    }
<span class="fc" id="L109">    Profiler p = Profiler.createIfTrace(LOG);</span>

<span class="fc" id="L111">    p.start();</span>
<span class="fc" id="L112">    Map&lt;String, Component&gt; reportFilesByUuid = getReportFilesByUuid(this.rootHolder.getRoot());</span>
<span class="fc" id="L113">    context.getStatistics().add(&quot;reportFiles&quot;, reportFilesByUuid.size());</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">    if (reportFilesByUuid.isEmpty()) {</span>
<span class="fc" id="L115">      LOG.debug(&quot;No files in report. No file move detection.&quot;);</span>
<span class="fc" id="L116">      return;</span>
    }

<span class="fc" id="L119">    Map&lt;String, DbComponent&gt; dbFilesByUuid = getDbFilesByUuid();</span>
<span class="fc" id="L120">    context.getStatistics().add(&quot;dbFiles&quot;, dbFilesByUuid.size());</span>

<span class="fc" id="L122">    Set&lt;String&gt; addedFileUuids = difference(reportFilesByUuid.keySet(), dbFilesByUuid.keySet());</span>
<span class="fc" id="L123">    context.getStatistics().add(&quot;addedFiles&quot;, addedFileUuids.size());</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">    if (dbFilesByUuid.isEmpty()) {</span>
<span class="fc" id="L126">      registerAddedFiles(addedFileUuids, reportFilesByUuid, null);</span>
<span class="fc" id="L127">      LOG.debug(&quot;Previous snapshot has no file. No file move detection.&quot;);</span>
<span class="fc" id="L128">      return;</span>
    }

<span class="fc" id="L131">    Set&lt;String&gt; removedFileUuids = difference(dbFilesByUuid.keySet(), reportFilesByUuid.keySet());</span>

    // can't find matches if at least one of the added or removed files groups is empty =&gt; abort
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">    if (addedFileUuids.isEmpty() || removedFileUuids.isEmpty()) {</span>
<span class="fc" id="L135">      registerAddedFiles(addedFileUuids, reportFilesByUuid, null);</span>
<span class="fc" id="L136">      LOG.debug(&quot;Either no files added or no files removed. Do nothing.&quot;);</span>
<span class="fc" id="L137">      return;</span>
    }

    // retrieve file data from report
<span class="fc" id="L141">    Map&lt;String, File&gt; addedFileHashesByUuid = getReportFileHashesByUuid(reportFilesByUuid, addedFileUuids);</span>
<span class="fc" id="L142">    p.stopTrace(&quot;loaded&quot;);</span>

    // compute score matrix
<span class="fc" id="L145">    p.start();</span>
<span class="fc" id="L146">    ScoreMatrix scoreMatrix = computeScoreMatrix(dbFilesByUuid, removedFileUuids, addedFileHashesByUuid);</span>
<span class="fc" id="L147">    p.stopTrace(&quot;Score matrix computed&quot;);</span>
<span class="fc" id="L148">    scoreMatrixDumper.dumpAsCsv(scoreMatrix);</span>

    // not a single match with score higher than MIN_REQUIRED_SCORE =&gt; abort
<span class="fc bfc" id="L151" title="All 2 branches covered.">    if (scoreMatrix.getMaxScore() &lt; MIN_REQUIRED_SCORE) {</span>
<span class="fc" id="L152">      context.getStatistics().add(&quot;movedFiles&quot;, 0);</span>
<span class="fc" id="L153">      registerAddedFiles(addedFileUuids, reportFilesByUuid, null);</span>
<span class="fc" id="L154">      LOG.debug(&quot;max score in matrix is less than min required score ({}). Do nothing.&quot;, MIN_REQUIRED_SCORE);</span>
<span class="fc" id="L155">      return;</span>
    }

<span class="fc" id="L158">    p.start();</span>
<span class="fc" id="L159">    MatchesByScore matchesByScore = MatchesByScore.create(scoreMatrix);</span>

<span class="fc" id="L161">    ElectedMatches electedMatches = electMatches(removedFileUuids, addedFileHashesByUuid, matchesByScore);</span>
<span class="fc" id="L162">    p.stopTrace(&quot;Matches elected&quot;);</span>

<span class="fc" id="L164">    context.getStatistics().add(&quot;movedFiles&quot;, electedMatches.size());</span>
<span class="fc" id="L165">    registerMatches(dbFilesByUuid, reportFilesByUuid, electedMatches);</span>
<span class="fc" id="L166">    registerAddedFiles(addedFileUuids, reportFilesByUuid, electedMatches);</span>
<span class="fc" id="L167">  }</span>

  public Set&lt;String&gt; difference(Set&lt;String&gt; set1, Set&lt;String&gt; set2) {
<span class="pc bpc" id="L170" title="1 of 4 branches missed.">    if (set1.isEmpty() || set2.isEmpty()) {</span>
<span class="fc" id="L171">      return set1;</span>
    }
<span class="fc" id="L173">    return Sets.difference(set1, set2).immutableCopy();</span>
  }

  private void registerMatches(Map&lt;String, DbComponent&gt; dbFilesByUuid, Map&lt;String, Component&gt; reportFilesByUuid, ElectedMatches electedMatches) {
<span class="fc" id="L177">    LOG.debug(&quot;{} files moves found&quot;, electedMatches.size());</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">    for (Match validatedMatch : electedMatches) {</span>
<span class="fc" id="L179">      movedFilesRepository.setOriginalFile(</span>
<span class="fc" id="L180">        reportFilesByUuid.get(validatedMatch.reportUuid()),</span>
<span class="fc" id="L181">        toOriginalFile(dbFilesByUuid.get(validatedMatch.dbUuid())));</span>
<span class="fc" id="L182">      LOG.trace(&quot;File move found: {}&quot;, validatedMatch);</span>
<span class="fc" id="L183">    }</span>
<span class="fc" id="L184">  }</span>

  private void registerAddedFiles(Set&lt;String&gt; addedFileUuids, Map&lt;String, Component&gt; reportFilesByUuid, @Nullable ElectedMatches electedMatches) {
<span class="fc bfc" id="L187" title="All 4 branches covered.">    if (electedMatches == null || electedMatches.isEmpty()) {</span>
<span class="fc" id="L188">      addedFileUuids.stream()</span>
<span class="fc" id="L189">        .map(reportFilesByUuid::get)</span>
<span class="fc" id="L190">        .forEach(addedFileRepository::register);</span>
    } else {
<span class="fc" id="L192">      Set&lt;String&gt; reallyAddedFileUuids = new HashSet&lt;&gt;(addedFileUuids);</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">      for (Match electedMatch : electedMatches) {</span>
<span class="fc" id="L194">        reallyAddedFileUuids.remove(electedMatch.reportUuid());</span>
<span class="fc" id="L195">      }</span>
<span class="fc" id="L196">      reallyAddedFileUuids.stream()</span>
<span class="fc" id="L197">        .map(reportFilesByUuid::get)</span>
<span class="fc" id="L198">        .forEach(addedFileRepository::register);</span>
    }
<span class="fc" id="L200">  }</span>

  private Map&lt;String, DbComponent&gt; getDbFilesByUuid() {
<span class="fc" id="L203">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L204">      ImmutableList.Builder&lt;DbComponent&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L205">      dbClient.componentDao().scrollAllFilesForFileMove(dbSession, rootHolder.getRoot().getUuid(),</span>
        resultContext -&gt; {
<span class="fc" id="L207">          FileMoveRowDto row = resultContext.getResultObject();</span>
<span class="fc" id="L208">          builder.add(new DbComponent(row.getKey(), row.getUuid(), row.getPath(), row.getLineCount()));</span>
<span class="fc" id="L209">        });</span>
<span class="fc" id="L210">      return builder.build().stream()</span>
<span class="fc" id="L211">        .collect(Collectors.toMap(DbComponent::uuid, Function.identity()));</span>
    }
  }

  private static Map&lt;String, Component&gt; getReportFilesByUuid(Component root) {
<span class="fc" id="L216">    final ImmutableMap.Builder&lt;String, Component&gt; builder = ImmutableMap.builder();</span>
<span class="fc" id="L217">    new DepthTraversalTypeAwareCrawler(</span>
<span class="fc" id="L218">      new TypeAwareVisitorAdapter(CrawlerDepthLimit.FILE, POST_ORDER) {</span>
        @Override
        public void visitFile(Component file) {
<span class="fc" id="L221">          builder.put(file.getUuid(), file);</span>
<span class="fc" id="L222">        }</span>
<span class="fc" id="L223">      }).visit(root);</span>
<span class="fc" id="L224">    return builder.build();</span>
  }

  private Map&lt;String, File&gt; getReportFileHashesByUuid(Map&lt;String, Component&gt; reportFilesByUuid, Set&lt;String&gt; addedFileUuids) {
<span class="fc" id="L228">    return addedFileUuids.stream().collect(Collectors.toMap(fileUuid -&gt; fileUuid, fileUuid -&gt; {</span>
<span class="fc" id="L229">      Component component = reportFilesByUuid.get(fileUuid);</span>
<span class="fc" id="L230">      return new LazyFileImpl(() -&gt; getReportFileLineHashes(component), component.getFileAttributes().getLines());</span>
    }));
  }

  private List&lt;String&gt; getReportFileLineHashes(Component component) {
    // this is not ideal because if the file moved, this component won't exist in DB with the same UUID.
    // Assuming that the file also had significant code before the move, it will be fine.
<span class="fc" id="L237">    return sourceLinesHash.getLineHashesMatchingDBVersion(component);</span>
  }

  private ScoreMatrix computeScoreMatrix(Map&lt;String, DbComponent&gt; dtosByUuid, Set&lt;String&gt; removedFileUuids, Map&lt;String, File&gt; addedFileHashesByUuid) {
<span class="fc" id="L241">    ScoreMatrix.ScoreFile[] addedFiles = addedFileHashesByUuid.entrySet().stream()</span>
<span class="fc" id="L242">      .map(e -&gt; new ScoreMatrix.ScoreFile(e.getKey(), e.getValue().getLineCount()))</span>
<span class="fc" id="L243">      .toArray(ScoreMatrix.ScoreFile[]::new);</span>
<span class="fc" id="L244">    ScoreMatrix.ScoreFile[] removedFiles = removedFileUuids.stream()</span>
<span class="fc" id="L245">      .map(key -&gt; {</span>
<span class="fc" id="L246">        DbComponent dbComponent = dtosByUuid.get(key);</span>
<span class="fc" id="L247">        return new ScoreMatrix.ScoreFile(dbComponent.uuid(), dbComponent.lineCount());</span>
      })
<span class="fc" id="L249">      .toArray(ScoreMatrix.ScoreFile[]::new);</span>

    // sort by highest line count first
<span class="fc" id="L252">    Arrays.sort(addedFiles, SCORE_FILE_COMPARATOR);</span>
<span class="fc" id="L253">    Arrays.sort(removedFiles, SCORE_FILE_COMPARATOR);</span>
<span class="fc" id="L254">    int[][] scoreMatrix = new int[removedFiles.length][addedFiles.length];</span>
<span class="fc" id="L255">    int smallestAddedFileSize = addedFiles[0].getLineCount();</span>
<span class="fc" id="L256">    int largestAddedFileSize = addedFiles[addedFiles.length - 1].getLineCount();</span>

<span class="fc" id="L258">    Map&lt;String, Integer&gt; removedFilesIndexesByUuid = new HashMap&lt;&gt;(removedFileUuids.size());</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">    for (int removeFileIndex = 0; removeFileIndex &lt; removedFiles.length; removeFileIndex++) {</span>
<span class="fc" id="L260">      ScoreMatrix.ScoreFile removedFile = removedFiles[removeFileIndex];</span>
<span class="fc" id="L261">      int lowerBound = (int) Math.floor(removedFile.getLineCount() * LOWER_BOUND_RATIO);</span>
<span class="fc" id="L262">      int upperBound = (int) Math.ceil(removedFile.getLineCount() * UPPER_BOUND_RATIO);</span>
      // no need to compute score if all files are out of bound, so no need to load line hashes from DB
<span class="fc bfc" id="L264" title="All 4 branches covered.">      if (smallestAddedFileSize &lt;= lowerBound || largestAddedFileSize &gt;= upperBound) {</span>
<span class="fc" id="L265">        continue;</span>
      }
<span class="fc" id="L267">      removedFilesIndexesByUuid.put(removedFile.getFileUuid(), removeFileIndex);</span>
    }

<span class="fc" id="L270">    LineHashesWithKeyDtoResultHandler rowHandler = new LineHashesWithKeyDtoResultHandler(removedFilesIndexesByUuid, removedFiles,</span>
      addedFiles, addedFileHashesByUuid, scoreMatrix);
<span class="fc" id="L272">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L273">      dbClient.fileSourceDao().scrollLineHashes(dbSession, removedFilesIndexesByUuid.keySet(), rowHandler);</span>
    }

<span class="fc" id="L276">    return new ScoreMatrix(removedFiles, addedFiles, scoreMatrix, rowHandler.getMaxScore());</span>
  }

  private final class LineHashesWithKeyDtoResultHandler implements ResultHandler&lt;LineHashesWithUuidDto&gt; {
    private final Map&lt;String, Integer&gt; removedFileIndexesByUuid;
    private final ScoreMatrix.ScoreFile[] removedFiles;
    private final ScoreMatrix.ScoreFile[] newFiles;
    private final Map&lt;String, File&gt; newFilesByUuid;
    private final int[][] scoreMatrix;
    private int maxScore;

    private LineHashesWithKeyDtoResultHandler(Map&lt;String, Integer&gt; removedFileIndexesByUuid, ScoreMatrix.ScoreFile[] removedFiles,
      ScoreMatrix.ScoreFile[] newFiles, Map&lt;String, File&gt; newFilesByUuid,
<span class="fc" id="L289">      int[][] scoreMatrix) {</span>
<span class="fc" id="L290">      this.removedFileIndexesByUuid = removedFileIndexesByUuid;</span>
<span class="fc" id="L291">      this.removedFiles = removedFiles;</span>
<span class="fc" id="L292">      this.newFiles = newFiles;</span>
<span class="fc" id="L293">      this.newFilesByUuid = newFilesByUuid;</span>
<span class="fc" id="L294">      this.scoreMatrix = scoreMatrix;</span>
<span class="fc" id="L295">    }</span>

    @Override
    public void handleResult(ResultContext&lt;? extends LineHashesWithUuidDto&gt; resultContext) {
<span class="fc" id="L299">      LineHashesWithUuidDto lineHashesDto = resultContext.getResultObject();</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">      if (lineHashesDto.getPath() == null) {</span>
<span class="nc" id="L301">        return;</span>
      }
<span class="fc" id="L303">      int removedFileIndex = removedFileIndexesByUuid.get(lineHashesDto.getUuid());</span>
<span class="fc" id="L304">      ScoreMatrix.ScoreFile removedFile = removedFiles[removedFileIndex];</span>
<span class="fc" id="L305">      int lowerBound = (int) Math.floor(removedFile.getLineCount() * LOWER_BOUND_RATIO);</span>
<span class="fc" id="L306">      int upperBound = (int) Math.ceil(removedFile.getLineCount() * UPPER_BOUND_RATIO);</span>

<span class="fc bfc" id="L308" title="All 2 branches covered.">      for (int newFileIndex = 0; newFileIndex &lt; newFiles.length; newFileIndex++) {</span>
<span class="fc" id="L309">        ScoreMatrix.ScoreFile newFile = newFiles[newFileIndex];</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (newFile.getLineCount() &gt;= upperBound) {</span>
<span class="fc" id="L311">          continue;</span>
        }
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (newFile.getLineCount() &lt;= lowerBound) {</span>
<span class="fc" id="L314">          break;</span>
        }

<span class="fc" id="L317">        File fileHashesInDb = new FileImpl(lineHashesDto.getLineHashes());</span>
<span class="fc" id="L318">        File unmatchedFile = newFilesByUuid.get(newFile.getFileUuid());</span>
<span class="fc" id="L319">        int score = fileSimilarity.score(fileHashesInDb, unmatchedFile);</span>
<span class="fc" id="L320">        scoreMatrix[removedFileIndex][newFileIndex] = score;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (score &gt; maxScore) {</span>
<span class="fc" id="L322">          maxScore = score;</span>
        }
      }
<span class="fc" id="L325">    }</span>

    int getMaxScore() {
<span class="fc" id="L328">      return maxScore;</span>
    }
  }

  private static ElectedMatches electMatches(Set&lt;String&gt; dbFileUuids, Map&lt;String, File&gt; reportFileSourcesByUuid, MatchesByScore matchesByScore) {
<span class="fc" id="L333">    ElectedMatches electedMatches = new ElectedMatches(matchesByScore, dbFileUuids, reportFileSourcesByUuid);</span>
<span class="fc" id="L334">    Multimap&lt;String, Match&gt; matchesPerFileForScore = ArrayListMultimap.create();</span>
<span class="fc" id="L335">    matchesByScore.forEach(matches -&gt; electMatches(matches, electedMatches, matchesPerFileForScore));</span>
<span class="fc" id="L336">    return electedMatches;</span>
  }

  private static void electMatches(@Nullable List&lt;Match&gt; matches, ElectedMatches electedMatches, Multimap&lt;String, Match&gt; matchesPerFileForScore) {
    // no match for this score value, ignore
<span class="fc bfc" id="L341" title="All 2 branches covered.">    if (matches == null) {</span>
<span class="fc" id="L342">      return;</span>
    }

<span class="fc" id="L345">    List&lt;Match&gt; matchesToValidate = electedMatches.filter(matches);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">    if (matchesToValidate.isEmpty()) {</span>
<span class="fc" id="L347">      return;</span>
    }
<span class="fc bfc" id="L349" title="All 2 branches covered.">    if (matchesToValidate.size() == 1) {</span>
<span class="fc" id="L350">      Match match = matchesToValidate.get(0);</span>
<span class="fc" id="L351">      electedMatches.add(match);</span>
<span class="fc" id="L352">    } else {</span>
<span class="fc" id="L353">      matchesPerFileForScore.clear();</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">      for (Match match : matchesToValidate) {</span>
<span class="fc" id="L355">        matchesPerFileForScore.put(match.dbUuid(), match);</span>
<span class="fc" id="L356">        matchesPerFileForScore.put(match.reportUuid(), match);</span>
<span class="fc" id="L357">      }</span>
      // validate non-ambiguous matches (i.e. the match is the only match of either the db file and the report file)
<span class="fc bfc" id="L359" title="All 2 branches covered.">      for (Match match : matchesToValidate) {</span>
<span class="fc" id="L360">        int dbFileMatchesCount = matchesPerFileForScore.get(match.dbUuid()).size();</span>
<span class="fc" id="L361">        int reportFileMatchesCount = matchesPerFileForScore.get(match.reportUuid()).size();</span>
<span class="fc bfc" id="L362" title="All 4 branches covered.">        if (dbFileMatchesCount == 1 &amp;&amp; reportFileMatchesCount == 1) {</span>
<span class="fc" id="L363">          electedMatches.add(match);</span>
        }
<span class="fc" id="L365">      }</span>
    }
<span class="fc" id="L367">  }</span>

  private static MovedFilesRepository.OriginalFile toOriginalFile(DbComponent dbComponent) {
<span class="fc" id="L370">    return new MovedFilesRepository.OriginalFile(dbComponent.uuid(), dbComponent.key());</span>
  }

<span class="fc" id="L373">  public record DbComponent(String key, String uuid, String path, int lineCount) {</span>
  }

  private static class ElectedMatches implements Iterable&lt;Match&gt; {
    private final List&lt;Match&gt; matches;
    private final Set&lt;String&gt; matchedFileUuids;

<span class="fc" id="L380">    public ElectedMatches(MatchesByScore matchesByScore, Set&lt;String&gt; dbFileUuids, Map&lt;String, File&gt; reportFileHashesByUuid) {</span>
<span class="fc" id="L381">      this.matches = new ArrayList&lt;&gt;(matchesByScore.getSize());</span>
<span class="fc" id="L382">      this.matchedFileUuids = new HashSet&lt;&gt;(dbFileUuids.size() + reportFileHashesByUuid.size());</span>
<span class="fc" id="L383">    }</span>

    public void add(Match match) {
<span class="fc" id="L386">      matches.add(match);</span>
<span class="fc" id="L387">      matchedFileUuids.add(match.dbUuid());</span>
<span class="fc" id="L388">      matchedFileUuids.add(match.reportUuid());</span>
<span class="fc" id="L389">    }</span>

    public List&lt;Match&gt; filter(Collection&lt;Match&gt; matches) {
<span class="fc" id="L392">      return matches.stream().filter(this::notAlreadyMatched).toList();</span>
    }

    private boolean notAlreadyMatched(Match input) {
<span class="fc bfc" id="L396" title="All 4 branches covered.">      return !(matchedFileUuids.contains(input.dbUuid()) || matchedFileUuids.contains(input.reportUuid()));</span>
    }

    @Override
    public Iterator&lt;Match&gt; iterator() {
<span class="fc" id="L401">      return matches.iterator();</span>
    }

    public int size() {
<span class="fc" id="L405">      return matches.size();</span>
    }

    public boolean isEmpty() {
<span class="fc" id="L409">      return matches.isEmpty();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>