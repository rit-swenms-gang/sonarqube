<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PullRequestFileMoveDetectionStep.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.ce.task.projectanalysis.filemove</a> &gt; <span class="el_source">PullRequestFileMoveDetectionStep.java</span></div><h1>PullRequestFileMoveDetectionStep.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.ce.task.projectanalysis.filemove;

import com.google.common.collect.ImmutableMap;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.apache.ibatis.session.ResultHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.ce.task.projectanalysis.analysis.AnalysisMetadataHolder;
import org.sonar.ce.task.projectanalysis.component.Component;
import org.sonar.ce.task.projectanalysis.component.CrawlerDepthLimit;
import org.sonar.ce.task.projectanalysis.component.DepthTraversalTypeAwareCrawler;
import org.sonar.ce.task.projectanalysis.component.TreeRootHolder;
import org.sonar.ce.task.projectanalysis.component.TypeAwareVisitorAdapter;
import org.sonar.ce.task.projectanalysis.filemove.FileMoveDetectionStep.DbComponent;
import org.sonar.ce.task.projectanalysis.filemove.MovedFilesRepository.OriginalFile;
import org.sonar.ce.task.step.ComputationStep;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.component.BranchDto;
import org.sonar.db.component.FileMoveRowDto;

import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toMap;
import static org.sonar.ce.task.projectanalysis.component.ComponentVisitor.Order.POST_ORDER;

public class PullRequestFileMoveDetectionStep implements ComputationStep {
<span class="fc" id="L50">  private static final Logger LOG = LoggerFactory.getLogger(PullRequestFileMoveDetectionStep.class);</span>

  private final AnalysisMetadataHolder analysisMetadataHolder;
  private final TreeRootHolder rootHolder;
  private final DbClient dbClient;
  private final MutableMovedFilesRepository movedFilesRepository;
  private final MutableAddedFileRepository addedFileRepository;

  public PullRequestFileMoveDetectionStep(AnalysisMetadataHolder analysisMetadataHolder, TreeRootHolder rootHolder, DbClient dbClient,
<span class="fc" id="L59">    MutableMovedFilesRepository movedFilesRepository, MutableAddedFileRepository addedFileRepository) {</span>
<span class="fc" id="L60">    this.analysisMetadataHolder = analysisMetadataHolder;</span>
<span class="fc" id="L61">    this.rootHolder = rootHolder;</span>
<span class="fc" id="L62">    this.dbClient = dbClient;</span>
<span class="fc" id="L63">    this.movedFilesRepository = movedFilesRepository;</span>
<span class="fc" id="L64">    this.addedFileRepository = addedFileRepository;</span>
<span class="fc" id="L65">  }</span>

  @Override
  public String getDescription() {
<span class="fc" id="L69">    return &quot;Detect file moves in Pull Request scope&quot;;</span>
  }

  @Override
  public void execute(ComputationStep.Context context) {
<span class="fc bfc" id="L74" title="All 2 branches covered.">    if (!analysisMetadataHolder.isPullRequest()) {</span>
<span class="fc" id="L75">      LOG.debug(&quot;Currently not within Pull Request scope. Do nothing.&quot;);</span>
<span class="fc" id="L76">      return;</span>
    }

<span class="fc" id="L79">    Map&lt;String, Component&gt; reportFilesByUuid = getReportFilesByUuid(this.rootHolder.getRoot());</span>
<span class="fc" id="L80">    context.getStatistics().add(&quot;reportFiles&quot;, reportFilesByUuid.size());</span>

<span class="fc bfc" id="L82" title="All 2 branches covered.">    if (reportFilesByUuid.isEmpty()) {</span>
<span class="fc" id="L83">      LOG.debug(&quot;No files in report. No file move detection.&quot;);</span>
<span class="fc" id="L84">      return;</span>
    }

<span class="fc" id="L87">    Map&lt;String, DbComponent&gt; targetBranchDbFilesByUuid = getTargetBranchDbFilesByUuid(analysisMetadataHolder);</span>
<span class="fc" id="L88">    context.getStatistics().add(&quot;dbFiles&quot;, targetBranchDbFilesByUuid.size());</span>

<span class="fc bfc" id="L90" title="All 2 branches covered.">    if (targetBranchDbFilesByUuid.isEmpty()) {</span>
<span class="fc" id="L91">      registerNewlyAddedFiles(reportFilesByUuid);</span>
<span class="fc" id="L92">      context.getStatistics().add(&quot;addedFiles&quot;, reportFilesByUuid.size());</span>
<span class="fc" id="L93">      LOG.debug(&quot;Target branch has no files. No file move detection.&quot;);</span>
<span class="fc" id="L94">      return;</span>
    }

<span class="fc" id="L97">    Collection&lt;Component&gt; movedFiles = getMovedFilesByUuid(reportFilesByUuid);</span>
<span class="fc" id="L98">    context.getStatistics().add(&quot;movedFiles&quot;, movedFiles.size());</span>

<span class="fc" id="L100">    Map&lt;String, Component&gt; newlyAddedFilesByUuid = getNewlyAddedFilesByUuid(reportFilesByUuid, targetBranchDbFilesByUuid);</span>
<span class="fc" id="L101">    context.getStatistics().add(&quot;addedFiles&quot;, newlyAddedFilesByUuid.size());</span>

<span class="fc" id="L103">    Map&lt;String, DbComponent&gt; dbFilesByPathReference = toDbFilesByPathReferenceMap(targetBranchDbFilesByUuid.values());</span>

<span class="fc" id="L105">    registerMovedFiles(movedFiles, dbFilesByPathReference);</span>
<span class="fc" id="L106">    registerNewlyAddedFiles(newlyAddedFilesByUuid);</span>
<span class="fc" id="L107">  }</span>

  private void registerMovedFiles(Collection&lt;Component&gt; movedFiles, Map&lt;String, DbComponent&gt; dbFilesByPathReference) {
<span class="fc" id="L110">    movedFiles</span>
<span class="fc" id="L111">      .forEach(movedFile -&gt; registerMovedFile(dbFilesByPathReference, movedFile));</span>
<span class="fc" id="L112">  }</span>

  private void registerMovedFile(Map&lt;String, DbComponent&gt; dbFiles, Component movedFile) {
<span class="fc" id="L115">    retrieveDbFile(dbFiles, movedFile)</span>
<span class="fc" id="L116">      .ifPresent(dbFile -&gt; movedFilesRepository.setOriginalPullRequestFile(movedFile, toOriginalFile(dbFile)));</span>
<span class="fc" id="L117">  }</span>

  private void registerNewlyAddedFiles(Map&lt;String, Component&gt; newAddedFilesByUuid) {
<span class="fc" id="L120">    newAddedFilesByUuid</span>
<span class="fc" id="L121">      .values()</span>
<span class="fc" id="L122">      .forEach(addedFileRepository::register);</span>
<span class="fc" id="L123">  }</span>

  private static Map&lt;String, Component&gt; getNewlyAddedFilesByUuid(Map&lt;String, Component&gt; reportFilesByUuid, Map&lt;String, DbComponent&gt; dbFilesByUuid) {
<span class="fc" id="L126">    return reportFilesByUuid</span>
<span class="fc" id="L127">      .values()</span>
<span class="fc" id="L128">      .stream()</span>
<span class="fc" id="L129">      .filter(file -&gt; Objects.isNull(file.getFileAttributes().getOldRelativePath()))</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">      .filter(file -&gt; !dbFilesByUuid.containsKey(file.getUuid()))</span>
<span class="fc" id="L131">      .collect(toMap(Component::getUuid, identity()));</span>
  }

  private static Collection&lt;Component&gt; getMovedFilesByUuid(Map&lt;String, Component&gt; reportFilesByUuid) {
<span class="fc" id="L135">    return reportFilesByUuid</span>
<span class="fc" id="L136">      .values()</span>
<span class="fc" id="L137">      .stream()</span>
<span class="fc" id="L138">      .filter(file -&gt; Objects.nonNull(file.getFileAttributes().getOldRelativePath()))</span>
<span class="fc" id="L139">      .toList();</span>
  }

  private static Optional&lt;DbComponent&gt; retrieveDbFile(Map&lt;String, DbComponent&gt; dbFilesByPathReference, Component file) {
<span class="fc" id="L143">    return Optional.ofNullable(dbFilesByPathReference.get(file.getFileAttributes().getOldRelativePath()));</span>
  }

  private Map&lt;String, DbComponent&gt; getTargetBranchDbFilesByUuid(AnalysisMetadataHolder analysisMetadataHolder) {
<span class="fc" id="L147">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L148">      return getTargetBranchUuid(dbSession, analysisMetadataHolder.getProject().getUuid(), analysisMetadataHolder.getBranch().getTargetBranchName())</span>
<span class="fc" id="L149">        .map(targetBranchUUid -&gt; getTargetBranchDbFilesByUuid(dbSession, targetBranchUUid))</span>
<span class="fc" id="L150">        .orElse(Map.of());</span>
    }
  }

  private Map&lt;String, DbComponent&gt; getTargetBranchDbFilesByUuid(DbSession dbSession, String targetBranchUuid) {
<span class="fc" id="L155">    Map&lt;String, DbComponent&gt; files = new HashMap&lt;&gt;();</span>
<span class="fc" id="L156">    dbClient.componentDao().scrollAllFilesForFileMove(dbSession, targetBranchUuid, accumulateFilesForFileMove(files));</span>
<span class="fc" id="L157">    return files;</span>
  }

  private static ResultHandler&lt;FileMoveRowDto&gt; accumulateFilesForFileMove(Map&lt;String, DbComponent&gt; accumulator) {
<span class="fc" id="L161">    return resultContext -&gt; {</span>
<span class="fc" id="L162">      DbComponent component = rowToDbComponent(resultContext.getResultObject());</span>
<span class="fc" id="L163">      accumulator.put(component.uuid(), component);</span>
<span class="fc" id="L164">    };</span>
  }

  private static DbComponent rowToDbComponent(FileMoveRowDto row) {
<span class="fc" id="L168">    return new DbComponent(row.getKey(), row.getUuid(), row.getPath(), row.getLineCount());</span>
  }

  private Optional&lt;String&gt; getTargetBranchUuid(DbSession dbSession, String projectUuid, String targetBranchName) {
<span class="fc" id="L172">    return dbClient.branchDao().selectByBranchKey(dbSession, projectUuid, targetBranchName)</span>
<span class="fc" id="L173">      .map(BranchDto::getUuid);</span>
  }

  private static Map&lt;String, DbComponent&gt; toDbFilesByPathReferenceMap(Collection&lt;DbComponent&gt; dbFiles) {
<span class="fc" id="L177">    return dbFiles</span>
<span class="fc" id="L178">      .stream()</span>
<span class="fc" id="L179">      .collect(toMap(DbComponent::path, identity()));</span>
  }

  private static Map&lt;String, Component&gt; getReportFilesByUuid(Component root) {
<span class="fc" id="L183">    final ImmutableMap.Builder&lt;String, Component&gt; builder = ImmutableMap.builder();</span>

<span class="fc" id="L185">    new DepthTraversalTypeAwareCrawler(</span>
<span class="fc" id="L186">      new TypeAwareVisitorAdapter(CrawlerDepthLimit.FILE, POST_ORDER) {</span>
        @Override
        public void visitFile(Component file) {
<span class="fc" id="L189">          builder.put(file.getUuid(), file);</span>
<span class="fc" id="L190">        }</span>
<span class="fc" id="L191">      }).visit(root);</span>

<span class="fc" id="L193">    return builder.build();</span>
  }

  private static OriginalFile toOriginalFile(DbComponent dbComponent) {
<span class="fc" id="L197">    return new OriginalFile(dbComponent.uuid(), dbComponent.key());</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>