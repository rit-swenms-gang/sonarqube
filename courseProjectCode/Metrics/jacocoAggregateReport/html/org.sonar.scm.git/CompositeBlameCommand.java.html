<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CompositeBlameCommand.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.scm.git</a> &gt; <span class="el_source">CompositeBlameCommand.java</span></div><h1>CompositeBlameCommand.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.scm.git;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.diff.RawTextComparator;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.treewalk.TreeWalk;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.scm.BlameCommand;
import org.sonar.api.batch.scm.BlameLine;
import org.sonar.api.notifications.AnalysisWarnings;
import org.sonar.api.scan.filesystem.PathResolver;
import org.sonar.api.utils.log.Logger;
import org.sonar.api.utils.log.Loggers;
import org.sonar.api.utils.log.Profiler;
import org.sonar.scm.git.blame.BlameResult;
import org.sonar.scm.git.blame.RepositoryBlameCommand;
import org.sonar.scm.git.strategy.BlameStrategy;
import org.sonar.scm.git.strategy.DefaultBlameStrategy.BlameAlgorithmEnum;

import static java.util.Optional.ofNullable;
import static org.sonar.scm.git.strategy.DefaultBlameStrategy.BlameAlgorithmEnum.GIT_FILES_BLAME;

public class CompositeBlameCommand extends BlameCommand {
<span class="fc" id="L64">  private static final Logger LOG = Loggers.get(CompositeBlameCommand.class);</span>

  private final AnalysisWarnings analysisWarnings;
  private final PathResolver pathResolver;
  private final JGitBlameCommand jgitCmd;
  private final NativeGitBlameCommand nativeCmd;
<span class="fc" id="L70">  private boolean nativeGitEnabled = false;</span>

  private final BlameStrategy blameStrategy;

  public CompositeBlameCommand(AnalysisWarnings analysisWarnings, PathResolver pathResolver, JGitBlameCommand jgitCmd,
<span class="fc" id="L75">    NativeGitBlameCommand nativeCmd, BlameStrategy blameStrategy) {</span>
<span class="fc" id="L76">    this.analysisWarnings = analysisWarnings;</span>
<span class="fc" id="L77">    this.pathResolver = pathResolver;</span>
<span class="fc" id="L78">    this.blameStrategy = blameStrategy;</span>
<span class="fc" id="L79">    this.jgitCmd = jgitCmd;</span>
<span class="fc" id="L80">    this.nativeCmd = nativeCmd;</span>
<span class="fc" id="L81">  }</span>

  @Override
  public void blame(BlameInput input, BlameOutput output) {
<span class="fc" id="L85">    File basedir = input.fileSystem().baseDir();</span>
<span class="fc" id="L86">    try (Repository repo = JGitUtils.buildRepository(basedir.toPath())) {</span>

<span class="fc" id="L88">      File gitBaseDir = repo.getWorkTree();</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">      if (cloneIsInvalid(gitBaseDir)) {</span>
<span class="fc" id="L90">        return;</span>
      }
<span class="fc" id="L92">      Profiler profiler = Profiler.create(LOG);</span>
<span class="fc" id="L93">      profiler.startDebug(&quot;Collecting committed files&quot;);</span>
<span class="fc" id="L94">      Map&lt;String, InputFile&gt; inputFileByGitRelativePath = getCommittedFilesToBlame(repo, gitBaseDir, input);</span>
<span class="fc" id="L95">      profiler.stopDebug();</span>

<span class="fc" id="L97">      BlameAlgorithmEnum blameAlgorithmEnum = this.blameStrategy.getBlameAlgorithm(Runtime.getRuntime().availableProcessors(), inputFileByGitRelativePath.size());</span>
<span class="fc" id="L98">      LOG.debug(&quot;Using {} strategy to blame files&quot;, blameAlgorithmEnum);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">      if (blameAlgorithmEnum == GIT_FILES_BLAME) {</span>
<span class="fc" id="L100">        blameWithFilesGitCommand(output, repo, inputFileByGitRelativePath);</span>
      } else {
<span class="fc" id="L102">        blameWithNativeGitCommand(output, repo, inputFileByGitRelativePath, gitBaseDir);</span>
      }
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">    }</span>
<span class="fc" id="L105">  }</span>

  private Map&lt;String, InputFile&gt; getCommittedFilesToBlame(Repository repo, File gitBaseDir, BlameInput input) {
<span class="fc" id="L108">    Set&lt;String&gt; committedFiles = collectAllCommittedFiles(repo);</span>
<span class="fc" id="L109">    Map&lt;String, InputFile&gt; inputFileByGitRelativePath = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    for (InputFile inputFile : input.filesToBlame()) {</span>
<span class="fc" id="L111">      String relative = pathResolver.relativePath(gitBaseDir, inputFile.file());</span>
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">      if (relative == null || !committedFiles.contains(relative)) {</span>
<span class="fc" id="L113">        continue;</span>
      }
<span class="fc" id="L115">      inputFileByGitRelativePath.put(relative, inputFile);</span>
<span class="fc" id="L116">    }</span>
<span class="fc" id="L117">    return inputFileByGitRelativePath;</span>
  }

  private void blameWithNativeGitCommand(BlameOutput output, Repository repo, Map&lt;String, InputFile&gt; inputFileByGitRelativePath, File gitBaseDir) {
<span class="fc" id="L121">    try (Git git = Git.wrap(repo)) {</span>
<span class="fc" id="L122">      nativeGitEnabled = nativeCmd.checkIfEnabled();</span>
<span class="fc" id="L123">      ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), new GitThreadFactory());</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">      for (Map.Entry&lt;String, InputFile&gt; e : inputFileByGitRelativePath.entrySet()) {</span>
<span class="fc" id="L126">        InputFile inputFile = e.getValue();</span>
<span class="fc" id="L127">        String filename = e.getKey();</span>
        // exceptions thrown by the blame method will be ignored
<span class="fc" id="L129">        executorService.submit(() -&gt; blame(output, git, gitBaseDir, inputFile, filename));</span>
<span class="fc" id="L130">      }</span>

<span class="fc" id="L132">      executorService.shutdown();</span>
      try {
<span class="fc" id="L134">        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span>
<span class="nc" id="L135">      } catch (InterruptedException e) {</span>
<span class="nc" id="L136">        LOG.info(&quot;Git blame interrupted&quot;, e);</span>
<span class="nc" id="L137">        Thread.currentThread().interrupt();</span>
<span class="fc" id="L138">      }</span>
    }
<span class="fc" id="L140">  }</span>

  private static Set&lt;String&gt; collectAllCommittedFiles(Repository repo) {
    try {
<span class="fc" id="L144">      Set&lt;String&gt; files = new HashSet&lt;&gt;();</span>
<span class="fc" id="L145">      Optional&lt;ObjectId&gt; headCommit = ofNullable(repo.resolve(Constants.HEAD));</span>

<span class="fc bfc" id="L147" title="All 2 branches covered.">      if (headCommit.isEmpty()) {</span>
<span class="fc" id="L148">        LOG.warn(&quot;Could not find HEAD commit&quot;);</span>
<span class="fc" id="L149">        return files;</span>
      }

<span class="fc" id="L152">      try (RevWalk revWalk = new RevWalk(repo)) {</span>
<span class="fc" id="L153">        RevCommit head = revWalk.parseCommit(headCommit.get());</span>
<span class="fc" id="L154">        try (TreeWalk treeWalk = new TreeWalk(repo)) {</span>
<span class="fc" id="L155">          treeWalk.addTree(head.getTree());</span>
<span class="fc" id="L156">          treeWalk.setRecursive(true);</span>

<span class="fc bfc" id="L158" title="All 2 branches covered.">          while (treeWalk.next()) {</span>
<span class="fc" id="L159">            String path = treeWalk.getPathString();</span>
<span class="fc" id="L160">            files.add(path);</span>
<span class="fc" id="L161">          }</span>
        }
      }
<span class="fc" id="L164">      return files;</span>
<span class="nc" id="L165">    } catch (IOException e) {</span>
<span class="nc" id="L166">      throw new IllegalStateException(&quot;Failed to find all committed files&quot;, e);</span>
    }
  }

  private void blame(BlameOutput output, Git git, File gitBaseDir, InputFile inputFile, String filename) {
<span class="fc" id="L171">    List&lt;BlameLine&gt; blame = null;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">    if (nativeGitEnabled) {</span>
      try {
<span class="fc" id="L174">        LOG.debug(&quot;Blame file (native) {}&quot;, filename);</span>
<span class="fc" id="L175">        blame = nativeCmd.blame(gitBaseDir.toPath(), filename);</span>
<span class="fc" id="L176">      } catch (Exception e) {</span>
<span class="fc" id="L177">        LOG.debug(&quot;Native git blame failed. Falling back to jgit: &quot; + filename, e);</span>
<span class="fc" id="L178">        nativeGitEnabled = false;</span>
<span class="fc" id="L179">      }</span>
    }

<span class="fc bfc" id="L182" title="All 2 branches covered.">    if (blame == null) {</span>
<span class="fc" id="L183">      LOG.debug(&quot;Blame file (JGit) {}&quot;, filename);</span>
<span class="fc" id="L184">      blame = jgitCmd.blame(git, filename);</span>
    }

<span class="pc bpc" id="L187" title="1 of 2 branches missed.">    if (!blame.isEmpty()) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">      if (blame.size() == inputFile.lines() - 1) {</span>
        // SONARPLUGINS-3097 Git does not report blame on last empty line
<span class="fc" id="L190">        blame.add(blame.get(blame.size() - 1));</span>
      }
<span class="fc" id="L192">      output.blameResult(inputFile, blame);</span>
    }
<span class="fc" id="L194">  }</span>

  private static void blameWithFilesGitCommand(BlameOutput output, Repository repo, Map&lt;String, InputFile&gt; inputFileByGitRelativePath) {
<span class="fc" id="L197">    RepositoryBlameCommand blameCommand = new RepositoryBlameCommand(repo)</span>
<span class="fc" id="L198">      .setTextComparator(RawTextComparator.WS_IGNORE_ALL)</span>
<span class="fc" id="L199">      .setMultithreading(true)</span>
<span class="fc" id="L200">      .setFilePaths(inputFileByGitRelativePath.keySet());</span>
    try {
<span class="fc" id="L202">      BlameResult blameResult = blameCommand.call();</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">      for (Map.Entry&lt;String, InputFile&gt; e : inputFileByGitRelativePath.entrySet()) {</span>
<span class="fc" id="L205">        BlameResult.FileBlame fileBlameResult = blameResult.getFileBlameByPath().get(e.getKey());</span>

<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (fileBlameResult == null) {</span>
<span class="nc" id="L208">          LOG.debug(&quot;Unable to blame file {}.&quot;, e.getValue().filename());</span>
<span class="nc" id="L209">          continue;</span>
        }

<span class="fc" id="L212">        saveBlameInformationForFileInTheOutput(fileBlameResult, e.getValue(), output);</span>
<span class="fc" id="L213">      }</span>
<span class="nc" id="L214">    } catch (GitAPIException e) {</span>
<span class="nc" id="L215">      LOG.warn(&quot;There was an issue when interacting with git repository: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L216">    }</span>
<span class="fc" id="L217">  }</span>

  private boolean cloneIsInvalid(File gitBaseDir) {
<span class="fc bfc" id="L220" title="All 2 branches covered.">    if (Files.isRegularFile(gitBaseDir.toPath().resolve(&quot;.git/objects/info/alternates&quot;))) {</span>
<span class="fc" id="L221">      LOG.info(&quot;This git repository references another local repository which is not well supported. SCM information might be missing for some files. &quot;</span>
        + &quot;You can avoid borrow objects from another local repository by not using --reference or --shared when cloning it.&quot;);
    }

<span class="fc bfc" id="L225" title="All 2 branches covered.">    if (Files.isRegularFile(gitBaseDir.toPath().resolve(&quot;.git/shallow&quot;))) {</span>
<span class="fc" id="L226">      LOG.warn(&quot;Shallow clone detected, no blame information will be provided. &quot; + &quot;You can convert to non-shallow with 'git fetch --unshallow'.&quot;);</span>
<span class="fc" id="L227">      analysisWarnings.addUnique(&quot;Shallow clone detected during the analysis. &quot; + &quot;Some files will miss SCM information. This will affect features like auto-assignment of issues. &quot;</span>
        + &quot;Please configure your build to disable shallow clone.&quot;);
<span class="fc" id="L229">      return true;</span>
    }

<span class="fc" id="L232">    return false;</span>
  }

  private static void saveBlameInformationForFileInTheOutput(BlameResult.FileBlame fileBlame, InputFile file, BlameOutput output) {
<span class="fc" id="L236">    List&lt;BlameLine&gt; linesList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">    for (int i = 0; i &lt; fileBlame.lines(); i++) {</span>
<span class="pc bpc" id="L238" title="3 of 6 branches missed.">      if (fileBlame.getAuthorEmails()[i] == null || fileBlame.getCommitHashes()[i] == null || fileBlame.getCommitDates()[i] == null) {</span>
<span class="nc" id="L239">        LOG.debug(&quot;Unable to blame file {}. No blame info at line {}. Is file committed? [Author: {} Source commit: {}]&quot;, file.filename());</span>
<span class="nc" id="L240">        linesList.clear();</span>
<span class="nc" id="L241">        break;</span>
      }
<span class="fc" id="L243">      linesList.add(new BlameLine()</span>
<span class="fc" id="L244">        .date(toDate(fileBlame.getCommitDates()[i]))</span>
<span class="fc" id="L245">        .revision(fileBlame.getCommitHashes()[i])</span>
<span class="fc" id="L246">        .author(fileBlame.getAuthorEmails()[i]));</span>
    }
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">    if (!linesList.isEmpty()) {</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">      if (linesList.size() == file.lines() - 1) {</span>
        // SONARPLUGINS-3097 Git does not report blame on last empty line
<span class="nc" id="L251">        linesList.add(linesList.get(linesList.size() - 1));</span>
      }
<span class="fc" id="L253">      output.blameResult(file, linesList);</span>
    }
<span class="fc" id="L255">  }</span>

  private static @Nullable Date toDate(@Nullable Instant commitDate) {
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">    return commitDate != null ? Date.from(commitDate) : null;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>