<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GitScmProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.scm.git</a> &gt; <span class="el_source">GitScmProvider.java</span></div><h1>GitScmProvider.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.scm.git;

import com.google.common.annotations.VisibleForTesting;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.time.Instant;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import javax.annotation.CheckForNull;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.diff.DiffAlgorithm;
import org.eclipse.jgit.diff.DiffEntry;
import org.eclipse.jgit.diff.DiffEntry.ChangeType;
import org.eclipse.jgit.diff.DiffFormatter;
import org.eclipse.jgit.diff.RawTextComparator;
import org.eclipse.jgit.diff.RenameDetector;
import org.eclipse.jgit.lib.Config;
import org.eclipse.jgit.lib.ConfigConstants;
import org.eclipse.jgit.lib.NullProgressMonitor;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.ObjectReader;
import org.eclipse.jgit.lib.Ref;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.lib.RepositoryBuilder;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.revwalk.filter.RevFilter;
import org.eclipse.jgit.treewalk.AbstractTreeIterator;
import org.eclipse.jgit.treewalk.CanonicalTreeParser;
import org.eclipse.jgit.treewalk.FileTreeIterator;
import org.eclipse.jgit.treewalk.filter.PathFilter;
import org.eclipse.jgit.treewalk.filter.PathFilterGroup;
import org.eclipse.jgit.treewalk.filter.TreeFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.batch.scm.BlameCommand;
import org.sonar.api.batch.scm.ScmProvider;
import org.sonar.api.notifications.AnalysisWarnings;
import org.sonar.api.utils.MessageException;
import org.sonar.api.utils.System2;
import org.sonar.core.documentation.DocumentationLinkGenerator;

import static java.lang.String.format;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toMap;
import static java.util.stream.Collectors.toSet;
import static java.util.stream.Collectors.toUnmodifiableMap;
import static org.eclipse.jgit.diff.DiffEntry.ChangeType.ADD;
import static org.eclipse.jgit.diff.DiffEntry.ChangeType.MODIFY;
import static org.eclipse.jgit.diff.DiffEntry.ChangeType.RENAME;

public class GitScmProvider extends ScmProvider {

<span class="fc" id="L86">  private static final Logger LOG = LoggerFactory.getLogger(GitScmProvider.class);</span>
  private static final String COULD_NOT_FIND_REF = &quot;Could not find ref '%s' in refs/heads, refs/remotes, refs/remotes/upstream or refs/remotes/origin&quot;;
  private static final String NO_MERGE_BASE_FOUND_MESSAGE = &quot;No merge base found between HEAD and %s&quot;;
  @VisibleForTesting
  static final String SCM_INTEGRATION_DOCUMENTATION_SUFFIX = &quot;/analyzing-source-code/scm-integration/&quot;;
  private final BlameCommand blameCommand;
  private final AnalysisWarnings analysisWarnings;
  private final GitIgnoreCommand gitIgnoreCommand;
  private final System2 system2;
  private final DocumentationLinkGenerator documentationLinkGenerator;

  public GitScmProvider(CompositeBlameCommand blameCommand, AnalysisWarnings analysisWarnings, GitIgnoreCommand gitIgnoreCommand, System2 system2,
<span class="fc" id="L98">    DocumentationLinkGenerator documentationLinkGenerator) {</span>

<span class="fc" id="L100">    this.blameCommand = blameCommand;</span>
<span class="fc" id="L101">    this.analysisWarnings = analysisWarnings;</span>
<span class="fc" id="L102">    this.gitIgnoreCommand = gitIgnoreCommand;</span>
<span class="fc" id="L103">    this.system2 = system2;</span>
<span class="fc" id="L104">    this.documentationLinkGenerator = documentationLinkGenerator;</span>
<span class="fc" id="L105">  }</span>

  @Override
  public GitIgnoreCommand ignoreCommand() {
<span class="fc" id="L109">    return gitIgnoreCommand;</span>
  }

  @Override
  public String key() {
<span class="fc" id="L114">    return &quot;git&quot;;</span>
  }

  @Override
  public boolean supports(File baseDir) {
<span class="fc" id="L119">    RepositoryBuilder builder = new RepositoryBuilder().findGitDir(baseDir);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">    return builder.getGitDir() != null;</span>
  }

  @Override
  public BlameCommand blameCommand() {
<span class="fc" id="L125">    return this.blameCommand;</span>
  }

  @CheckForNull
  @Override
  public Set&lt;Path&gt; branchChangedFiles(String targetBranchName, Path rootBaseDir) {
<span class="fc" id="L131">    return Optional.ofNullable((branchChangedFilesWithFileMovementDetection(targetBranchName, rootBaseDir)))</span>
<span class="fc" id="L132">      .map(GitScmProvider::extractAbsoluteFilePaths)</span>
<span class="fc" id="L133">      .orElse(null);</span>
  }

  @CheckForNull
  public Set&lt;ChangedFile&gt; branchChangedFilesWithFileMovementDetection(String targetBranchName, Path rootBaseDir) {
<span class="fc" id="L138">    try (Repository repo = buildRepo(rootBaseDir)) {</span>
<span class="fc" id="L139">      Ref targetRef = resolveTargetRef(targetBranchName, repo);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">      if (targetRef == null) {</span>
<span class="fc" id="L141">        addWarningTargetNotFound(targetBranchName);</span>
<span class="fc" id="L142">        return null;</span>
      }

<span class="pc bpc" id="L145" title="1 of 2 branches missed.">      if (isDiffAlgoInvalid(repo.getConfig())) {</span>
<span class="nc" id="L146">        LOG.warn(&quot;The diff algorithm configured in git is not supported. &quot;</span>
          + &quot;No information regarding changes in the branch will be collected, which can lead to unexpected results.&quot;);
<span class="nc" id="L148">        return null;</span>
      }

<span class="fc" id="L151">      Optional&lt;RevCommit&gt; mergeBaseCommit = findMergeBase(repo, targetRef);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">      if (mergeBaseCommit.isEmpty()) {</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if (LOG.isWarnEnabled()) {</span>
<span class="fc" id="L154">          LOG.warn(composeNoMergeBaseFoundWarning(targetRef.getName()));</span>
        }
<span class="fc" id="L156">        return null;</span>
      }
<span class="fc" id="L158">      AbstractTreeIterator mergeBaseTree = prepareTreeParser(repo, mergeBaseCommit.get());</span>

      // we compare a commit with HEAD, so no point ignoring line endings (it will be whatever is committed)
<span class="fc" id="L161">      try (Git git = newGit(repo)) {</span>
<span class="fc" id="L162">        List&lt;DiffEntry&gt; diffEntries = git.diff()</span>
<span class="fc" id="L163">          .setShowNameAndStatusOnly(true)</span>
<span class="fc" id="L164">          .setOldTree(mergeBaseTree)</span>
<span class="fc" id="L165">          .setNewTree(prepareNewTree(repo))</span>
<span class="fc" id="L166">          .call();</span>

<span class="fc" id="L168">        return computeChangedFiles(repo, diffEntries);</span>
      }
<span class="pc bpc" id="L170" title="4 of 6 branches missed.">    } catch (IOException | GitAPIException e) {</span>
<span class="fc" id="L171">      LOG.warn(e.getMessage(), e);</span>
    }
<span class="fc" id="L173">    return null;</span>
  }

  private static Set&lt;ChangedFile&gt; computeChangedFiles(Repository repository, List&lt;DiffEntry&gt; diffEntries) throws IOException {
<span class="fc" id="L177">    Path workingDirectory = repository.getWorkTree().toPath();</span>

<span class="fc" id="L179">    Map&lt;String, String&gt; renamedFilePaths = computeRenamedFilePaths(repository, diffEntries);</span>
<span class="fc" id="L180">    Set&lt;String&gt; changedFilePaths = computeChangedFilePaths(diffEntries);</span>

<span class="fc" id="L182">    return collectChangedFiles(workingDirectory, renamedFilePaths, changedFilePaths);</span>
  }

  private static Set&lt;ChangedFile&gt; collectChangedFiles(Path workingDirectory, Map&lt;String, String&gt; renamedFilePaths, Set&lt;String&gt; changedFilePaths) {
<span class="fc" id="L186">    Set&lt;ChangedFile&gt; changedFiles = new HashSet&lt;&gt;();</span>
<span class="fc" id="L187">    changedFilePaths.forEach(filePath -&gt; changedFiles.add(ChangedFile.of(workingDirectory.resolve(filePath), renamedFilePaths.get(filePath))));</span>
<span class="fc" id="L188">    return changedFiles;</span>
  }

  private static Map&lt;String, String&gt; computeRenamedFilePaths(Repository repository, List&lt;DiffEntry&gt; diffEntries) throws IOException {
<span class="fc" id="L192">    RenameDetector renameDetector = new RenameDetector(repository);</span>
<span class="fc" id="L193">    renameDetector.addAll(diffEntries);</span>

<span class="fc" id="L195">    return renameDetector</span>
<span class="fc" id="L196">      .compute()</span>
<span class="fc" id="L197">      .stream()</span>
<span class="fc" id="L198">      .filter(entry -&gt; RENAME.equals(entry.getChangeType()))</span>
<span class="fc" id="L199">      .collect(toUnmodifiableMap(DiffEntry::getNewPath, DiffEntry::getOldPath));</span>
  }

  private static Set&lt;String&gt; computeChangedFilePaths(List&lt;DiffEntry&gt; diffEntries) {
<span class="fc" id="L203">    return diffEntries</span>
<span class="fc" id="L204">      .stream()</span>
<span class="fc" id="L205">      .filter(isAllowedChangeType(ADD, MODIFY))</span>
<span class="fc" id="L206">      .map(DiffEntry::getNewPath)</span>
<span class="fc" id="L207">      .collect(toSet());</span>
  }

  private static Predicate&lt;DiffEntry&gt; isAllowedChangeType(ChangeType... changeTypes) {
<span class="fc" id="L211">    Function&lt;ChangeType, Predicate&lt;DiffEntry&gt;&gt; isChangeType = type -&gt; entry -&gt; type.equals(entry.getChangeType());</span>

<span class="fc" id="L213">    return Arrays</span>
<span class="fc" id="L214">      .stream(changeTypes)</span>
<span class="fc" id="L215">      .map(isChangeType)</span>
<span class="fc" id="L216">      .reduce(x -&gt; false, Predicate::or);</span>
  }

  @CheckForNull
  @Override
  public Map&lt;Path, Set&lt;Integer&gt;&gt; branchChangedLines(String targetBranchName, Path projectBaseDir, Set&lt;Path&gt; changedFiles) {
<span class="fc" id="L222">    return branchChangedLinesWithFileMovementDetection(targetBranchName, projectBaseDir, toChangedFileByPathsMap(changedFiles));</span>
  }

  @CheckForNull
  public Map&lt;Path, Set&lt;Integer&gt;&gt; branchChangedLinesWithFileMovementDetection(String targetBranchName, Path projectBaseDir, Map&lt;Path, ChangedFile&gt; changedFiles) {
<span class="fc" id="L227">    try (Repository repo = buildRepo(projectBaseDir)) {</span>
<span class="fc" id="L228">      Ref targetRef = resolveTargetRef(targetBranchName, repo);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">      if (targetRef == null) {</span>
<span class="fc" id="L230">        addWarningTargetNotFound(targetBranchName);</span>
<span class="fc" id="L231">        return null;</span>
      }

<span class="pc bpc" id="L234" title="1 of 2 branches missed.">      if (isDiffAlgoInvalid(repo.getConfig())) {</span>
        // we already print a warning when branchChangedFiles is called
<span class="nc" id="L236">        return null;</span>
      }

      // force ignore different line endings when comparing a commit with the workspace
<span class="fc" id="L240">      repo.getConfig().setBoolean(&quot;core&quot;, null, &quot;autocrlf&quot;, true);</span>

<span class="fc" id="L242">      Optional&lt;RevCommit&gt; mergeBaseCommit = findMergeBase(repo, targetRef);</span>

<span class="fc bfc" id="L244" title="All 2 branches covered.">      if (mergeBaseCommit.isEmpty()) {</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (LOG.isWarnEnabled()) {</span>
<span class="fc" id="L246">          LOG.warn(composeNoMergeBaseFoundWarning(targetRef.getName()));</span>
        }
<span class="fc" id="L248">        return null;</span>
      }

<span class="fc" id="L251">      Map&lt;Path, Set&lt;Integer&gt;&gt; changedLines = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L253" title="All 2 branches covered.">      for (Map.Entry&lt;Path, ChangedFile&gt; entry : changedFiles.entrySet()) {</span>
<span class="fc" id="L254">        collectChangedLines(repo, mergeBaseCommit.get(), changedLines, entry.getKey(), entry.getValue());</span>
<span class="fc" id="L255">      }</span>

<span class="fc" id="L257">      return changedLines;</span>
<span class="pc bpc" id="L258" title="4 of 6 branches missed.">    } catch (Exception e) {</span>
<span class="fc" id="L259">      LOG.warn(&quot;Failed to get changed lines from git&quot;, e);</span>
    }

<span class="fc" id="L262">    return null;</span>
  }

  private static String composeNoMergeBaseFoundWarning(String targetRef) {
<span class="fc" id="L266">    return format(NO_MERGE_BASE_FOUND_MESSAGE, targetRef);</span>
  }

  private void addWarningTargetNotFound(String targetBranchName) {
<span class="fc" id="L270">    String url = documentationLinkGenerator.getDocumentationLink(SCM_INTEGRATION_DOCUMENTATION_SUFFIX);</span>
<span class="fc" id="L271">    analysisWarnings.addUnique(format(COULD_NOT_FIND_REF</span>
      + &quot;. You may see unexpected issues and changes. &quot;
      + &quot;Please make sure to fetch this ref before pull request analysis and refer to&quot;
      + &quot; &lt;a href=\&quot;%s\&quot; rel=\&quot;noopener noreferrer\&quot; target=\&quot;_blank\&quot;&gt;the documentation&lt;/a&gt;.&quot;, targetBranchName, url));
<span class="fc" id="L275">  }</span>

  private void collectChangedLines(Repository repo, RevCommit mergeBaseCommit, Map&lt;Path, Set&lt;Integer&gt;&gt; changedLines, Path changedFilePath, ChangedFile changedFile) {
<span class="fc" id="L278">    ChangedLinesComputer computer = new ChangedLinesComputer();</span>

<span class="fc" id="L280">    try (DiffFormatter diffFmt = new DiffFormatter(new BufferedOutputStream(computer.receiver()))) {</span>
<span class="fc" id="L281">      diffFmt.setRepository(repo);</span>
<span class="fc" id="L282">      diffFmt.setProgressMonitor(NullProgressMonitor.INSTANCE);</span>
<span class="fc" id="L283">      diffFmt.setDiffComparator(RawTextComparator.WS_IGNORE_ALL);</span>

<span class="fc" id="L285">      diffFmt.setDetectRenames(changedFile.isMovedFile());</span>

<span class="fc" id="L287">      Path workTree = repo.getWorkTree().toPath();</span>
<span class="fc" id="L288">      TreeFilter treeFilter = getTreeFilter(changedFile, workTree);</span>
<span class="fc" id="L289">      diffFmt.setPathFilter(treeFilter);</span>

<span class="fc" id="L291">      AbstractTreeIterator mergeBaseTree = prepareTreeParser(repo, mergeBaseCommit);</span>
<span class="fc" id="L292">      List&lt;DiffEntry&gt; diffEntries = diffFmt.scan(mergeBaseTree, new FileTreeIterator(repo));</span>

<span class="fc" id="L294">      diffFmt.format(diffEntries);</span>
<span class="fc" id="L295">      diffFmt.flush();</span>

<span class="fc" id="L297">      diffEntries.stream()</span>
<span class="fc" id="L298">        .filter(isAllowedChangeType(ADD, MODIFY, RENAME))</span>
<span class="fc" id="L299">        .findAny()</span>
<span class="fc" id="L300">        .ifPresent(diffEntry -&gt; changedLines.put(changedFilePath, computer.changedLines()));</span>
<span class="fc" id="L301">    } catch (Exception e) {</span>
<span class="fc" id="L302">      LOG.warn(&quot;Failed to get changed lines from git for file &quot; + changedFilePath, e);</span>
<span class="fc" id="L303">    }</span>
<span class="fc" id="L304">  }</span>

  @Override
  @CheckForNull
  public Instant forkDate(String referenceBranchName, Path projectBaseDir) {
<span class="fc" id="L309">    return null;</span>
  }

  private static String toGitPath(String path) {
<span class="fc" id="L313">    return path.replaceAll(Pattern.quote(File.separator), &quot;/&quot;);</span>
  }

  private static TreeFilter getTreeFilter(ChangedFile changedFile, Path baseDir) {
<span class="fc" id="L317">    String path = toGitPath(relativizeFilePath(baseDir, changedFile.getAbsolutFilePath()));</span>
<span class="fc" id="L318">    String oldRelativePath = changedFile.getOldRelativeFilePathReference();</span>

<span class="fc bfc" id="L320" title="All 2 branches covered.">    if (oldRelativePath != null) {</span>
<span class="fc" id="L321">      return PathFilterGroup.createFromStrings(path, toGitPath(oldRelativePath));</span>
    }

<span class="fc" id="L324">    return PathFilter.create(path);</span>
  }

  private static Set&lt;Path&gt; extractAbsoluteFilePaths(Collection&lt;ChangedFile&gt; changedFiles) {
<span class="fc" id="L328">    return changedFiles</span>
<span class="fc" id="L329">      .stream()</span>
<span class="fc" id="L330">      .map(ChangedFile::getAbsolutFilePath)</span>
<span class="fc" id="L331">      .collect(toSet());</span>
  }

  @CheckForNull
  private Ref resolveTargetRef(String targetBranchName, Repository repo) throws IOException {
<span class="fc" id="L336">    String localRef = &quot;refs/heads/&quot; + targetBranchName;</span>
<span class="fc" id="L337">    String remotesRef = &quot;refs/remotes/&quot; + targetBranchName;</span>
<span class="fc" id="L338">    String originRef = &quot;refs/remotes/origin/&quot; + targetBranchName;</span>
<span class="fc" id="L339">    String upstreamRef = &quot;refs/remotes/upstream/&quot; + targetBranchName;</span>

    Ref targetRef;
    // Because circle ci destroys the local reference to master, try to load remote ref first.
    // https://discuss.circleci.com/t/git-checkout-of-a-branch-destroys-local-reference-to-master/23781
<span class="fc bfc" id="L344" title="All 2 branches covered.">    if (runningOnCircleCI()) {</span>
<span class="fc" id="L345">      targetRef = getFirstExistingRef(repo, originRef, localRef, upstreamRef, remotesRef);</span>
    } else {
<span class="fc" id="L347">      targetRef = getFirstExistingRef(repo, localRef, originRef, upstreamRef, remotesRef);</span>
    }

<span class="pc bpc" id="L350" title="1 of 4 branches missed.">    if (targetRef == null &amp;&amp; LOG.isWarnEnabled()) {</span>
<span class="fc" id="L351">      LOG.warn(String.format(COULD_NOT_FIND_REF, targetBranchName));</span>
    }

<span class="fc" id="L354">    return targetRef;</span>
  }

  @CheckForNull
  private static Ref getFirstExistingRef(Repository repo, String... refs) throws IOException {
<span class="fc" id="L359">    Ref targetRef = null;</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">    for (String ref : refs) {</span>
<span class="fc" id="L361">      targetRef = repo.exactRef(ref);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">      if (targetRef != null) {</span>
<span class="fc" id="L363">        break;</span>
      }
    }
<span class="fc" id="L366">    return targetRef;</span>
  }

  private boolean runningOnCircleCI() {
<span class="fc" id="L370">    return &quot;true&quot;.equals(system2.envVariable(&quot;CIRCLECI&quot;));</span>
  }

  @Override
  public Path relativePathFromScmRoot(Path path) {
<span class="fc" id="L375">    RepositoryBuilder builder = getVerifiedRepositoryBuilder(path);</span>
<span class="fc" id="L376">    return builder.getGitDir().toPath().getParent().relativize(path);</span>
  }

  @Override
  @CheckForNull
  public String revisionId(Path path) {
<span class="fc" id="L382">    RepositoryBuilder builder = getVerifiedRepositoryBuilder(path);</span>
    try {
<span class="fc" id="L384">      return Optional.ofNullable(getHead(builder.build()))</span>
<span class="fc" id="L385">        .map(Ref::getObjectId)</span>
<span class="fc" id="L386">        .map(ObjectId::getName)</span>
<span class="fc" id="L387">        .orElse(null);</span>
<span class="nc" id="L388">    } catch (IOException e) {</span>
<span class="nc" id="L389">      throw new IllegalStateException(&quot;I/O error while getting revision ID for path: &quot; + path, e);</span>
    }
  }

  private static boolean isDiffAlgoInvalid(Config cfg) {
    try {
<span class="fc" id="L395">      DiffAlgorithm.getAlgorithm(cfg.getEnum(</span>
        ConfigConstants.CONFIG_DIFF_SECTION, null,
        ConfigConstants.CONFIG_KEY_ALGORITHM,
        DiffAlgorithm.SupportedAlgorithm.HISTOGRAM));
<span class="fc" id="L399">      return false;</span>
<span class="nc" id="L400">    } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L401">      return true;</span>
    }
  }

  private static AbstractTreeIterator prepareNewTree(Repository repo) throws IOException {
<span class="fc" id="L406">    CanonicalTreeParser treeParser = new CanonicalTreeParser();</span>
<span class="fc" id="L407">    try (ObjectReader objectReader = repo.newObjectReader()) {</span>
<span class="fc" id="L408">      Ref head = getHead(repo);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">      if (head == null) {</span>
<span class="nc" id="L410">        throw new IOException(&quot;HEAD reference not found&quot;);</span>
      }
<span class="fc" id="L412">      treeParser.reset(objectReader, repo.parseCommit(head.getObjectId()).getTree());</span>
    }
<span class="fc" id="L414">    return treeParser;</span>
  }

  @CheckForNull
  private static Ref getHead(Repository repo) throws IOException {
<span class="fc" id="L419">    return repo.exactRef(&quot;HEAD&quot;);</span>
  }

  private static Optional&lt;RevCommit&gt; findMergeBase(Repository repo, Ref targetRef) throws IOException {
<span class="fc" id="L423">    try (RevWalk walk = new RevWalk(repo)) {</span>
<span class="fc" id="L424">      Ref head = getHead(repo);</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">      if (head == null) {</span>
<span class="nc" id="L426">        throw new IOException(&quot;HEAD reference not found&quot;);</span>
      }

<span class="fc" id="L429">      walk.markStart(walk.parseCommit(targetRef.getObjectId()));</span>
<span class="fc" id="L430">      walk.markStart(walk.parseCommit(head.getObjectId()));</span>
<span class="fc" id="L431">      walk.setRevFilter(RevFilter.MERGE_BASE);</span>
<span class="fc" id="L432">      RevCommit next = walk.next();</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">      if (next == null) {</span>
<span class="fc" id="L434">        return Optional.empty();</span>
      }
<span class="fc" id="L436">      RevCommit base = walk.parseCommit(next);</span>
<span class="fc" id="L437">      walk.dispose();</span>
<span class="fc" id="L438">      LOG.info(&quot;Merge base sha1: {}&quot;, base.getName());</span>
<span class="fc" id="L439">      return Optional.of(base);</span>
<span class="fc" id="L440">    }</span>
  }

  private static Map&lt;Path, ChangedFile&gt; toChangedFileByPathsMap(Set&lt;Path&gt; changedFiles) {
<span class="fc" id="L444">    return changedFiles</span>
<span class="fc" id="L445">      .stream()</span>
<span class="pc" id="L446">      .collect(toMap(identity(), ChangedFile::of, (x, y) -&gt; y, LinkedHashMap::new));</span>
  }

  private static String relativizeFilePath(Path baseDirectory, Path filePath) {
<span class="fc" id="L450">    return baseDirectory.relativize(filePath).toString();</span>
  }

  AbstractTreeIterator prepareTreeParser(Repository repo, RevCommit commit) throws IOException {
<span class="fc" id="L454">    CanonicalTreeParser treeParser = new CanonicalTreeParser();</span>
<span class="fc" id="L455">    try (ObjectReader objectReader = repo.newObjectReader()) {</span>
<span class="fc" id="L456">      treeParser.reset(objectReader, commit.getTree());</span>
    }
<span class="fc" id="L458">    return treeParser;</span>
  }

  Git newGit(Repository repo) {
<span class="fc" id="L462">    return new Git(repo);</span>
  }

  Repository buildRepo(Path basedir) throws IOException {
<span class="fc" id="L466">    return getVerifiedRepositoryBuilder(basedir).build();</span>
  }

  static RepositoryBuilder getVerifiedRepositoryBuilder(Path basedir) {
<span class="fc" id="L470">    RepositoryBuilder builder = new RepositoryBuilder()</span>
<span class="fc" id="L471">      .findGitDir(basedir.toFile())</span>
<span class="fc" id="L472">      .setMustExist(true);</span>

<span class="fc bfc" id="L474" title="All 2 branches covered.">    if (builder.getGitDir() == null) {</span>
<span class="fc" id="L475">      throw MessageException.of(&quot;Not inside a Git work tree: &quot; + basedir);</span>
    }
<span class="fc" id="L477">    return builder;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>