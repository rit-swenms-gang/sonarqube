<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UserRegistrarImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.authentication</a> &gt; <span class="el_source">UserRegistrarImpl.java</span></div><h1>UserRegistrarImpl.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.authentication;

import com.google.common.collect.Sets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.server.authentication.IdentityProvider;
import org.sonar.api.server.authentication.UserIdentity;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.user.GroupDto;
import org.sonar.db.user.UserDto;
import org.sonar.db.user.UserGroupDto;
import org.sonar.server.authentication.event.AuthenticationEvent.Source;
import org.sonar.server.authentication.event.AuthenticationException;
import org.sonar.server.management.ManagedInstanceService;
import org.sonar.server.user.ExternalIdentity;
import org.sonar.server.user.NewUser;
import org.sonar.server.user.UpdateUser;
import org.sonar.server.user.UserUpdater;
import org.sonar.server.usergroups.DefaultGroupFinder;

import static java.lang.String.format;
import static java.util.Collections.singletonList;
import static org.sonar.server.user.UserSession.IdentityProvider.SONARQUBE;

public class UserRegistrarImpl implements UserRegistrar {

  public static final String SQ_AUTHORITY = &quot;sonarqube&quot;;
  public static final String LDAP_PROVIDER_PREFIX = &quot;LDAP_&quot;;
<span class="fc" id="L62">  private static final Logger LOGGER = LoggerFactory.getLogger(UserRegistrarImpl.class);</span>
  public static final String GITHUB_PROVIDER = &quot;github&quot;;
  public static final String GITLAB_PROVIDER = &quot;gitlab&quot;;

  private final DbClient dbClient;
  private final UserUpdater userUpdater;
  private final DefaultGroupFinder defaultGroupFinder;
  private final ManagedInstanceService managedInstanceService;

  public UserRegistrarImpl(DbClient dbClient, UserUpdater userUpdater, DefaultGroupFinder defaultGroupFinder,
<span class="fc" id="L72">    ManagedInstanceService managedInstanceService) {</span>
<span class="fc" id="L73">    this.dbClient = dbClient;</span>
<span class="fc" id="L74">    this.userUpdater = userUpdater;</span>
<span class="fc" id="L75">    this.defaultGroupFinder = defaultGroupFinder;</span>
<span class="fc" id="L76">    this.managedInstanceService = managedInstanceService;</span>
<span class="fc" id="L77">  }</span>

  @Override
  public UserDto register(UserRegistration registration) {
<span class="fc" id="L81">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L82">      UserDto userDto = getUser(dbSession, registration.getUserIdentity(), registration.getProvider(), registration.getSource());</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">      if (userDto == null) {</span>
<span class="fc" id="L84">        return registerNewUser(dbSession, null, registration);</span>
      }
<span class="fc bfc" id="L86" title="All 2 branches covered.">      if (!userDto.isActive()) {</span>
<span class="fc" id="L87">        return registerNewUser(dbSession, userDto, registration);</span>
      }
<span class="fc" id="L89">      return updateExistingUser(dbSession, userDto, registration);</span>
<span class="pc bpc" id="L90" title="2 of 4 branches missed.">    }</span>
  }

  @CheckForNull
  private UserDto getUser(DbSession dbSession, UserIdentity userIdentity, IdentityProvider provider, Source source) {
    // First, try to authenticate using the external ID
    // Then, try with the external login, for instance when external ID has changed or is not used by the provider
<span class="fc" id="L97">    return retrieveUserByExternalIdAndIdentityProvider(dbSession, userIdentity, provider)</span>
<span class="fc" id="L98">      .or(() -&gt; retrieveUserByExternalLoginAndIdentityProvider(dbSession, userIdentity, provider, source))</span>
<span class="fc" id="L99">      .or(() -&gt; retrieveUserByLogin(dbSession, userIdentity, provider))</span>
<span class="fc" id="L100">      .orElse(null);</span>
  }

  private Optional&lt;UserDto&gt; retrieveUserByExternalIdAndIdentityProvider(DbSession dbSession, UserIdentity userIdentity, IdentityProvider provider) {
<span class="fc" id="L104">    return Optional.ofNullable(dbClient.userDao().selectByExternalIdAndIdentityProvider(dbSession, getProviderIdOrProviderLogin(userIdentity), provider.getKey()));</span>
  }

  private Optional&lt;UserDto&gt; retrieveUserByExternalLoginAndIdentityProvider(DbSession dbSession, UserIdentity userIdentity, IdentityProvider provider, Source source) {
<span class="fc" id="L108">    return Optional.ofNullable(dbClient.userDao().selectByExternalLoginAndIdentityProvider(dbSession, userIdentity.getProviderLogin(), provider.getKey()))</span>
<span class="fc" id="L109">      .filter(user -&gt; validateAlmSpecificData(user, provider.getKey(), userIdentity, source));</span>
  }

  private Optional&lt;UserDto&gt; retrieveUserByLogin(DbSession dbSession, UserIdentity userIdentity, IdentityProvider provider) {
<span class="fc" id="L113">    return Optional.ofNullable(dbClient.userDao().selectByLogin(dbSession, userIdentity.getProviderLogin()))</span>
<span class="fc" id="L114">      .filter(user -&gt; shouldPerformLdapIdentityProviderMigration(user, provider));</span>
  }

  private static boolean shouldPerformLdapIdentityProviderMigration(UserDto user, IdentityProvider identityProvider) {
<span class="fc" id="L118">    boolean isLdapIdentityProvider = identityProvider.getKey().startsWith(LDAP_PROVIDER_PREFIX);</span>
<span class="fc" id="L119">    boolean hasSonarQubeExternalIdentityProvider = SONARQUBE.getKey().equals(user.getExternalIdentityProvider());</span>

<span class="fc bfc" id="L121" title="All 6 branches covered.">    return isLdapIdentityProvider &amp;&amp; hasSonarQubeExternalIdentityProvider &amp;&amp; !user.isLocal();</span>
  }

  private static boolean validateAlmSpecificData(UserDto user, String key, UserIdentity userIdentity, Source source) {
    // All gitlab users have an external ID, so the other two authentication methods should never be used
<span class="fc bfc" id="L126" title="All 2 branches covered.">    if (GITLAB_PROVIDER.equals(key)) {</span>
<span class="fc" id="L127">      throw failAuthenticationException(userIdentity, source);</span>
    }

<span class="fc bfc" id="L130" title="All 2 branches covered.">    if (GITHUB_PROVIDER.equals(key)) {</span>
<span class="fc" id="L131">      validateEmailToAvoidLoginRecycling(userIdentity, user, source);</span>
    }

<span class="fc" id="L134">    return true;</span>
  }

  private static void validateEmailToAvoidLoginRecycling(UserIdentity userIdentity, UserDto user, Source source) {
<span class="fc" id="L138">    String dbEmail = user.getEmail();</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">    if (dbEmail == null) {</span>
<span class="fc" id="L141">      return;</span>
    }

<span class="fc" id="L144">    String externalEmail = userIdentity.getEmail();</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">    if (!dbEmail.equalsIgnoreCase(externalEmail)) {</span>
<span class="fc" id="L147">      LOGGER.warn(&quot;User with login '{}' tried to login with email '{}' which doesn't match the email on record '{}'&quot;, userIdentity.getProviderLogin(), externalEmail, dbEmail);</span>
<span class="fc" id="L148">      throw failAuthenticationException(userIdentity, source);</span>
    }
<span class="fc" id="L150">  }</span>

  private static AuthenticationException failAuthenticationException(UserIdentity userIdentity, Source source) {
<span class="fc" id="L153">    String message = String.format(&quot;Failed to authenticate with login '%s'&quot;, userIdentity.getProviderLogin());</span>
<span class="fc" id="L154">    return authException(userIdentity, source, message, message);</span>
  }

  private static AuthenticationException authException(UserIdentity userIdentity, Source source, String message, String publicMessage) {
<span class="fc" id="L158">    return AuthenticationException.newBuilder()</span>
<span class="fc" id="L159">      .setSource(source)</span>
<span class="fc" id="L160">      .setLogin(userIdentity.getProviderLogin())</span>
<span class="fc" id="L161">      .setMessage(message)</span>
<span class="fc" id="L162">      .setPublicMessage(publicMessage)</span>
<span class="fc" id="L163">      .build();</span>
  }

  private UserDto registerNewUser(DbSession dbSession, @Nullable UserDto disabledUser, UserRegistration authenticatorParameters) {
<span class="fc" id="L167">    blockUnmanagedUserCreationOnManagedInstance(authenticatorParameters);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">    Optional&lt;UserDto&gt; otherUserToIndex = detectEmailUpdate(dbSession, authenticatorParameters, disabledUser != null ? disabledUser.getUuid() : null);</span>
<span class="fc" id="L169">    NewUser newUser = createNewUser(authenticatorParameters);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">    if (disabledUser == null) {</span>
<span class="fc" id="L171">      return userUpdater.createAndCommit(dbSession, newUser, beforeCommit(dbSession, authenticatorParameters), toArray(otherUserToIndex));</span>
    }
<span class="fc" id="L173">    return userUpdater.reactivateAndCommit(dbSession, disabledUser, newUser, beforeCommit(dbSession, authenticatorParameters), toArray(otherUserToIndex));</span>
  }

  private void blockUnmanagedUserCreationOnManagedInstance(UserRegistration userRegistration) {
<span class="fc bfc" id="L177" title="All 4 branches covered.">    if (managedInstanceService.isInstanceExternallyManaged() &amp;&amp; !userRegistration.managed()) {</span>
<span class="fc" id="L178">      throw AuthenticationException.newBuilder()</span>
<span class="fc" id="L179">        .setMessage(&quot;No account found for this user. As the instance is managed, make sure to provision the user from your IDP.&quot;)</span>
<span class="fc" id="L180">        .setPublicMessage(&quot;You have no account on SonarQube. Please make sure with your administrator that your account is provisioned.&quot;)</span>
<span class="fc" id="L181">        .setLogin(userRegistration.getUserIdentity().getProviderLogin())</span>
<span class="fc" id="L182">        .setSource(userRegistration.getSource())</span>
<span class="fc" id="L183">        .build();</span>
    }
<span class="fc" id="L185">  }</span>

  private UserDto updateExistingUser(DbSession dbSession, UserDto userDto, UserRegistration authenticatorParameters) {
<span class="fc" id="L188">    UpdateUser update = new UpdateUser()</span>
<span class="fc" id="L189">      .setEmail(authenticatorParameters.getUserIdentity().getEmail())</span>
<span class="fc" id="L190">      .setName(authenticatorParameters.getUserIdentity().getName())</span>
<span class="fc" id="L191">      .setExternalIdentityProvider(authenticatorParameters.getProvider().getKey())</span>
<span class="fc" id="L192">      .setExternalIdentityProviderId(authenticatorParameters.getUserIdentity().getProviderId())</span>
<span class="fc" id="L193">      .setExternalIdentityProviderLogin(authenticatorParameters.getUserIdentity().getProviderLogin());</span>
<span class="fc" id="L194">    Optional&lt;UserDto&gt; otherUserToIndex = detectEmailUpdate(dbSession, authenticatorParameters, userDto.getUuid());</span>
<span class="fc" id="L195">    userUpdater.updateAndCommit(dbSession, userDto, update, beforeCommit(dbSession, authenticatorParameters), toArray(otherUserToIndex));</span>
<span class="fc" id="L196">    return userDto;</span>
  }

  private Consumer&lt;UserDto&gt; beforeCommit(DbSession dbSession, UserRegistration authenticatorParameters) {
<span class="fc" id="L200">    return user -&gt; syncGroups(dbSession, authenticatorParameters.getUserIdentity(), user);</span>
  }

  private Optional&lt;UserDto&gt; detectEmailUpdate(DbSession dbSession, UserRegistration authenticatorParameters, @Nullable String authenticatingUserUuid) {
<span class="fc" id="L204">    String email = authenticatorParameters.getUserIdentity().getEmail();</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">    if (email == null) {</span>
<span class="fc" id="L206">      return Optional.empty();</span>
    }
<span class="fc" id="L208">    List&lt;UserDto&gt; existingUsers = dbClient.userDao().selectByEmail(dbSession, email);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">    if (existingUsers.isEmpty()) {</span>
<span class="fc" id="L210">      return Optional.empty();</span>
    }
<span class="fc bfc" id="L212" title="All 2 branches covered.">    if (existingUsers.size() &gt; 1) {</span>
<span class="fc" id="L213">      throw generateExistingEmailError(authenticatorParameters, email);</span>
    }

<span class="fc" id="L216">    UserDto existingUser = existingUsers.get(0);</span>
<span class="pc bpc" id="L217" title="1 of 4 branches missed.">    if (existingUser == null || existingUser.getUuid().equals(authenticatingUserUuid)) {</span>
<span class="fc" id="L218">      return Optional.empty();</span>
    }
<span class="fc" id="L220">    throw generateExistingEmailError(authenticatorParameters, email);</span>
  }

  private void syncGroups(DbSession dbSession, UserIdentity userIdentity, UserDto userDto) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">    if (!userIdentity.shouldSyncGroups()) {</span>
<span class="fc" id="L225">      return;</span>
    }
<span class="fc" id="L227">    String userLogin = userDto.getLogin();</span>
<span class="fc" id="L228">    Set&lt;String&gt; userGroups = new HashSet&lt;&gt;(dbClient.groupMembershipDao().selectGroupsByLogins(dbSession, singletonList(userLogin)).get(userLogin));</span>
<span class="fc" id="L229">    Set&lt;String&gt; identityGroups = userIdentity.getGroups();</span>
<span class="fc" id="L230">    LOGGER.debug(&quot;List of groups returned by the identity provider '{}'&quot;, identityGroups);</span>

<span class="fc" id="L232">    Collection&lt;String&gt; groupsToAdd = Sets.difference(identityGroups, userGroups);</span>
<span class="fc" id="L233">    Collection&lt;String&gt; groupsToRemove = Sets.difference(userGroups, identityGroups);</span>
<span class="fc" id="L234">    Collection&lt;String&gt; allGroups = new ArrayList&lt;&gt;(groupsToAdd);</span>
<span class="fc" id="L235">    allGroups.addAll(groupsToRemove);</span>
<span class="fc" id="L236">    Map&lt;String, GroupDto&gt; groupsByName = dbClient.groupDao().selectByNames(dbSession, allGroups)</span>
<span class="fc" id="L237">      .stream()</span>
<span class="fc" id="L238">      .collect(Collectors.toMap(GroupDto::getName, Function.identity()));</span>

<span class="fc" id="L240">    addGroups(dbSession, userDto, groupsToAdd, groupsByName);</span>
<span class="fc" id="L241">    removeGroups(dbSession, userDto, groupsToRemove, groupsByName);</span>
<span class="fc" id="L242">  }</span>

  private void addGroups(DbSession dbSession, UserDto userDto, Collection&lt;String&gt; groupsToAdd, Map&lt;String, GroupDto&gt; groupsByName) {
<span class="fc" id="L245">    groupsToAdd.stream().map(groupsByName::get).filter(Objects::nonNull).forEach(</span>
      groupDto -&gt; {
<span class="fc" id="L247">        LOGGER.debug(&quot;Adding user '{}' to group '{}'&quot;, userDto.getLogin(), groupDto.getName());</span>
<span class="fc" id="L248">        dbClient.userGroupDao().insert(dbSession, new UserGroupDto().setGroupUuid(groupDto.getUuid()).setUserUuid(userDto.getUuid()),</span>
<span class="fc" id="L249">          groupDto.getName(), userDto.getLogin());</span>
<span class="fc" id="L250">      });</span>
<span class="fc" id="L251">  }</span>

  private void removeGroups(DbSession dbSession, UserDto userDto, Collection&lt;String&gt; groupsToRemove, Map&lt;String, GroupDto&gt; groupsByName) {
<span class="fc" id="L254">    Optional&lt;GroupDto&gt; defaultGroup = getDefaultGroup(dbSession);</span>
<span class="fc" id="L255">    groupsToRemove.stream().map(groupsByName::get)</span>
<span class="fc" id="L256">      .filter(Objects::nonNull)</span>
      // user should be member of default group only when organizations are disabled, as the IdentityProvider API doesn't handle yet
      // organizations
<span class="pc bpc" id="L259" title="1 of 4 branches missed.">      .filter(group -&gt; defaultGroup.isEmpty() || !group.getUuid().equals(defaultGroup.get().getUuid()))</span>
<span class="fc" id="L260">      .forEach(groupDto -&gt; {</span>
<span class="fc" id="L261">        LOGGER.debug(&quot;Removing group '{}' from user '{}'&quot;, groupDto.getName(), userDto.getLogin());</span>
<span class="fc" id="L262">        dbClient.userGroupDao().delete(dbSession, groupDto, userDto);</span>
<span class="fc" id="L263">      });</span>
<span class="fc" id="L264">  }</span>

  private Optional&lt;GroupDto&gt; getDefaultGroup(DbSession dbSession) {
<span class="fc" id="L267">    return Optional.of(defaultGroupFinder.findDefaultGroup(dbSession));</span>
  }

  private NewUser createNewUser(UserRegistration authenticatorParameters) {
<span class="fc" id="L271">    String identityProviderKey = authenticatorParameters.getProvider().getKey();</span>
<span class="fc bfc" id="L272" title="All 4 branches covered.">    if (!managedInstanceService.isInstanceExternallyManaged() &amp;&amp; !authenticatorParameters.getProvider().allowsUsersToSignUp()) {</span>
<span class="fc" id="L273">      throw AuthenticationException.newBuilder()</span>
<span class="fc" id="L274">        .setSource(authenticatorParameters.getSource())</span>
<span class="fc" id="L275">        .setLogin(authenticatorParameters.getUserIdentity().getProviderLogin())</span>
<span class="fc" id="L276">        .setMessage(format(&quot;User signup disabled for provider '%s'&quot;, identityProviderKey))</span>
<span class="fc" id="L277">        .setPublicMessage(format(&quot;'%s' users are not allowed to sign up&quot;, identityProviderKey))</span>
<span class="fc" id="L278">        .build();</span>
    }
<span class="fc" id="L280">    String providerLogin = authenticatorParameters.getUserIdentity().getProviderLogin();</span>
<span class="fc" id="L281">    return NewUser.builder()</span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">      .setLogin(SQ_AUTHORITY.equals(identityProviderKey) ? providerLogin : null)</span>
<span class="fc" id="L283">      .setEmail(authenticatorParameters.getUserIdentity().getEmail())</span>
<span class="fc" id="L284">      .setName(authenticatorParameters.getUserIdentity().getName())</span>
<span class="fc" id="L285">      .setExternalIdentity(</span>
        new ExternalIdentity(
          identityProviderKey,
          providerLogin,
<span class="fc" id="L289">          authenticatorParameters.getUserIdentity().getProviderId()))</span>
<span class="fc" id="L290">      .build();</span>
  }

  private static UserDto[] toArray(Optional&lt;UserDto&gt; userDto) {
<span class="pc" id="L294">    return userDto.map(u -&gt; new UserDto[]{u}).orElse(new UserDto[]{});</span>
  }

  private static AuthenticationException generateExistingEmailError(UserRegistration authenticatorParameters, String email) {
<span class="fc" id="L298">    return AuthenticationException.newBuilder()</span>
<span class="fc" id="L299">      .setSource(authenticatorParameters.getSource())</span>
<span class="fc" id="L300">      .setLogin(authenticatorParameters.getUserIdentity().getProviderLogin())</span>
<span class="fc" id="L301">      .setMessage(format(&quot;Email '%s' is already used&quot;, email))</span>
<span class="fc" id="L302">      .setPublicMessage(</span>
        &quot;This account is already associated with another authentication method. &quot;
          + &quot;Sign in using the current authentication method, &quot;
          + &quot;or contact your administrator to transfer your account to a different authentication method.&quot;)
<span class="fc" id="L306">      .build();</span>
  }

  private static String getProviderIdOrProviderLogin(UserIdentity userIdentity) {
<span class="fc" id="L310">    String providerId = userIdentity.getProviderId();</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">    return providerId == null ? userIdentity.getProviderLogin() : providerId;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>