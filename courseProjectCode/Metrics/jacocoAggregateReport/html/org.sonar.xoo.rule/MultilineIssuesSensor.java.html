<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MultilineIssuesSensor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.xoo.rule</a> &gt; <span class="el_source">MultilineIssuesSensor.java</span></div><h1>MultilineIssuesSensor.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.xoo.rule;

import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.api.batch.fs.FilePredicates;
import org.sonar.api.batch.fs.FileSystem;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.fs.InputFile.Type;
import org.sonar.api.batch.fs.TextPointer;
import org.sonar.api.batch.sensor.Sensor;
import org.sonar.api.batch.sensor.SensorContext;
import org.sonar.api.batch.sensor.SensorDescriptor;
import org.sonar.api.batch.sensor.issue.MessageFormatting;
import org.sonar.api.batch.sensor.issue.NewIssue;
import org.sonar.api.batch.sensor.issue.NewIssue.FlowType;
import org.sonar.api.batch.sensor.issue.NewIssueLocation;
import org.sonar.api.batch.sensor.issue.NewMessageFormatting;
import org.sonar.api.rule.RuleKey;
import org.sonar.xoo.Xoo;

import static org.sonar.api.batch.sensor.issue.NewIssue.FlowType.DATA;
import static org.sonar.api.batch.sensor.issue.NewIssue.FlowType.EXECUTION;
import static org.sonar.api.utils.Preconditions.checkState;

<span class="fc" id="L55">public class MultilineIssuesSensor implements Sensor {</span>

  public static final String RULE_KEY = &quot;MultilineIssue&quot;;

<span class="fc" id="L59">  private static final Pattern START_ISSUE_PATTERN = Pattern.compile(&quot;\\{xoo-start-issue:([0-9]+)\\}&quot;);</span>
<span class="fc" id="L60">  private static final Pattern END_ISSUE_PATTERN = Pattern.compile(&quot;\\{xoo-end-issue:([0-9]+)\\}&quot;);</span>

<span class="fc" id="L62">  private static final Pattern START_FLOW_PATTERN = Pattern.compile(&quot;\\{xoo-start-flow:([0-9]+):([0-9]+):([0-9]+)\\}&quot;);</span>
<span class="fc" id="L63">  private static final Pattern END_FLOW_PATTERN = Pattern.compile(&quot;\\{xoo-end-flow:([0-9]+):([0-9]+):([0-9]+)\\}&quot;);</span>

<span class="fc" id="L65">  private static final Pattern START_DATA_FLOW_PATTERN = Pattern.compile(&quot;\\{xoo-start-data-flow:([0-9]+):([0-9]+):([0-9]+)\\}&quot;);</span>
<span class="fc" id="L66">  private static final Pattern END_DATA_FLOW_PATTERN = Pattern.compile(&quot;\\{xoo-end-data-flow:([0-9]+):([0-9]+):([0-9]+)\\}&quot;);</span>

<span class="fc" id="L68">  private static final Pattern START_EXECUTION_FLOW_PATTERN = Pattern.compile(&quot;\\{xoo-start-execution-flow:([0-9]+):([0-9]+):([0-9]+)\\}&quot;);</span>
<span class="fc" id="L69">  private static final Pattern END_EXECUTION_FLOW_PATTERN = Pattern.compile(&quot;\\{xoo-end-execution-flow:([0-9]+):([0-9]+):([0-9]+)\\}&quot;);</span>

  @Override
  public void describe(SensorDescriptor descriptor) {
<span class="fc" id="L73">    descriptor.name(&quot;Multiline Issues&quot;).onlyOnLanguages(Xoo.KEY).createIssuesForRuleRepositories(XooRulesDefinition.XOO_REPOSITORY);</span>
<span class="fc" id="L74">  }</span>

  @Override
  public void execute(SensorContext context) {
<span class="fc" id="L78">    FileSystem fs = context.fileSystem();</span>
<span class="fc" id="L79">    FilePredicates p = fs.predicates();</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">    for (InputFile file : fs.inputFiles(p.and(p.hasLanguages(Xoo.KEY), p.hasType(Type.MAIN)))) {</span>
<span class="fc" id="L81">      createIssues(file, context);</span>
<span class="fc" id="L82">    }</span>
<span class="fc" id="L83">  }</span>

  public String getRuleKey() {
<span class="fc" id="L86">    return RULE_KEY;</span>
  }

  private void createIssues(InputFile file, SensorContext context) {
<span class="fc" id="L90">    Collection&lt;ParsedIssue&gt; issues = parseIssues(file);</span>
<span class="fc" id="L91">    FlowIndex flowIndex = new FlowIndex();</span>
<span class="fc" id="L92">    parseFlows(flowIndex, file, START_FLOW_PATTERN, END_FLOW_PATTERN, null);</span>
<span class="fc" id="L93">    parseFlows(flowIndex, file, START_DATA_FLOW_PATTERN, END_DATA_FLOW_PATTERN, DATA);</span>
<span class="fc" id="L94">    parseFlows(flowIndex, file, START_EXECUTION_FLOW_PATTERN, END_EXECUTION_FLOW_PATTERN, EXECUTION);</span>
<span class="fc" id="L95">    createIssues(file, context, issues, flowIndex);</span>
<span class="fc" id="L96">  }</span>

  private void createIssues(InputFile file, SensorContext context, Collection&lt;ParsedIssue&gt; parsedIssues, FlowIndex flowIndex) {
<span class="fc" id="L99">    RuleKey ruleKey = RuleKey.of(XooRulesDefinition.XOO_REPOSITORY, getRuleKey());</span>

<span class="fc bfc" id="L101" title="All 2 branches covered.">    for (ParsedIssue parsedIssue : parsedIssues) {</span>
<span class="fc" id="L102">      NewIssue newIssue = context.newIssue().forRule(ruleKey);</span>
<span class="fc" id="L103">      NewIssueLocation primaryLocation = newIssue.newLocation();</span>
<span class="fc" id="L104">      String message = &quot;Primary location of the issue in xoo code&quot;;</span>
<span class="fc" id="L105">      List&lt;NewMessageFormatting&gt; newMessageFormattings = formatIssueMessage(message, primaryLocation.newMessageFormatting());</span>
<span class="fc" id="L106">      newIssue.at(primaryLocation.on(file)</span>
<span class="fc" id="L107">        .at(file.newRange(parsedIssue.start, parsedIssue.end))</span>
<span class="fc" id="L108">        .message(message, newMessageFormattings));</span>

<span class="fc bfc" id="L110" title="All 2 branches covered.">      for (ParsedFlow flow : flowIndex.getFlows(parsedIssue.issueId)) {</span>
<span class="fc" id="L111">        List&lt;NewIssueLocation&gt; flowLocations = new LinkedList&lt;&gt;();</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (ParsedFlowLocation flowLocation : flow.getLocations()) {</span>
<span class="fc" id="L114">          String locationMessage = &quot;Xoo code, flow step #&quot; + flowLocation.flowLocationId;</span>
<span class="fc" id="L115">          NewIssueLocation newIssueLocation = newIssue.newLocation();</span>
<span class="fc" id="L116">          List&lt;NewMessageFormatting&gt; locationMessageFormattings = formatIssueMessage(locationMessage, newIssueLocation.newMessageFormatting());</span>
<span class="fc" id="L117">          newIssueLocation</span>
<span class="fc" id="L118">            .on(file)</span>
<span class="fc" id="L119">            .at(file.newRange(flowLocation.start, flowLocation.end))</span>
<span class="fc" id="L120">            .message(locationMessage, locationMessageFormattings);</span>
<span class="fc" id="L121">          flowLocations.add(newIssueLocation);</span>
<span class="fc" id="L122">        }</span>

<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (flow.getType() != null) {</span>
<span class="fc" id="L125">          newIssue.addFlow(flowLocations, flow.getType(), &quot;flow #&quot; + flow.getFlowId());</span>
        } else {
<span class="fc" id="L127">          newIssue.addFlow(flowLocations);</span>
        }
<span class="fc" id="L129">      }</span>
<span class="fc" id="L130">      newIssue.save();</span>
<span class="fc" id="L131">    }</span>
<span class="fc" id="L132">  }</span>

  private static List&lt;NewMessageFormatting&gt; formatIssueMessage(String message, NewMessageFormatting newMessageFormatting) {
<span class="fc" id="L135">    int startIndex = message.toLowerCase().indexOf(&quot;xoo&quot;);</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">    if(startIndex == -1) {</span>
<span class="nc" id="L137">      return List.of();</span>
    }
<span class="fc" id="L139">    int endIndex = startIndex + &quot;xoo&quot;.length();</span>
<span class="fc" id="L140">    return List.of(newMessageFormatting.start(startIndex).end(endIndex).type(MessageFormatting.Type.CODE));</span>
  }

  private static Collection&lt;ParsedIssue&gt; parseIssues(InputFile file) {
<span class="fc" id="L144">    Map&lt;Integer, ParsedIssue&gt; issuesById = new HashMap&lt;&gt;();</span>

<span class="fc" id="L146">    int currentLine = 0;</span>
    try {
<span class="fc bfc" id="L148" title="All 2 branches covered.">      for (String lineStr : file.contents().split(&quot;\\r?\\n&quot;)) {</span>
<span class="fc" id="L149">        currentLine++;</span>

<span class="fc" id="L151">        Matcher m = START_ISSUE_PATTERN.matcher(lineStr);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        while (m.find()) {</span>
<span class="fc" id="L153">          Integer issueId = Integer.parseInt(m.group(1));</span>
<span class="fc" id="L154">          issuesById.computeIfAbsent(issueId, ParsedIssue::new).start = file.newPointer(currentLine, m.end());</span>
<span class="fc" id="L155">        }</span>

<span class="fc" id="L157">        m = END_ISSUE_PATTERN.matcher(lineStr);</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        while (m.find()) {</span>
<span class="fc" id="L159">          Integer issueId = Integer.parseInt(m.group(1));</span>
<span class="fc" id="L160">          issuesById.computeIfAbsent(issueId, ParsedIssue::new).end = file.newPointer(currentLine, m.start());</span>
<span class="fc" id="L161">        }</span>
      }
<span class="nc" id="L163">    } catch (IOException e) {</span>
<span class="nc" id="L164">      throw new IllegalStateException(&quot;Unable to read file&quot;, e);</span>
<span class="fc" id="L165">    }</span>
<span class="fc" id="L166">    return issuesById.values();</span>
  }

  private void parseFlows(FlowIndex flowIndex, InputFile file, Pattern flowStartPattern, Pattern flowEndPattern, @Nullable FlowType flowType) {
<span class="fc" id="L170">    int currentLine = 0;</span>
    try {
<span class="fc bfc" id="L172" title="All 2 branches covered.">      for (String lineStr : file.contents().split(&quot;\\r?\\n&quot;)) {</span>
<span class="fc" id="L173">        currentLine++;</span>

<span class="fc" id="L175">        Matcher m = flowStartPattern.matcher(lineStr);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        while (m.find()) {</span>
<span class="fc" id="L177">          ParsedFlowLocation flowLocation = new ParsedFlowLocation(Integer.parseInt(m.group(1)), Integer.parseInt(m.group(2)), Integer.parseInt(m.group(3)));</span>
<span class="fc" id="L178">          flowLocation.start = file.newPointer(currentLine, m.end());</span>
<span class="fc" id="L179">          flowIndex.addLocation(flowLocation, flowType);</span>
<span class="fc" id="L180">        }</span>

<span class="fc" id="L182">        m = flowEndPattern.matcher(lineStr);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">        while (m.find()) {</span>
<span class="fc" id="L184">          ParsedFlowLocation flowLocation = new ParsedFlowLocation(Integer.parseInt(m.group(1)), Integer.parseInt(m.group(2)), Integer.parseInt(m.group(3)));</span>
<span class="fc" id="L185">          flowLocation.end = file.newPointer(currentLine, m.start());</span>
<span class="fc" id="L186">          flowIndex.addLocation(flowLocation, flowType);</span>
<span class="fc" id="L187">        }</span>
      }
<span class="nc" id="L189">    } catch (IOException e) {</span>
<span class="nc" id="L190">      throw new IllegalStateException(&quot;Unable to read file&quot;, e);</span>
<span class="fc" id="L191">    }</span>
<span class="fc" id="L192">  }</span>

  private static class ParsedIssue {
    private final int issueId;

    private TextPointer start;
    private TextPointer end;

<span class="fc" id="L200">    private ParsedIssue(int issueId) {</span>
<span class="fc" id="L201">      this.issueId = issueId;</span>
<span class="fc" id="L202">    }</span>
  }

<span class="fc" id="L205">  private static class FlowIndex {</span>
<span class="fc" id="L206">    private final Map&lt;Integer, IssueFlows&gt; flowsByIssueId = new HashMap&lt;&gt;();</span>

    public void addLocation(ParsedFlowLocation flowLocation, @Nullable FlowType type) {
<span class="fc" id="L209">      flowsByIssueId.computeIfAbsent(flowLocation.issueId, issueId -&gt; new IssueFlows()).addLocation(flowLocation, type);</span>
<span class="fc" id="L210">    }</span>

    public Collection&lt;ParsedFlow&gt; getFlows(int issueId) {
<span class="fc" id="L213">      return Optional.ofNullable(flowsByIssueId.get(issueId)).map(IssueFlows::getFlows).orElse(Collections.emptyList());</span>
    }
  }

<span class="fc" id="L217">  private static class IssueFlows {</span>
<span class="fc" id="L218">    private final Map&lt;Integer, ParsedFlow&gt; flowById = new TreeMap&lt;&gt;();</span>

    private void addLocation(ParsedFlowLocation flowLocation, @Nullable FlowType type) {
<span class="fc" id="L221">      flowById.computeIfAbsent(flowLocation.flowId, flowId -&gt; new ParsedFlow(flowId, type)).addLocation(flowLocation);</span>
<span class="fc" id="L222">    }</span>

    Collection&lt;ParsedFlow&gt; getFlows() {
<span class="fc" id="L225">      return flowById.values();</span>
    }
  }

  private static class ParsedFlow {
    private final int id;
    private final FlowType type;
<span class="fc" id="L232">    private final Map&lt;Integer, ParsedFlowLocation&gt; locationsById = new TreeMap&lt;&gt;();</span>
    private String description;

<span class="fc" id="L235">    private ParsedFlow(int id, @Nullable FlowType type) {</span>
<span class="fc" id="L236">      this.id = id;</span>
<span class="fc" id="L237">      this.type = type;</span>
<span class="fc" id="L238">    }</span>

    private void addLocation(ParsedFlowLocation flowLocation) {
<span class="fc bfc" id="L241" title="All 2 branches covered.">      if (locationsById.containsKey(flowLocation.flowLocationId)) {</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        checkState(flowLocation.end != null, &quot;Existing flow should be the end&quot;);</span>
<span class="fc" id="L243">        locationsById.get(flowLocation.flowLocationId).end = flowLocation.end;</span>
      } else {
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        checkState(flowLocation.start != null, &quot;New flow should be the start&quot;);</span>
<span class="fc" id="L246">        locationsById.put(flowLocation.flowLocationId, flowLocation);</span>
      }
<span class="fc" id="L248">    }</span>

    public Collection&lt;ParsedFlowLocation&gt; getLocations() {
<span class="fc" id="L251">      return locationsById.values();</span>

    }

    public void setDescription(@Nullable String description) {
<span class="nc" id="L256">      this.description = description;</span>
<span class="nc" id="L257">    }</span>

    @CheckForNull
    public String getDescription() {
<span class="nc" id="L261">      return description;</span>
    }

    @CheckForNull
    FlowType getType() {
<span class="fc" id="L266">      return type;</span>
    }

    int getFlowId() {
<span class="fc" id="L270">      return id;</span>
    }
  }

  private static class ParsedFlowLocation {
    private final int issueId;
    private final int flowId;
    private final int flowLocationId;

    private TextPointer start;
    private TextPointer end;

<span class="fc" id="L282">    public ParsedFlowLocation(int issueId, int flowId, int flowLocationId) {</span>
<span class="fc" id="L283">      this.issueId = issueId;</span>
<span class="fc" id="L284">      this.flowId = flowId;</span>
<span class="fc" id="L285">      this.flowLocationId = flowLocationId;</span>
<span class="fc" id="L286">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>