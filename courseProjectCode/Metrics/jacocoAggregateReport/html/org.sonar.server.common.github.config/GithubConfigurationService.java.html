<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GithubConfigurationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.common.github.config</a> &gt; <span class="el_source">GithubConfigurationService.java</span></div><h1>GithubConfigurationService.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.common.github.config;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.apache.commons.lang.StringUtils;
import org.sonar.alm.client.github.GithubGlobalSettingsValidator;
import org.sonar.api.server.ServerSide;
import org.sonar.auth.github.GitHubIdentityProvider;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.property.PropertyDto;
import org.sonar.server.common.UpdatedValue;
import org.sonar.server.common.gitlab.config.ProvisioningType;
import org.sonar.server.exceptions.BadRequestException;
import org.sonar.server.exceptions.NotFoundException;
import org.sonar.server.management.ManagedInstanceService;
import org.sonar.server.setting.ThreadLocalSettings;

import static java.lang.String.format;
import static org.sonar.api.utils.Preconditions.checkState;
import static org.sonar.auth.github.GitHubSettings.GITHUB_ALLOW_USERS_TO_SIGN_UP;
import static org.sonar.auth.github.GitHubSettings.GITHUB_API_URL;
import static org.sonar.auth.github.GitHubSettings.GITHUB_APP_ID;
import static org.sonar.auth.github.GitHubSettings.GITHUB_CLIENT_ID;
import static org.sonar.auth.github.GitHubSettings.GITHUB_CLIENT_SECRET;
import static org.sonar.auth.github.GitHubSettings.GITHUB_ENABLED;
import static org.sonar.auth.github.GitHubSettings.GITHUB_GROUPS_SYNC;
import static org.sonar.auth.github.GitHubSettings.GITHUB_ORGANIZATIONS;
import static org.sonar.auth.github.GitHubSettings.GITHUB_PRIVATE_KEY;
import static org.sonar.auth.github.GitHubSettings.GITHUB_PROVISIONING;
import static org.sonar.auth.github.GitHubSettings.GITHUB_PROVISION_PROJECT_VISIBILITY;
import static org.sonar.auth.github.GitHubSettings.GITHUB_USER_CONSENT_FOR_PERMISSIONS_REQUIRED_AFTER_UPGRADE;
import static org.sonar.auth.github.GitHubSettings.GITHUB_WEB_URL;
import static org.sonar.server.common.gitlab.config.ProvisioningType.AUTO_PROVISIONING;
import static org.sonar.server.common.gitlab.config.ProvisioningType.JIT;
import static org.sonar.server.exceptions.NotFoundException.checkFound;
import static org.sonarqube.ws.WsUtils.checkArgument;

@ServerSide
public class GithubConfigurationService {

<span class="fc" id="L65">  private static final List&lt;String&gt; GITHUB_CONFIGURATION_PROPERTIES = List.of(</span>
    GITHUB_ENABLED,
    GITHUB_CLIENT_ID,
    GITHUB_CLIENT_SECRET,
    GITHUB_APP_ID,
    GITHUB_PRIVATE_KEY,
    GITHUB_GROUPS_SYNC,
    GITHUB_API_URL,
    GITHUB_WEB_URL,
    GITHUB_ORGANIZATIONS,
    GITHUB_ALLOW_USERS_TO_SIGN_UP,
    GITHUB_PROVISION_PROJECT_VISIBILITY,
    GITHUB_USER_CONSENT_FOR_PERMISSIONS_REQUIRED_AFTER_UPGRADE);

  public static final String UNIQUE_GITHUB_CONFIGURATION_ID = &quot;github-configuration&quot;;
  private final DbClient dbClient;
  private final ManagedInstanceService managedInstanceService;
  private final GithubGlobalSettingsValidator githubGlobalSettingsValidator;
  private final ThreadLocalSettings threadLocalSettings;

  public GithubConfigurationService(DbClient dbClient,
<span class="fc" id="L86">    ManagedInstanceService managedInstanceService, GithubGlobalSettingsValidator githubGlobalSettingsValidator, ThreadLocalSettings threadLocalSettings) {</span>
<span class="fc" id="L87">    this.dbClient = dbClient;</span>
<span class="fc" id="L88">    this.managedInstanceService = managedInstanceService;</span>
<span class="fc" id="L89">    this.githubGlobalSettingsValidator = githubGlobalSettingsValidator;</span>
<span class="fc" id="L90">    this.threadLocalSettings = threadLocalSettings;</span>
<span class="fc" id="L91">  }</span>

  public GithubConfiguration updateConfiguration(UpdateGithubConfigurationRequest updateRequest) {
<span class="fc" id="L94">    UpdatedValue&lt;Boolean&gt; provisioningEnabled = updateRequest.provisioningType().map(GithubConfigurationService::isTypeAutoProvisioning);</span>
<span class="fc" id="L95">    throwIfUrlIsUpdatedWithoutPrivateKey(updateRequest);</span>
<span class="fc" id="L96">    try (DbSession dbSession = dbClient.openSession(true)) {</span>
<span class="fc" id="L97">      throwIfConfigurationDoesntExist(dbSession);</span>
<span class="fc" id="L98">      GithubConfiguration currentConfiguration = getConfiguration(updateRequest.githubConfigurationId(), dbSession);</span>

<span class="fc" id="L100">      setIfDefined(dbSession, GITHUB_ENABLED, updateRequest.enabled().map(String::valueOf));</span>
<span class="fc" id="L101">      setIfDefined(dbSession, GITHUB_CLIENT_ID, updateRequest.clientId());</span>
<span class="fc" id="L102">      setIfDefined(dbSession, GITHUB_CLIENT_SECRET, updateRequest.clientSecret());</span>
<span class="fc" id="L103">      setIfDefined(dbSession, GITHUB_APP_ID, updateRequest.applicationId());</span>
<span class="fc" id="L104">      setIfDefined(dbSession, GITHUB_PRIVATE_KEY, updateRequest.privateKey());</span>
<span class="fc" id="L105">      setIfDefined(dbSession, GITHUB_GROUPS_SYNC, updateRequest.synchronizeGroups().map(String::valueOf));</span>
<span class="fc" id="L106">      setIfDefined(dbSession, GITHUB_API_URL, updateRequest.apiUrl());</span>
<span class="fc" id="L107">      setIfDefined(dbSession, GITHUB_WEB_URL, updateRequest.webUrl());</span>
<span class="fc" id="L108">      setIfDefined(dbSession, GITHUB_ORGANIZATIONS, updateRequest.allowedOrganizations().map(orgs -&gt; String.join(&quot;,&quot;, orgs)));</span>
<span class="fc" id="L109">      setInternalIfDefined(dbSession, GITHUB_PROVISIONING, provisioningEnabled.map(String::valueOf));</span>
<span class="fc" id="L110">      setIfDefined(dbSession, GITHUB_ALLOW_USERS_TO_SIGN_UP, updateRequest.allowUsersToSignUp().map(String::valueOf));</span>
<span class="fc" id="L111">      setIfDefined(dbSession, GITHUB_PROVISION_PROJECT_VISIBILITY, updateRequest.projectVisibility().map(String::valueOf));</span>
<span class="fc" id="L112">      insertOrDeleteAsEmptyIfDefined(dbSession, GITHUB_USER_CONSENT_FOR_PERMISSIONS_REQUIRED_AFTER_UPGRADE, updateRequest.userConsentRequiredAfterUpgrade().contains(true));</span>

<span class="fc" id="L114">      deleteExternalGroupsWhenDisablingAutoProvisioning(dbSession, currentConfiguration, updateRequest.provisioningType());</span>
<span class="fc" id="L115">      dbSession.commit();</span>

<span class="fc" id="L117">      GithubConfiguration updatedConfiguration = getConfiguration(UNIQUE_GITHUB_CONFIGURATION_ID, dbSession);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">      if (shouldTriggerProvisioning(provisioningEnabled, currentConfiguration, updateRequest)) {</span>
<span class="fc" id="L119">        triggerRun(updatedConfiguration);</span>
      }

<span class="fc" id="L122">      return updatedConfiguration;</span>
    }
  }

  private static boolean shouldTriggerProvisioning(UpdatedValue&lt;Boolean&gt; provisioningEnabled, GithubConfiguration currentConfiguration,
    UpdateGithubConfigurationRequest updateRequest) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">    return shouldTriggerProvisioningAfterTypeChange(provisioningEnabled, currentConfiguration)</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">      || shouldTriggerProvisioningAfterUserConsent(updateRequest, currentConfiguration);</span>
  }

  private static boolean shouldTriggerProvisioningAfterTypeChange(UpdatedValue&lt;Boolean&gt; provisioningEnabled, GithubConfiguration currentConfiguration) {
<span class="fc bfc" id="L133" title="All 2 branches covered.">    return provisioningEnabled.orElse(false)</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">      &amp;&amp; !currentConfiguration.provisioningType().equals(AUTO_PROVISIONING);</span>
  }

  private static boolean shouldTriggerProvisioningAfterUserConsent(UpdateGithubConfigurationRequest updateRequest,
    GithubConfiguration currentConfiguration) {
<span class="fc" id="L139">    boolean wasUserConsentRequired = currentConfiguration.userConsentRequiredAfterUpgrade();</span>
<span class="fc bfc" id="L140" title="All 4 branches covered.">    boolean userConsentProvidedForAutoProvisioning = !updateRequest.provisioningType().contains(JIT) &amp;&amp; updateRequest.userConsentRequiredAfterUpgrade().contains(false);</span>
<span class="fc bfc" id="L141" title="All 4 branches covered.">    return wasUserConsentRequired &amp;&amp; userConsentProvidedForAutoProvisioning;</span>
  }

  private static void throwIfUrlIsUpdatedWithoutPrivateKey(UpdateGithubConfigurationRequest request) {
<span class="pc bpc" id="L145" title="1 of 4 branches missed.">    if (request.apiUrl().isDefined() || request.webUrl().isDefined()) {</span>
<span class="fc" id="L146">      checkArgument(request.privateKey().isDefined(), &quot;For security reasons, API and Web urls can't be updated without providing the private key.&quot;);</span>
    }
<span class="fc" id="L148">  }</span>

  private void setIfDefined(DbSession dbSession, String propertyName, UpdatedValue&lt;String&gt; value) {
<span class="fc" id="L151">    value</span>
<span class="fc" id="L152">      .map(definedValue -&gt; new PropertyDto().setKey(propertyName).setValue(definedValue))</span>
<span class="fc" id="L153">      .applyIfDefined(property -&gt; dbClient.propertiesDao().saveProperty(dbSession, property));</span>
<span class="fc" id="L154">    threadLocalSettings.setProperty(propertyName, value.orElse(null));</span>
<span class="fc" id="L155">  }</span>

  private void insertOrDeleteAsEmptyIfDefined(DbSession dbSession, String propertyName, boolean value) {
<span class="fc bfc" id="L158" title="All 2 branches covered.">    if (value) {</span>
<span class="fc" id="L159">      dbClient.propertiesDao().saveProperty(dbSession, new PropertyDto().setKey(propertyName));</span>
    } else {
<span class="fc" id="L161">      dbClient.propertiesDao().deleteGlobalProperty(propertyName, dbSession);</span>
    }
<span class="fc" id="L163">    threadLocalSettings.setProperty(propertyName, value);</span>
<span class="fc" id="L164">  }</span>

  private void setInternalIfDefined(DbSession dbSession, String propertyName, UpdatedValue&lt;String&gt; value) {
<span class="fc" id="L167">    value.applyIfDefined(v -&gt; dbClient.internalPropertiesDao().save(dbSession, propertyName, v));</span>
<span class="fc" id="L168">  }</span>

  private void deleteExternalGroupsWhenDisablingAutoProvisioning(DbSession dbSession, GithubConfiguration currentConfiguration,
    UpdatedValue&lt;ProvisioningType&gt; provisioningTypeFromUpdate) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">    if (shouldDisableAutoProvisioning(currentConfiguration, provisioningTypeFromUpdate)) {</span>
<span class="fc" id="L173">      dbClient.externalGroupDao().deleteByExternalIdentityProvider(dbSession, GitHubIdentityProvider.KEY);</span>
<span class="fc" id="L174">      dbClient.githubOrganizationGroupDao().deleteAll(dbSession);</span>
<span class="fc" id="L175">      dbSession.commit();</span>
    }
<span class="fc" id="L177">  }</span>

  private static boolean shouldDisableAutoProvisioning(GithubConfiguration currentConfiguration, UpdatedValue&lt;ProvisioningType&gt; provisioningTypeFromUpdate) {
<span class="fc bfc" id="L180" title="All 2 branches covered.">    return provisioningTypeFromUpdate.map(provisioningType -&gt; provisioningType.equals(JIT)).orElse(false)</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">      &amp;&amp; currentConfiguration.provisioningType().equals(AUTO_PROVISIONING);</span>
  }

  public GithubConfiguration getConfiguration(String id) {
<span class="fc" id="L185">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L186">      throwIfNotUniqueConfigurationId(id);</span>
<span class="fc" id="L187">      throwIfConfigurationDoesntExist(dbSession);</span>
<span class="fc" id="L188">      return getConfiguration(id, dbSession);</span>
    }
  }

  public Optional&lt;GithubConfiguration&gt; findConfigurations() {
<span class="fc" id="L193">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">      if (dbClient.propertiesDao().selectGlobalProperty(dbSession, GITHUB_ENABLED) == null) {</span>
<span class="fc" id="L195">        return Optional.empty();</span>
      }
<span class="fc" id="L197">      return Optional.of(getConfiguration(UNIQUE_GITHUB_CONFIGURATION_ID, dbSession));</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">    }</span>
  }

  private Boolean getBooleanOrFalse(DbSession dbSession, String property) {
<span class="fc" id="L202">    return Optional.ofNullable(dbClient.propertiesDao().selectGlobalProperty(dbSession, property))</span>
<span class="fc" id="L203">      .map(dto -&gt; Boolean.valueOf(dto.getValue())).orElse(false);</span>
  }

  private Boolean getBooleanOrFalseFromEmptyProperty(DbSession dbSession, String property) {
<span class="fc" id="L207">    return Optional.ofNullable(dbClient.propertiesDao().selectGlobalProperty(dbSession, property))</span>
<span class="fc" id="L208">      .isPresent();</span>
  }

  private Boolean getInternalBooleanOrFalse(DbSession dbSession, String property) {
<span class="fc" id="L212">    return dbClient.internalPropertiesDao().selectByKey(dbSession, property)</span>
<span class="fc" id="L213">      .map(Boolean::valueOf)</span>
<span class="fc" id="L214">      .orElse(false);</span>
  }

  private String getStringPropertyOrEmpty(DbSession dbSession, String property) {
<span class="fc" id="L218">    return Optional.ofNullable(dbClient.propertiesDao().selectGlobalProperty(dbSession, property))</span>
<span class="fc" id="L219">      .map(PropertyDto::getValue).orElse(&quot;&quot;);</span>
  }

  private static void throwIfNotUniqueConfigurationId(String id) {
<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (!UNIQUE_GITHUB_CONFIGURATION_ID.equals(id)) {</span>
<span class="fc" id="L224">      throw new NotFoundException(format(&quot;GitHub configuration with id %s not found&quot;, id));</span>
    }
<span class="fc" id="L226">  }</span>

  public void deleteConfiguration(String id) {
<span class="fc" id="L229">    throwIfNotUniqueConfigurationId(id);</span>
<span class="fc" id="L230">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L231">      throwIfConfigurationDoesntExist(dbSession);</span>
<span class="fc" id="L232">      GITHUB_CONFIGURATION_PROPERTIES.forEach(property -&gt; dbClient.propertiesDao().deleteGlobalProperty(property, dbSession));</span>
<span class="fc" id="L233">      dbClient.internalPropertiesDao().delete(dbSession, GITHUB_PROVISIONING);</span>
<span class="fc" id="L234">      dbClient.externalGroupDao().deleteByExternalIdentityProvider(dbSession, GitHubIdentityProvider.KEY);</span>
<span class="fc" id="L235">      dbSession.commit();</span>
    }
<span class="fc" id="L237">  }</span>

  private void throwIfConfigurationDoesntExist(DbSession dbSession) {
<span class="fc" id="L240">    checkFound(dbClient.propertiesDao().selectGlobalProperty(dbSession, GITHUB_ENABLED), &quot;GitHub configuration doesn't exist.&quot;);</span>
<span class="fc" id="L241">  }</span>

  private static ProvisioningType toProvisioningType(boolean provisioningEnabled) {
<span class="fc bfc" id="L244" title="All 2 branches covered.">    return provisioningEnabled ? AUTO_PROVISIONING : JIT;</span>
  }

  public GithubConfiguration createConfiguration(GithubConfiguration configuration) {
<span class="fc" id="L248">    throwIfConfigurationAlreadyExists();</span>

<span class="fc" id="L250">    boolean enableAutoProvisioning = isTypeAutoProvisioning(configuration.provisioningType());</span>
<span class="fc" id="L251">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L252">      setProperty(dbSession, GITHUB_ENABLED, String.valueOf(configuration.enabled()));</span>
<span class="fc" id="L253">      setProperty(dbSession, GITHUB_CLIENT_ID, configuration.clientId());</span>
<span class="fc" id="L254">      setProperty(dbSession, GITHUB_CLIENT_SECRET, configuration.clientSecret());</span>
<span class="fc" id="L255">      setProperty(dbSession, GITHUB_APP_ID, configuration.applicationId());</span>
<span class="fc" id="L256">      setProperty(dbSession, GITHUB_PRIVATE_KEY, configuration.privateKey());</span>
<span class="fc" id="L257">      setProperty(dbSession, GITHUB_GROUPS_SYNC, String.valueOf(configuration.synchronizeGroups()));</span>
<span class="fc" id="L258">      setProperty(dbSession, GITHUB_API_URL, configuration.apiUrl());</span>
<span class="fc" id="L259">      setProperty(dbSession, GITHUB_WEB_URL, configuration.webUrl());</span>
<span class="fc" id="L260">      setProperty(dbSession, GITHUB_ORGANIZATIONS, String.join(&quot;,&quot;, configuration.allowedOrganizations()));</span>
<span class="fc" id="L261">      setInternalProperty(dbSession, GITHUB_PROVISIONING, String.valueOf(enableAutoProvisioning));</span>
<span class="fc" id="L262">      setProperty(dbSession, GITHUB_ALLOW_USERS_TO_SIGN_UP, String.valueOf(configuration.allowUsersToSignUp()));</span>
<span class="fc" id="L263">      setProperty(dbSession, GITHUB_PROVISION_PROJECT_VISIBILITY, String.valueOf(configuration.provisionProjectVisibility()));</span>
<span class="fc" id="L264">      setPropertyAsEmpty(dbSession, GITHUB_USER_CONSENT_FOR_PERMISSIONS_REQUIRED_AFTER_UPGRADE, configuration.userConsentRequiredAfterUpgrade());</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">      if (enableAutoProvisioning) {</span>
<span class="fc" id="L266">        triggerRun(configuration);</span>
      }
<span class="fc" id="L268">      GithubConfiguration createdConfiguration = getConfiguration(UNIQUE_GITHUB_CONFIGURATION_ID, dbSession);</span>
<span class="fc" id="L269">      dbSession.commit();</span>
<span class="fc" id="L270">      return createdConfiguration;</span>
    }

  }

  private void throwIfConfigurationAlreadyExists() {
<span class="fc" id="L276">    Optional.ofNullable(dbClient.propertiesDao().selectGlobalProperty(GITHUB_ENABLED)).ifPresent(property -&gt; {</span>
<span class="fc" id="L277">      throw BadRequestException.create(&quot;GitHub configuration already exists. Only one GitHub configuration is supported.&quot;);</span>
    });
<span class="fc" id="L279">  }</span>

  private static boolean isTypeAutoProvisioning(ProvisioningType provisioningType) {
<span class="fc" id="L282">    return AUTO_PROVISIONING.equals(provisioningType);</span>
  }

  private void setProperty(DbSession dbSession, String propertyName, @Nullable String value) {
<span class="fc" id="L286">    dbClient.propertiesDao().saveProperty(dbSession, new PropertyDto().setKey(propertyName).setValue(value));</span>
<span class="fc" id="L287">  }</span>

  private void setPropertyAsEmpty(DbSession dbSession, String propertyName, boolean value) {
<span class="fc bfc" id="L290" title="All 2 branches covered.">    if (value) {</span>
<span class="fc" id="L291">      dbClient.propertiesDao().saveProperty(dbSession, new PropertyDto().setKey(propertyName));</span>
    }
<span class="fc" id="L293">  }</span>

  private void setInternalProperty(DbSession dbSession, String propertyName, @Nullable String value) {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">    if (StringUtils.isNotEmpty(value)) {</span>
<span class="fc" id="L297">      dbClient.internalPropertiesDao().save(dbSession, propertyName, value);</span>
    }
<span class="fc" id="L299">  }</span>

  private GithubConfiguration getConfiguration(String id, DbSession dbSession) {
<span class="fc" id="L302">    throwIfNotUniqueConfigurationId(id);</span>
<span class="fc" id="L303">    throwIfConfigurationDoesntExist(dbSession);</span>
<span class="fc" id="L304">    return new GithubConfiguration(</span>
      UNIQUE_GITHUB_CONFIGURATION_ID,
<span class="fc" id="L306">      getBooleanOrFalse(dbSession, GITHUB_ENABLED),</span>
<span class="fc" id="L307">      getStringPropertyOrEmpty(dbSession, GITHUB_CLIENT_ID),</span>
<span class="fc" id="L308">      getStringPropertyOrEmpty(dbSession, GITHUB_CLIENT_SECRET),</span>
<span class="fc" id="L309">      getStringPropertyOrEmpty(dbSession, GITHUB_APP_ID),</span>
<span class="fc" id="L310">      getStringPropertyOrEmpty(dbSession, GITHUB_PRIVATE_KEY),</span>
<span class="fc" id="L311">      getBooleanOrFalse(dbSession, GITHUB_GROUPS_SYNC),</span>
<span class="fc" id="L312">      getStringPropertyOrEmpty(dbSession, GITHUB_API_URL),</span>
<span class="fc" id="L313">      getStringPropertyOrEmpty(dbSession, GITHUB_WEB_URL),</span>
<span class="fc" id="L314">      getAllowedOrganizations(dbSession),</span>
<span class="fc" id="L315">      toProvisioningType(getInternalBooleanOrFalse(dbSession, GITHUB_PROVISIONING)),</span>
<span class="fc" id="L316">      getBooleanOrFalse(dbSession, GITHUB_ALLOW_USERS_TO_SIGN_UP),</span>
<span class="fc" id="L317">      getBooleanOrFalse(dbSession, GITHUB_PROVISION_PROJECT_VISIBILITY),</span>
<span class="fc" id="L318">      getBooleanOrFalseFromEmptyProperty(dbSession, GITHUB_USER_CONSENT_FOR_PERMISSIONS_REQUIRED_AFTER_UPGRADE));</span>
  }

  private Set&lt;String&gt; getAllowedOrganizations(DbSession dbSession) {
<span class="fc" id="L322">    return Optional.ofNullable(dbClient.propertiesDao().selectGlobalProperty(dbSession, GITHUB_ORGANIZATIONS))</span>
<span class="fc" id="L323">      .map(dto -&gt; Arrays.stream(dto.getValue().split(&quot;,&quot;))</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        .filter(s -&gt; !s.isEmpty())</span>
<span class="fc" id="L325">        .collect(Collectors.toSet()))</span>
<span class="fc" id="L326">      .orElse(Set.of());</span>
  }

  private void triggerRun(GithubConfiguration githubConfiguration) {
<span class="fc" id="L330">    throwIfConfigIncompleteOrInstanceAlreadyManaged(githubConfiguration);</span>
<span class="fc" id="L331">    managedInstanceService.queueSynchronisationTask();</span>
<span class="fc" id="L332">  }</span>

  private void throwIfConfigIncompleteOrInstanceAlreadyManaged(GithubConfiguration configuration) {
<span class="fc" id="L335">    checkInstanceNotManagedByAnotherProvider();</span>
<span class="fc" id="L336">    checkState(AUTO_PROVISIONING.equals(configuration.provisioningType()), &quot;Auto provisioning must be activated&quot;);</span>
<span class="fc" id="L337">    checkState(configuration.enabled(), getErrorMessage(&quot;GitHub authentication must be turned on&quot;));</span>
<span class="fc" id="L338">  }</span>

  private void checkInstanceNotManagedByAnotherProvider() {
<span class="fc bfc" id="L341" title="All 2 branches covered.">    if (managedInstanceService.isInstanceExternallyManaged()) {</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">      Optional.of(managedInstanceService.getProviderName()).filter(providerName -&gt; !GitHubIdentityProvider.KEY.equals(providerName))</span>
<span class="nc" id="L343">        .ifPresent(providerName -&gt; {</span>
<span class="fc" id="L344">          throw new IllegalStateException(&quot;It is not possible to synchronize SonarQube using GitHub, as it is already managed by &quot; + providerName + &quot;.&quot;);</span>
        });
    }
<span class="fc" id="L347">  }</span>

  private static String getErrorMessage(String prefix) {
<span class="fc" id="L350">    return format(&quot;%s to enable GitHub provisioning.&quot;, prefix);</span>
  }

  public Optional&lt;String&gt; validate(GithubConfiguration configuration) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">    if (!configuration.enabled()) {</span>
<span class="fc" id="L355">      return Optional.empty();</span>
    }
    try {
<span class="fc" id="L358">      githubGlobalSettingsValidator.validate(configuration.applicationId(), configuration.clientId(), configuration.clientSecret(), configuration.privateKey(),</span>
<span class="fc" id="L359">        configuration.apiUrl());</span>
<span class="fc" id="L360">    } catch (Exception e) {</span>
<span class="fc" id="L361">      return Optional.of(e.getMessage());</span>
<span class="fc" id="L362">    }</span>
<span class="fc" id="L363">    return Optional.empty();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>