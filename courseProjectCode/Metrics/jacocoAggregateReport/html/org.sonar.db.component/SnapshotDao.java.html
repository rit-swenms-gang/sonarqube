<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SnapshotDao.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.db.component</a> &gt; <span class="el_source">SnapshotDao.java</span></div><h1>SnapshotDao.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.db.component;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.IntStream;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.db.Dao;
import org.sonar.db.DbSession;
import org.sonar.db.Pagination;

import static com.google.common.base.Preconditions.checkArgument;
import static java.util.Objects.requireNonNull;
import static org.sonar.db.DatabaseUtils.executeLargeInputs;

<span class="fc" id="L40">public class SnapshotDao implements Dao {</span>

  public static boolean isLast(SnapshotDto snapshotTested, @Nullable SnapshotDto previousLastSnapshot) {
<span class="fc bfc" id="L43" title="All 4 branches covered.">    return previousLastSnapshot == null || previousLastSnapshot.getCreatedAt() &lt; snapshotTested.getCreatedAt();</span>
  }

  public Optional&lt;SnapshotDto&gt; selectByUuid(DbSession dbSession, String analysisUuid) {
<span class="fc" id="L47">    List&lt;SnapshotDto&gt; dtos = mapper(dbSession).selectByUuids(Collections.singletonList(analysisUuid));</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">    if (dtos.isEmpty()) {</span>
<span class="fc" id="L49">      return Optional.empty();</span>
    }
<span class="fc" id="L51">    return Optional.of(dtos.iterator().next());</span>
  }

  public List&lt;SnapshotDto&gt; selectByUuids(DbSession dbSession, Collection&lt;String&gt; analysisUuids) {
<span class="fc" id="L55">    return executeLargeInputs(analysisUuids, mapper(dbSession)::selectByUuids);</span>
  }

  public Optional&lt;SnapshotDto&gt; selectLastAnalysisByComponentUuid(DbSession session, String componentUuid) {
<span class="fc" id="L59">    return Optional.ofNullable(mapper(session).selectLastSnapshotByComponentUuid(componentUuid));</span>
  }

  /**
   * returns the last analysis of any branch of a project
   */
  public Optional&lt;Long&gt; selectLastAnalysisDateByProject(DbSession session, String projectUuid) {
<span class="nc" id="L66">    return Optional.ofNullable(mapper(session).selectLastAnalysisDateByProject(projectUuid));</span>
  }

  /**
   * returns the last analysis of any branch for each existing project
   */
  public List&lt;ProjectLastAnalysisDateDto&gt; selectLastAnalysisDateByProjectUuids(DbSession session, Collection&lt;String&gt; projectUuids) {
<span class="fc bfc" id="L73" title="All 2 branches covered.">    if (projectUuids.isEmpty()) {</span>
<span class="fc" id="L74">      return Collections.emptyList();</span>
    }
<span class="fc" id="L76">    return mapper(session).selectLastAnalysisDateByProjectUuids(projectUuids);</span>
  }

  public Optional&lt;SnapshotDto&gt; selectLastAnalysisByRootComponentUuid(DbSession session, String rootComponentUuid) {
<span class="fc" id="L80">    return Optional.ofNullable(mapper(session).selectLastSnapshotByRootComponentUuid(rootComponentUuid));</span>
  }

  public List&lt;SnapshotDto&gt; selectLastAnalysesByRootComponentUuids(DbSession dbSession, Collection&lt;String&gt; rootComponentUuids) {
<span class="fc" id="L84">    return executeLargeInputs(rootComponentUuids, mapper(dbSession)::selectLastSnapshotsByRootComponentUuids);</span>
  }

  public List&lt;SnapshotDto&gt; selectAnalysesByQuery(DbSession session, SnapshotQuery query) {
<span class="fc" id="L88">    return mapper(session).selectSnapshotsByQuery(query);</span>
  }

  public Optional&lt;SnapshotDto&gt; selectOldestAnalysis(DbSession session, String rootComponentUuid) {
<span class="fc" id="L92">    return mapper(session).selectOldestSnapshots(rootComponentUuid, SnapshotDto.STATUS_PROCESSED, Pagination.first())</span>
<span class="fc" id="L93">      .stream()</span>
<span class="fc" id="L94">      .findFirst();</span>
  }

  /**
   * Returned finished analysis from a list of projects and dates.
   * &quot;Finished&quot; analysis means that the status in the CE_ACTIVITY table is SUCCESS =&gt; the goal is to be sure that the CE task is completely finished.
   * Note that branches analysis of projects are also returned.
   */
  public List&lt;SnapshotDto&gt; selectFinishedByProjectUuidsAndFromDates(DbSession dbSession, List&lt;String&gt; projectUuids, List&lt;Long&gt; fromDates) {
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">    checkArgument(projectUuids.size() == fromDates.size(), &quot;The number of components (%s) and from dates (%s) must be the same.&quot;,</span>
<span class="fc" id="L104">      String.valueOf(projectUuids.size()),</span>
<span class="fc" id="L105">      String.valueOf(fromDates.size()));</span>
<span class="fc" id="L106">    List&lt;ProjectUuidFromDatePair&gt; projectUuidFromDatePairs = IntStream.range(0, projectUuids.size())</span>
<span class="fc" id="L107">      .mapToObj(i -&gt; new ProjectUuidFromDatePair(projectUuids.get(i), fromDates.get(i)))</span>
<span class="fc" id="L108">      .toList();</span>

<span class="fc" id="L110">    return executeLargeInputs(projectUuidFromDatePairs, partition -&gt; mapper(dbSession).selectFinishedByProjectUuidsAndFromDates(partition), i -&gt; i / 2);</span>
  }

  public void switchIsLastFlagAndSetProcessedStatus(DbSession dbSession, String rootComponentUuid, String analysisUuid) {
<span class="fc" id="L114">    SnapshotMapper mapper = mapper(dbSession);</span>
<span class="fc" id="L115">    mapper.unsetIsLastFlagForRootComponentUuid(rootComponentUuid);</span>
<span class="fc" id="L116">    mapper(dbSession).setIsLastFlagForAnalysisUuid(analysisUuid);</span>
<span class="fc" id="L117">  }</span>

  public SnapshotDto insert(DbSession session, SnapshotDto item) {
<span class="fc" id="L120">    mapper(session).insert(item);</span>
<span class="fc" id="L121">    return item;</span>
  }

  @VisibleForTesting
  public void insert(DbSession session, Collection&lt;SnapshotDto&gt; items) {
<span class="fc bfc" id="L126" title="All 2 branches covered.">    for (SnapshotDto item : items) {</span>
<span class="fc" id="L127">      insert(session, item);</span>
<span class="fc" id="L128">    }</span>
<span class="fc" id="L129">  }</span>

  @VisibleForTesting
  public void insert(DbSession session, SnapshotDto item, SnapshotDto... others) {
<span class="fc" id="L133">    insert(session, Lists.asList(item, others));</span>
<span class="fc" id="L134">  }</span>

  public void update(DbSession dbSession, SnapshotDto analysis) {
<span class="fc" id="L137">    mapper(dbSession).update(analysis);</span>
<span class="fc" id="L138">  }</span>

  /**
   * Used by Governance
   */
  @CheckForNull
  public ViewsSnapshotDto selectSnapshotBefore(String rootComponentUuid, long date, DbSession dbSession) {
<span class="fc" id="L145">    return mapper(dbSession).selectSnapshotBefore(rootComponentUuid, date).stream().findFirst().orElse(null);</span>
  }

  private static SnapshotMapper mapper(DbSession session) {
<span class="fc" id="L149">    return session.getMapper(SnapshotMapper.class);</span>
  }

  static class ProjectUuidFromDatePair implements Comparable&lt;ProjectUuidFromDatePair&gt; {
    private final String projectUuid;
    private final long from;

<span class="fc" id="L156">    ProjectUuidFromDatePair(String projectUuid, long from) {</span>
<span class="fc" id="L157">      this.projectUuid = requireNonNull(projectUuid);</span>
<span class="fc" id="L158">      this.from = from;</span>
<span class="fc" id="L159">    }</span>

    @Override
    public int compareTo(ProjectUuidFromDatePair other) {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">      if (this == other) {</span>
<span class="nc" id="L164">        return 0;</span>
      }

<span class="fc" id="L167">      int c = projectUuid.compareTo(other.projectUuid);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">      if (c == 0) {</span>
<span class="nc" id="L169">        c = Long.compare(from, other.from);</span>
      }

<span class="fc" id="L172">      return c;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L178">        return true;</span>
      }
<span class="nc bnc" id="L180" title="All 4 branches missed.">      if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L181">        return false;</span>
      }

<span class="nc" id="L184">      ProjectUuidFromDatePair other = (ProjectUuidFromDatePair) o;</span>
<span class="nc bnc" id="L185" title="All 4 branches missed.">      return projectUuid.equals(other.projectUuid) &amp;&amp; from == other.from;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L190">      return Objects.hash(projectUuid, from);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>