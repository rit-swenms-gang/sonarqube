<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ComponentDao.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.db.component</a> &gt; <span class="el_source">ComponentDao.java</span></div><h1>ComponentDao.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.db.component;

import com.google.common.collect.Ordering;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.apache.ibatis.session.ResultHandler;
import org.sonar.db.Dao;
import org.sonar.db.DbSession;
import org.sonar.db.Pagination;
import org.sonar.db.RowNotFoundException;
import org.sonar.db.audit.AuditPersister;
import org.sonar.db.audit.model.ComponentNewValue;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.util.Collections.emptyList;
import static org.sonar.db.DatabaseUtils.checkThatNotTooManyConditions;
import static org.sonar.db.DatabaseUtils.executeLargeInputs;
import static org.sonar.db.DatabaseUtils.executeLargeInputsIntoSet;
import static org.sonar.db.DatabaseUtils.executeLargeUpdates;

public class ComponentDao implements Dao {
  private final AuditPersister auditPersister;

<span class="fc" id="L52">  public ComponentDao(AuditPersister auditPersister) {</span>
<span class="fc" id="L53">    this.auditPersister = auditPersister;</span>
<span class="fc" id="L54">  }</span>

  /*
   * SELECT BY UUID
   */
  public Optional&lt;ComponentDto&gt; selectByUuid(DbSession session, String uuid) {
<span class="fc" id="L60">    return Optional.ofNullable(mapper(session).selectByUuid(uuid));</span>
  }

  public ComponentDto selectOrFailByUuid(DbSession session, String uuid) {
<span class="fc" id="L64">    return selectByUuid(session, uuid).orElseThrow(() -&gt; new RowNotFoundException(String.format(&quot;Component with uuid '%s' not found&quot;,</span>
      uuid)));
  }

  public List&lt;ComponentDto&gt; selectByUuids(DbSession session, Collection&lt;String&gt; uuids) {
<span class="fc" id="L69">    return executeLargeInputs(uuids, mapper(session)::selectByUuids);</span>
  }

  public List&lt;String&gt; selectExistingUuids(DbSession session, Collection&lt;String&gt; uuids) {
<span class="fc" id="L73">    return executeLargeInputs(uuids, mapper(session)::selectExistingUuids);</span>
  }

  public List&lt;ComponentDto&gt; selectSubProjectsByComponentUuids(DbSession session, Collection&lt;String&gt; uuids) {
<span class="fc bfc" id="L77" title="All 2 branches covered.">    if (uuids.isEmpty()) {</span>
<span class="fc" id="L78">      return emptyList();</span>
    }
<span class="fc" id="L80">    return mapper(session).selectSubProjectsByComponentUuids(uuids);</span>
  }

  public List&lt;ComponentDto&gt; selectEnabledViewsFromRootView(DbSession session, String rootViewUuid) {
<span class="fc" id="L84">    return mapper(session).selectEnabledViewsFromRootView(rootViewUuid);</span>
  }

  public List&lt;FilePathWithHashDto&gt; selectEnabledFilesFromProject(DbSession session, String rootComponentUuid) {
<span class="fc" id="L88">    return mapper(session).selectEnabledFilesFromProject(rootComponentUuid);</span>
  }

  /**
   * Retrieves all components with a specific branch UUID, no other filtering is done by this method.
   */
  public List&lt;ComponentDto&gt; selectByBranchUuid(String branchUuid, DbSession dbSession) {
<span class="fc" id="L95">    return mapper(dbSession).selectByBranchUuid(branchUuid);</span>
  }

  /*
    SELECT BY QUERY
   */

  /**
   * @throws IllegalArgumentException if parameter query#getComponentIds() has more than
   * {@link org.sonar.db.DatabaseUtils#PARTITION_SIZE_FOR_ORACLE} values
   * @throws IllegalArgumentException if parameter query#getComponentKeys() has more than
   * {@link org.sonar.db.DatabaseUtils#PARTITION_SIZE_FOR_ORACLE} values
   * @throws IllegalArgumentException if parameter query#getMainComponentUuids() has more than
   * {@link org.sonar.db.DatabaseUtils#PARTITION_SIZE_FOR_ORACLE} values
   */
  public List&lt;ComponentDto&gt; selectByQuery(DbSession dbSession, ComponentQuery query, Pagination pagination) {
<span class="fc" id="L111">    return selectByQueryImpl(dbSession, query, pagination);</span>
  }

  /**
   * @throws IllegalArgumentException if parameter query#getComponentIds() has more than
   * {@link org.sonar.db.DatabaseUtils#PARTITION_SIZE_FOR_ORACLE} values
   * @throws IllegalArgumentException if parameter query#getComponentKeys() has more than
   * {@link org.sonar.db.DatabaseUtils#PARTITION_SIZE_FOR_ORACLE} values
   * @throws IllegalArgumentException if parameter query#getMainComponentUuids() has more than
   * {@link org.sonar.db.DatabaseUtils#PARTITION_SIZE_FOR_ORACLE} values
   */
  public int countByQuery(DbSession session, ComponentQuery query) {
<span class="fc" id="L123">    return countByQueryImpl(session, query);</span>
  }

  private static List&lt;ComponentDto&gt; selectByQueryImpl(DbSession session, ComponentQuery query, Pagination pagination) {
<span class="fc bfc" id="L127" title="All 2 branches covered.">    if (query.hasEmptySetOfComponents()) {</span>
<span class="fc" id="L128">      return emptyList();</span>
    }
<span class="fc" id="L130">    checkThatNotTooManyComponents(query);</span>
<span class="fc" id="L131">    return mapper(session).selectByQuery(query, pagination);</span>
  }

  private static int countByQueryImpl(DbSession session, ComponentQuery query) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">    if (query.hasEmptySetOfComponents()) {</span>
<span class="fc" id="L136">      return 0;</span>
    }
<span class="fc" id="L138">    checkThatNotTooManyComponents(query);</span>
<span class="fc" id="L139">    return mapper(session).countByQuery(query);</span>
  }

  /*
     SELECT BY KEY
   */

  /**
   * Return all components of a project (including disable ones)
   */
  public List&lt;KeyWithUuidDto&gt; selectUuidsByKeyFromProjectKey(DbSession session, String projectKey) {
<span class="fc" id="L150">    return mapper(session).selectUuidsByKeyFromProjectKeyAndBranchOrPr(projectKey, null, null);</span>
  }

  public List&lt;KeyWithUuidDto&gt; selectUuidsByKeyFromProjectKeyAndBranch(DbSession session, String projectKey, String branch) {
<span class="fc" id="L154">    return mapper(session).selectUuidsByKeyFromProjectKeyAndBranchOrPr(projectKey, branch, null);</span>
  }

  public List&lt;KeyWithUuidDto&gt; selectUuidsByKeyFromProjectKeyAndPullRequest(DbSession session, String projectKey, String pullrequest) {
<span class="fc" id="L158">    return mapper(session).selectUuidsByKeyFromProjectKeyAndBranchOrPr(projectKey, null, pullrequest);</span>
  }

  public List&lt;ComponentDto&gt; selectByKeys(DbSession session, Collection&lt;String&gt; keys) {
<span class="fc" id="L162">    return selectByKeys(session, keys, null, null);</span>
  }

  /**
   * If no branch or pull request is provided, returns components in the main branch
   */
  public List&lt;ComponentDto&gt; selectByKeys(DbSession session, Collection&lt;String&gt; keys, @Nullable String branch,
    @Nullable String pullRequest) {
<span class="fc bfc" id="L170" title="All 4 branches covered.">    checkState(branch == null || pullRequest == null, &quot;Can't set both branch and pull request&quot;);</span>
<span class="fc" id="L171">    return executeLargeInputs(keys, subKeys -&gt; mapper(session).selectByKeysAndBranchOrPr(subKeys, branch, pullRequest));</span>
  }

  /**
   * Returns components in the main branch
   */
  public Optional&lt;ComponentDto&gt; selectByKey(DbSession session, String key) {
<span class="fc" id="L178">    return Optional.ofNullable(mapper(session).selectByKeyAndBranchOrPr(key, null, null));</span>
  }

  public Optional&lt;ComponentDto&gt; selectByKeyAndBranch(DbSession session, String key, String branch) {
<span class="fc" id="L182">    return Optional.ofNullable(mapper(session).selectByKeyAndBranchOrPr(key, branch, null));</span>
  }

  public Optional&lt;ComponentDto&gt; selectByKeyAndPullRequest(DbSession session, String key, String pullRequestId) {
<span class="fc" id="L186">    return Optional.ofNullable(mapper(session).selectByKeyAndBranchOrPr(key, null, pullRequestId));</span>
  }

  public List&lt;ComponentDto&gt; selectByKeyCaseInsensitive(DbSession session, String key) {
<span class="fc" id="L190">    return mapper(session).selectByKeyCaseInsensitive(key);</span>
  }

  /**
   * List of ancestors, ordered from root to parent. The list is empty
   * if the component is a tree root. Disabled components are excluded by design
   * as tree represents the more recent analysis.
   */
  public List&lt;ComponentDto&gt; selectAncestors(DbSession dbSession, ComponentDto component) {
<span class="fc bfc" id="L199" title="All 2 branches covered.">    if (component.isRoot()) {</span>
<span class="fc" id="L200">      return Collections.emptyList();</span>
    }
<span class="fc" id="L202">    List&lt;String&gt; ancestorUuids = component.getUuidPathAsList();</span>
<span class="fc" id="L203">    List&lt;ComponentDto&gt; ancestors = selectByUuids(dbSession, ancestorUuids);</span>
<span class="fc" id="L204">    return Ordering.explicit(ancestorUuids).onResultOf(ComponentDto::uuid).immutableSortedCopy(ancestors);</span>
  }

  /**
   * Select the children or the leaves of a base component, given by its UUID. The components that are not present in last
   * analysis are ignored.
   * &lt;p&gt;
   * An empty list is returned if the base component does not exist or if the base component is a leaf.
   */
  public List&lt;ComponentDto&gt; selectDescendants(DbSession dbSession, ComponentTreeQuery query) {
<span class="fc" id="L214">    Optional&lt;ComponentDto&gt; componentOpt = selectByUuid(dbSession, query.getBaseUuid());</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">    if (!componentOpt.isPresent()) {</span>
<span class="fc" id="L216">      return emptyList();</span>
    }
<span class="fc" id="L218">    ComponentDto component = componentOpt.get();</span>
<span class="fc" id="L219">    return mapper(dbSession).selectDescendants(query, componentOpt.get().uuid(), query.getUuidPath(component));</span>
  }

  public List&lt;ComponentDto&gt; selectChildren(DbSession dbSession, String branchUuid, Collection&lt;ComponentDto&gt; components) {
<span class="fc" id="L223">    Set&lt;String&gt; uuidPaths = components.stream().map(c -&gt; c.getUuidPath() + c.uuid() + &quot;.&quot;).collect(Collectors.toSet());</span>
<span class="fc" id="L224">    return mapper(dbSession).selectChildren(branchUuid, uuidPaths);</span>
  }

  /*
    SELECT ALL
   */
  public List&lt;UuidWithBranchUuidDto&gt; selectAllViewsAndSubViews(DbSession session) {
<span class="fc" id="L231">    return mapper(session).selectUuidsForQualifiers(ComponentQualifiers.APP, ComponentQualifiers.VIEW, ComponentQualifiers.SUBVIEW);</span>
  }

  /**
   * Used by Governance
   */
  public Set&lt;String&gt; selectViewKeysWithEnabledCopyOfProject(DbSession session, Set&lt;String&gt; projectUuids) {
<span class="fc" id="L238">    return executeLargeInputsIntoSet(projectUuids, partition -&gt; mapper(session).selectViewKeysWithEnabledCopyOfProject(partition), i -&gt; i);</span>
  }

  public List&lt;String&gt; selectProjectBranchUuidsFromView(DbSession session, String viewUuid, String rootViewUuid) {
    // TODO why not query by scope/qualifier, using the view as the branchUuid?
<span class="fc" id="L243">    var escapedViewUuid = viewUuid.replace(&quot;_&quot;, &quot;\\_&quot;).replace(&quot;%&quot;, &quot;\\%&quot;);</span>
<span class="fc" id="L244">    return mapper(session).selectProjectsFromView(&quot;%.&quot; + escapedViewUuid + &quot;.%&quot;, rootViewUuid);</span>
  }

  /**
   * Retrieve enabled components keys with given qualifiers
   * &lt;p&gt;
   * Used by Views plugin
   */
  public Set&lt;ComponentDto&gt; selectComponentsByQualifiers(DbSession dbSession, Set&lt;String&gt; qualifiers) {
<span class="fc bfc" id="L253" title="All 2 branches covered.">    checkArgument(!qualifiers.isEmpty(), &quot;Qualifiers cannot be empty&quot;);</span>
<span class="fc" id="L254">    return new HashSet&lt;&gt;(mapper(dbSession).selectComponentsByQualifiers(qualifiers));</span>
  }

  /**
   * Returns components with open issues from P/Rs that use a certain branch as reference (reference branch).
   * Excludes components from the current branch.
   */
  public List&lt;KeyWithUuidDto&gt; selectComponentsFromPullRequestsTargetingCurrentBranchThatHaveOpenIssues(DbSession dbSession,
    String referenceBranchUuid, String currentBranchUuid) {
<span class="fc" id="L263">    return mapper(dbSession).selectComponentsFromPullRequestsTargetingCurrentBranchThatHaveOpenIssues(referenceBranchUuid,</span>
      currentBranchUuid);
  }

  /**
   * Returns components with open issues from the given branches
   */
  public List&lt;KeyWithUuidDto&gt; selectComponentsFromBranchesThatHaveOpenIssues(DbSession dbSession, Set&lt;String&gt; branchUuids) {
<span class="fc bfc" id="L271" title="All 2 branches covered.">    if (branchUuids.isEmpty()) {</span>
<span class="fc" id="L272">      return emptyList();</span>
    }

<span class="fc" id="L275">    return executeLargeInputs(branchUuids, input -&gt; mapper(dbSession).selectComponentsFromBranchesThatHaveOpenIssues(input));</span>
  }

  /**
   * Scroll all &lt;strong&gt;enabled&lt;/strong&gt; files of the specified project (same project_uuid) in no specific order with
   * 'SOURCE' source and a non null path.
   */
  public void scrollAllFilesForFileMove(DbSession session, String branchUuid, ResultHandler&lt;FileMoveRowDto&gt; handler) {
<span class="fc" id="L283">    mapper(session).scrollAllFilesForFileMove(branchUuid, handler);</span>
<span class="fc" id="L284">  }</span>

  public boolean existAnyOfComponentsWithQualifiers(DbSession session, Collection&lt;String&gt; componentKeys, Set&lt;String&gt; qualifiers) {
<span class="fc bfc" id="L287" title="All 2 branches covered.">    if (!componentKeys.isEmpty()) {</span>
<span class="fc" id="L288">      List&lt;Boolean&gt; result = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L289">      return executeLargeInputs(componentKeys, input -&gt; {</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        boolean groupNeedIssueSync = mapper(session).checkIfAnyOfComponentsWithQualifiers(input, qualifiers) &gt; 0;</span>
<span class="fc" id="L291">        result.add(groupNeedIssueSync);</span>
<span class="fc" id="L292">        return result;</span>
<span class="fc" id="L293">      }).stream().anyMatch(b -&gt; b);</span>
    }
<span class="fc" id="L295">    return false;</span>
  }

  /*
    INSERT / UPDATE
   */
  public void insert(DbSession session, ComponentDto item, boolean shouldPersistAudit) {
<span class="fc" id="L302">    mapper(session).insert(item);</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">    if (shouldPersistAudit) {</span>
<span class="fc" id="L304">      auditPersister.addComponent(session, new ComponentNewValue(item));</span>
    }
<span class="fc" id="L306">  }</span>

  public void insertWithAudit(DbSession session, ComponentDto item) {
<span class="fc" id="L309">    insert(session, item, true);</span>
<span class="fc" id="L310">  }</span>

  public void insert(DbSession session, Collection&lt;ComponentDto&gt; items, boolean isMainBranch) {
<span class="fc" id="L313">    insert(session, items.stream(), isMainBranch);</span>
<span class="fc" id="L314">  }</span>

  private void insert(DbSession session, Stream&lt;ComponentDto&gt; items, boolean isMainBranch) {
<span class="fc" id="L317">    items.forEach(item -&gt; insert(session, item, isMainBranch));</span>
<span class="fc" id="L318">  }</span>

  public void update(DbSession session, ComponentUpdateDto component, String qualifier) {
<span class="fc" id="L321">    auditPersister.updateComponent(session, new ComponentNewValue(component.getUuid(), component.getBName(),</span>
<span class="fc" id="L322">      component.getBKey(), component.isBEnabled(), component.getBPath(), qualifier));</span>
<span class="fc" id="L323">    mapper(session).update(component);</span>
<span class="fc" id="L324">  }</span>

  public void updateBEnabledToFalse(DbSession session, Collection&lt;String&gt; uuids) {
<span class="fc" id="L327">    executeLargeUpdates(uuids, mapper(session)::updateBEnabledToFalse);</span>
<span class="fc" id="L328">  }</span>

  public void applyBChangesForBranchUuid(DbSession session, String branchUuid) {
<span class="fc" id="L331">    mapper(session).applyBChangesForBranchUuid(branchUuid);</span>
<span class="fc" id="L332">  }</span>

  public void resetBChangedForBranchUuid(DbSession session, String branchUuid) {
<span class="fc" id="L335">    mapper(session).resetBChangedForBranchUuid(branchUuid);</span>
<span class="fc" id="L336">  }</span>

  public void setPrivateForBranchUuidWithoutAudit(DbSession session, String branchUuid, boolean isPrivate) {
<span class="fc" id="L339">    mapper(session).setPrivateForBranchUuid(branchUuid, isPrivate);</span>
<span class="fc" id="L340">  }</span>

  public void setPrivateForBranchUuid(DbSession session, String branchUuid, boolean isPrivate, String qualifier, String componentKey,
    String componentName) {
<span class="fc" id="L344">    ComponentNewValue componentNewValue = new ComponentNewValue(branchUuid, componentName, componentKey, isPrivate, qualifier);</span>
    //TODO we should log change to the visibility in EntityDao, not ComponentDao
<span class="fc" id="L346">    auditPersister.updateComponentVisibility(session, componentNewValue);</span>
<span class="fc" id="L347">    mapper(session).setPrivateForBranchUuid(branchUuid, isPrivate);</span>
<span class="fc" id="L348">  }</span>

  public void setPrivateForBranchUuidWithoutAuditLog(DbSession session, String branchUuid, boolean isPrivate) {
<span class="fc" id="L351">    mapper(session).setPrivateForBranchUuid(branchUuid, isPrivate);</span>
<span class="fc" id="L352">  }</span>

  /*
     UTIL
   */
  private static ComponentMapper mapper(DbSession session) {
<span class="fc" id="L358">    return session.getMapper(ComponentMapper.class);</span>
  }

  private static void checkThatNotTooManyComponents(ComponentQuery query) {
<span class="fc" id="L362">    checkThatNotTooManyConditions(query.getComponentKeys(), &quot;Too many component keys in query&quot;);</span>
<span class="fc" id="L363">    checkThatNotTooManyConditions(query.getComponentUuids(), &quot;Too many component UUIDs in query&quot;);</span>
<span class="fc" id="L364">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>