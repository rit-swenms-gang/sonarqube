<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InternalPropertiesDao.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.db.property</a> &gt; <span class="el_source">InternalPropertiesDao.java</span></div><h1>InternalPropertiesDao.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.db.property;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.api.utils.System2;
import org.slf4j.LoggerFactory;
import org.sonar.db.Dao;
import org.sonar.db.DbSession;
import org.sonar.db.audit.AuditPersister;
import org.sonar.db.audit.model.PropertyNewValue;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.util.Collections.singletonList;

public class InternalPropertiesDao implements Dao {

  /**
   * A common prefix used by locks. {@see InternalPropertiesDao#tryLock}
   */
  private static final String LOCK_PREFIX = &quot;lock.&quot;;

  private static final int KEY_MAX_LENGTH = 40;
<span class="fc" id="L54">  public static final int LOCK_NAME_MAX_LENGTH = KEY_MAX_LENGTH - LOCK_PREFIX.length();</span>

  private static final int TEXT_VALUE_MAX_LENGTH = 4000;
<span class="fc" id="L57">  private static final Optional&lt;String&gt; OPTIONAL_OF_EMPTY_STRING = Optional.of(&quot;&quot;);</span>

  private final System2 system2;
  private final AuditPersister auditPersister;

<span class="fc" id="L62">  public InternalPropertiesDao(System2 system2, AuditPersister auditPersister) {</span>
<span class="fc" id="L63">    this.system2 = system2;</span>
<span class="fc" id="L64">    this.auditPersister = auditPersister;</span>
<span class="fc" id="L65">  }</span>

  /**
   * Save a property which value is not empty.
   * &lt;p&gt;Value can't be {@code null} but can have any size except 0.&lt;/p&gt;
   *
   * @throws IllegalArgumentException if {@code key} or {@code value} is {@code null} or empty.
   *
   * @see #saveAsEmpty(DbSession, String)
   */
  public void save(DbSession dbSession, String key, String value) {
<span class="fc" id="L76">    checkKey(key);</span>
<span class="fc bfc" id="L77" title="All 4 branches covered.">    checkArgument(value != null &amp;&amp; !value.isEmpty(), &quot;value can't be null nor empty&quot;);</span>

<span class="fc" id="L79">    InternalPropertiesMapper mapper = getMapper(dbSession);</span>
<span class="fc" id="L80">    int deletedRows = mapper.deleteByKey(key);</span>
<span class="fc" id="L81">    long now = system2.now();</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">    if (mustsBeStoredInClob(value)) {</span>
<span class="fc" id="L83">      mapper.insertAsClob(key, value, now);</span>
    } else {
<span class="fc" id="L85">      mapper.insertAsText(key, value, now);</span>
    }

<span class="fc bfc" id="L88" title="All 2 branches covered.">    if (auditPersister.isTrackedProperty(key)) {</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">      if (deletedRows &gt; 0) {</span>
<span class="fc" id="L90">        auditPersister.updateProperty(dbSession, new PropertyNewValue(key, value), false);</span>
      } else {
<span class="fc" id="L92">        auditPersister.addProperty(dbSession, new PropertyNewValue(key, value), false);</span>
      }
    }
<span class="fc" id="L95">  }</span>

  private static boolean mustsBeStoredInClob(String value) {
<span class="fc bfc" id="L98" title="All 2 branches covered.">    return value.length() &gt; TEXT_VALUE_MAX_LENGTH;</span>
  }

  /**
   * Save a property which value is empty.
   */
  public void saveAsEmpty(DbSession dbSession, String key) {
<span class="fc" id="L105">    checkKey(key);</span>

<span class="fc" id="L107">    InternalPropertiesMapper mapper = getMapper(dbSession);</span>
<span class="fc" id="L108">    int deletedRows = mapper.deleteByKey(key);</span>
<span class="fc" id="L109">    mapper.insertAsEmpty(key, system2.now());</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">    if (auditPersister.isTrackedProperty(key)) {</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">      if (deletedRows &gt; 0) {</span>
<span class="fc" id="L113">        auditPersister.updateProperty(dbSession, new PropertyNewValue(key, &quot;&quot;), false);</span>
      } else {
<span class="fc" id="L115">        auditPersister.addProperty(dbSession, new PropertyNewValue(key, &quot;&quot;), false);</span>
      }
    }
<span class="fc" id="L118">  }</span>

  public void delete(DbSession dbSession, String key) {
<span class="fc" id="L121">    int deletedRows = getMapper(dbSession).deleteByKey(key);</span>

<span class="fc bfc" id="L123" title="All 4 branches covered.">    if (deletedRows &gt; 0 &amp;&amp; auditPersister.isTrackedProperty(key)) {</span>
<span class="fc" id="L124">      auditPersister.deleteProperty(dbSession, new PropertyNewValue(key), false);</span>
    }
<span class="fc" id="L126">  }</span>

  /**
   * @return a Map with an {link Optional&lt;String&gt;} for each String in {@code keys}.
   */
  public Map&lt;String, Optional&lt;String&gt;&gt; selectByKeys(DbSession dbSession, @Nullable Set&lt;String&gt; keys) {
<span class="fc bfc" id="L132" title="All 4 branches covered.">    if (keys == null || keys.isEmpty()) {</span>
<span class="fc" id="L133">      return Collections.emptyMap();</span>
    }
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">    if (keys.size() == 1) {</span>
<span class="nc" id="L136">      String key = keys.iterator().next();</span>
<span class="nc" id="L137">      return ImmutableMap.of(key, selectByKey(dbSession, key));</span>
    }
<span class="fc" id="L139">    keys.forEach(InternalPropertiesDao::checkKey);</span>

<span class="fc" id="L141">    InternalPropertiesMapper mapper = getMapper(dbSession);</span>
<span class="fc" id="L142">    List&lt;InternalPropertyDto&gt; res = mapper.selectAsText(ImmutableList.copyOf(keys));</span>
<span class="fc" id="L143">    Map&lt;String, Optional&lt;String&gt;&gt; builder = new HashMap&lt;&gt;(keys.size());</span>
<span class="fc" id="L144">    res.forEach(internalPropertyDto -&gt; {</span>
<span class="fc" id="L145">      String key = internalPropertyDto.getKey();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">      if (internalPropertyDto.isEmpty()) {</span>
<span class="fc" id="L147">        builder.put(key, OPTIONAL_OF_EMPTY_STRING);</span>
      }
<span class="fc bfc" id="L149" title="All 2 branches covered.">      if (internalPropertyDto.getValue() != null) {</span>
<span class="fc" id="L150">        builder.put(key, Optional.of(internalPropertyDto.getValue()));</span>
      }
<span class="fc" id="L152">    });</span>
    // return Optional.empty() for all keys without a DB entry
<span class="fc" id="L154">    Sets.difference(keys, res.stream().map(InternalPropertyDto::getKey).collect(Collectors.toSet()))</span>
<span class="fc" id="L155">      .forEach(key -&gt; builder.put(key, Optional.empty()));</span>
    // keys for which there isn't a text or empty value found yet
<span class="fc" id="L157">    List&lt;String&gt; keyWithClobValue = ImmutableList.copyOf(Sets.difference(keys, builder.keySet()));</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">    if (keyWithClobValue.isEmpty()) {</span>
<span class="fc" id="L159">      return ImmutableMap.copyOf(builder);</span>
    }

    // retrieve properties with a clob value
<span class="fc" id="L163">    res = mapper.selectAsClob(keyWithClobValue);</span>
<span class="fc" id="L164">    res.forEach(internalPropertyDto -&gt; builder.put(internalPropertyDto.getKey(), Optional.of(internalPropertyDto.getValue())));</span>

    // return Optional.empty() for all key with a DB entry which neither has text value, nor is empty nor has clob value
<span class="pc" id="L167">    Sets.difference(ImmutableSet.copyOf(keyWithClobValue), builder.keySet()).forEach(key -&gt; builder.put(key, Optional.empty()));</span>

<span class="fc" id="L169">    return ImmutableMap.copyOf(builder);</span>
  }

  /**
   * No streaming of value
   */
  public Optional&lt;String&gt; selectByKey(DbSession dbSession, String key) {
<span class="fc" id="L176">    checkKey(key);</span>

<span class="fc" id="L178">    InternalPropertiesMapper mapper = getMapper(dbSession);</span>
<span class="fc" id="L179">    InternalPropertyDto res = enforceSingleElement(key, mapper.selectAsText(singletonList(key)));</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">    if (res == null) {</span>
<span class="fc" id="L181">      return Optional.empty();</span>
    }
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (res.isEmpty()) {</span>
<span class="fc" id="L184">      return OPTIONAL_OF_EMPTY_STRING;</span>
    }
<span class="fc bfc" id="L186" title="All 2 branches covered.">    if (res.getValue() != null) {</span>
<span class="fc" id="L187">      return Optional.of(res.getValue());</span>
    }
<span class="fc" id="L189">    res = enforceSingleElement(key, mapper.selectAsClob(singletonList(key)));</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">    if (res == null) {</span>
<span class="nc" id="L191">      LoggerFactory.getLogger(InternalPropertiesDao.class)</span>
<span class="nc" id="L192">        .debug(&quot;Internal property {} has been found in db but has neither text value nor is empty. &quot; +</span>
          &quot;Still it couldn't be retrieved with clob value. Ignoring the property.&quot;, key);
<span class="nc" id="L194">      return Optional.empty();</span>
    }
<span class="fc" id="L196">    return Optional.of(res.getValue());</span>
  }

  @CheckForNull
  private static InternalPropertyDto enforceSingleElement(String key, List&lt;InternalPropertyDto&gt; rows) {
<span class="fc bfc" id="L201" title="All 2 branches covered.">    if (rows.isEmpty()) {</span>
<span class="fc" id="L202">      return null;</span>
    }
<span class="fc" id="L204">    int size = rows.size();</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    checkState(size &lt;= 1, &quot;%s rows retrieved for single property %s&quot;, size, key);</span>
<span class="fc" id="L206">    return rows.iterator().next();</span>
  }

  /**
   * Try to acquire a lock with the specified name, for specified duration.
   *
   * Returns false if the lock exists with a timestamp &gt; now - duration,
   * or if the atomic replacement of the timestamp fails (another process replaced first).
   *
   * Returns true if the lock does not exist, or if exists with a timestamp &lt;= now - duration,
   * and the atomic replacement of the timestamp succeeds.
   *
   * The lock is considered released when the specified duration has elapsed.
   *
   * @throws IllegalArgumentException if name's length is &gt; {@link #LOCK_NAME_MAX_LENGTH}
   * @throws IllegalArgumentException if maxAgeInSeconds is &lt;= 0
   */
  public boolean tryLock(DbSession dbSession, String name, int maxAgeInSeconds) {
<span class="fc bfc" id="L224" title="All 2 branches covered.">    if (name.isEmpty()) {</span>
<span class="fc" id="L225">      throw new IllegalArgumentException(&quot;lock name can't be empty&quot;);</span>
    }
<span class="fc bfc" id="L227" title="All 2 branches covered.">    if (name.length() &gt; LOCK_NAME_MAX_LENGTH) {</span>
<span class="fc" id="L228">      throw new IllegalArgumentException(&quot;lock name is too long&quot;);</span>
    }
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">    if (maxAgeInSeconds &lt;= 0) {</span>
<span class="nc" id="L231">      throw new IllegalArgumentException(&quot;maxAgeInSeconds must be &gt; 0&quot;);</span>
    }

<span class="fc" id="L234">    String key = LOCK_PREFIX + name;</span>
<span class="fc" id="L235">    long now = system2.now();</span>

<span class="fc" id="L237">    Optional&lt;String&gt; timestampAsStringOpt = selectByKey(dbSession, key);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">    if (!timestampAsStringOpt.isPresent()) {</span>
<span class="fc" id="L239">      return tryCreateLock(dbSession, key, String.valueOf(now));</span>
    }

<span class="fc" id="L242">    String oldTimestampString = timestampAsStringOpt.get();</span>
<span class="fc" id="L243">    long oldTimestamp = Long.parseLong(oldTimestampString);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">    if (oldTimestamp &gt; now - maxAgeInSeconds * 1000) {</span>
<span class="fc" id="L245">      return false;</span>
    }

<span class="fc bfc" id="L248" title="All 2 branches covered.">    return getMapper(dbSession).replaceValue(key, oldTimestampString, String.valueOf(now)) == 1;</span>
  }

  private boolean tryCreateLock(DbSession dbSession, String name, String value) {
    try {
<span class="fc" id="L253">      getMapper(dbSession).insertAsText(name, value, system2.now());</span>
<span class="fc" id="L254">      return true;</span>
<span class="fc" id="L255">    } catch (Exception ignored) {</span>
<span class="fc" id="L256">      return false;</span>
    }
  }

  private static void checkKey(@Nullable String key) {
<span class="fc bfc" id="L261" title="All 4 branches covered.">    checkArgument(key != null &amp;&amp; !key.isEmpty(), &quot;key can't be null nor empty&quot;);</span>
<span class="fc" id="L262">  }</span>

  private static InternalPropertiesMapper getMapper(DbSession dbSession) {
<span class="fc" id="L265">    return dbSession.getMapper(InternalPropertiesMapper.class);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>