<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PersistMeasuresStep.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.ce.task.projectanalysis.step</a> &gt; <span class="el_source">PersistMeasuresStep.java</span></div><h1>PersistMeasuresStep.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.ce.task.projectanalysis.step;

import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.ce.task.log.CeTaskMessages;
import org.sonar.ce.task.projectanalysis.component.Component;
import org.sonar.ce.task.projectanalysis.component.Component.Type;
import org.sonar.ce.task.projectanalysis.component.CrawlerDepthLimit;
import org.sonar.ce.task.projectanalysis.component.DepthTraversalTypeAwareCrawler;
import org.sonar.ce.task.projectanalysis.component.TreeRootHolder;
import org.sonar.ce.task.projectanalysis.component.TypeAwareVisitorAdapter;
import org.sonar.ce.task.projectanalysis.duplication.ComputeDuplicationDataMeasure;
import org.sonar.ce.task.projectanalysis.measure.BestValueOptimization;
import org.sonar.ce.task.projectanalysis.measure.Measure;
import org.sonar.ce.task.projectanalysis.measure.MeasureRepository;
import org.sonar.ce.task.projectanalysis.measure.MeasureToMeasureDto;
import org.sonar.ce.task.projectanalysis.measure.ValueType;
import org.sonar.ce.task.projectanalysis.metric.Metric;
import org.sonar.ce.task.projectanalysis.metric.MetricRepository;
import org.sonar.ce.task.step.ComputationStep;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.measure.MeasureDto;
import org.sonar.db.measure.MeasureHash;
import org.springframework.beans.factory.annotation.Autowired;

import static org.sonar.api.measures.CoreMetrics.DUPLICATIONS_DATA_KEY;
import static org.sonar.api.measures.CoreMetrics.EXECUTABLE_LINES_DATA_KEY;
import static org.sonar.api.measures.CoreMetrics.NCLOC_DATA_KEY;
import static org.sonar.api.measures.CoreMetrics.QUALITY_GATE_DETAILS_KEY;
import static org.sonar.api.measures.CoreMetrics.QUALITY_PROFILES_KEY;
import static org.sonar.ce.task.projectanalysis.component.ComponentVisitor.Order.PRE_ORDER;

public class PersistMeasuresStep implements ComputationStep {

<span class="fc" id="L66">  private static final Logger LOGGER = LoggerFactory.getLogger(PersistMeasuresStep.class);</span>

  // 50 mb
  private static final int MAX_TRANSACTION_SIZE = 50_000_000;
<span class="fc" id="L70">  private static final Predicate&lt;Measure&gt; NON_EMPTY_MEASURE = measure -&gt;</span>
<span class="pc bpc" id="L71" title="1 of 4 branches missed.">    measure.getValueType() != ValueType.NO_VALUE || measure.getData() != null;</span>

  /**
   * List of metrics that should not be persisted
   */
<span class="fc" id="L76">  private static final Set&lt;String&gt; NOT_TO_PERSIST = Set.of(</span>
    EXECUTABLE_LINES_DATA_KEY,
    NCLOC_DATA_KEY);

<span class="fc" id="L80">  private static final Set&lt;String&gt; CORE_METRICS_WITH_LARGE_VALUES = Set.of(</span>
    DUPLICATIONS_DATA_KEY,
    QUALITY_PROFILES_KEY,
    QUALITY_GATE_DETAILS_KEY
  );

  private final DbClient dbClient;
  private final MetricRepository metricRepository;
  private final TreeRootHolder treeRootHolder;
  private final MeasureRepository measureRepository;
  private final ComputeDuplicationDataMeasure computeDuplicationDataMeasure;
  private final int maxTransactionSize;
  private final CeTaskMessages ceTaskMessages;

  @Autowired
  public PersistMeasuresStep(DbClient dbClient, MetricRepository metricRepository, TreeRootHolder treeRootHolder,
    MeasureRepository measureRepository, @Nullable ComputeDuplicationDataMeasure computeDuplicationDataMeasure,
    @Nullable CeTaskMessages ceTaskMessages) {
<span class="fc" id="L98">    this(dbClient, metricRepository, treeRootHolder, measureRepository, computeDuplicationDataMeasure, MAX_TRANSACTION_SIZE,</span>
      ceTaskMessages);
<span class="fc" id="L100">  }</span>

  PersistMeasuresStep(DbClient dbClient, MetricRepository metricRepository, TreeRootHolder treeRootHolder,
    MeasureRepository measureRepository, @Nullable ComputeDuplicationDataMeasure computeDuplicationDataMeasure, int maxTransactionSize,
<span class="fc" id="L104">    @Nullable CeTaskMessages ceTaskMessages) {</span>
<span class="fc" id="L105">    this.dbClient = dbClient;</span>
<span class="fc" id="L106">    this.metricRepository = metricRepository;</span>
<span class="fc" id="L107">    this.treeRootHolder = treeRootHolder;</span>
<span class="fc" id="L108">    this.measureRepository = measureRepository;</span>
<span class="fc" id="L109">    this.computeDuplicationDataMeasure = computeDuplicationDataMeasure;</span>
<span class="fc" id="L110">    this.maxTransactionSize = maxTransactionSize;</span>
<span class="fc" id="L111">    this.ceTaskMessages = ceTaskMessages;</span>
<span class="fc" id="L112">  }</span>

  @Override
  public String getDescription() {
<span class="fc" id="L116">    return &quot;Persist measures&quot;;</span>
  }

  @Override
  public void execute(ComputationStep.Context context) {
<span class="fc" id="L121">    Component root = treeRootHolder.getRoot();</span>
<span class="fc" id="L122">    CollectComponentsVisitor visitor = new CollectComponentsVisitor();</span>
<span class="fc" id="L123">    new DepthTraversalTypeAwareCrawler(visitor).visit(root);</span>

<span class="fc" id="L125">    Set&lt;MeasureHash&gt; dbMeasureHashes = getDBMeasureHashes();</span>
<span class="fc" id="L126">    Set&lt;String&gt; dbComponents = dbMeasureHashes.stream().map(MeasureHash::componentUuid).collect(Collectors.toSet());</span>

<span class="fc" id="L128">    List&lt;MeasureDto&gt; inserts = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L129">    List&lt;MeasureDto&gt; updates = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L130">    Set&lt;String&gt; largeValueMetrics = new HashSet&lt;&gt;();</span>
<span class="fc" id="L131">    int insertsOrUpdates = 0;</span>
<span class="fc" id="L132">    int unchanged = 0;</span>
<span class="fc" id="L133">    int size = 0;</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">    for (Component component : visitor.components) {</span>
<span class="fc" id="L136">      MeasureDto measure = createMeasure(component, largeValueMetrics);</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">      if (dbMeasureHashes.contains(new MeasureHash(measure.getComponentUuid(), measure.computeJsonValueHash()))) {</span>
<span class="fc" id="L139">        unchanged += measure.getMetricValues().size();</span>
      } else {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (dbComponents.contains(measure.getComponentUuid())) {</span>
<span class="fc" id="L142">          updates.add(measure);</span>
        } else {
<span class="fc" id="L144">          inserts.add(measure);</span>
        }
<span class="fc" id="L146">        size += measure.getJsonValue().length();</span>
<span class="fc" id="L147">        insertsOrUpdates += measure.getMetricValues().size();</span>
      }

<span class="fc bfc" id="L150" title="All 2 branches covered.">      if (size &gt; maxTransactionSize) {</span>
<span class="fc" id="L151">        persist(inserts, updates);</span>
<span class="fc" id="L152">        inserts.clear();</span>
<span class="fc" id="L153">        updates.clear();</span>
<span class="fc" id="L154">        size = 0;</span>
      }
<span class="fc" id="L156">    }</span>
<span class="fc" id="L157">    persist(inserts, updates);</span>

<span class="fc" id="L159">    addLargeValueMetricsWarning(largeValueMetrics);</span>
<span class="fc" id="L160">    context.getStatistics()</span>
<span class="fc" id="L161">      .add(&quot;insertsOrUpdates&quot;, insertsOrUpdates)</span>
<span class="fc" id="L162">      .add(&quot;unchanged&quot;, unchanged);</span>
<span class="fc" id="L163">  }</span>

  private Set&lt;MeasureHash&gt; getDBMeasureHashes() {
<span class="fc" id="L166">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L167">      return dbClient.measureDao().selectMeasureHashesForBranch(dbSession, treeRootHolder.getRoot().getUuid());</span>
    }
  }

  private MeasureDto createMeasure(Component component, Set&lt;String&gt; largeValueMetrics) {
<span class="fc" id="L172">    MeasureDto measureDto = new MeasureDto();</span>
<span class="fc" id="L173">    measureDto.setComponentUuid(component.getUuid());</span>
<span class="fc" id="L174">    measureDto.setBranchUuid(treeRootHolder.getRoot().getUuid());</span>

<span class="fc" id="L176">    Map&lt;String, Measure&gt; measures = measureRepository.getRawMeasures(component);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">    for (Map.Entry&lt;String, Measure&gt; measuresByMetricKey : measures.entrySet()) {</span>
<span class="fc" id="L178">      String metricKey = measuresByMetricKey.getKey();</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">      if (shouldNotPersist(metricKey)) {</span>
<span class="fc" id="L180">        continue;</span>
      }
<span class="fc" id="L182">      Metric metric = metricRepository.getByKey(metricKey);</span>
<span class="fc" id="L183">      Predicate&lt;Measure&gt; notBestValueOptimized = BestValueOptimization.from(metric, component).negate();</span>
<span class="fc" id="L184">      Measure measure = measuresByMetricKey.getValue();</span>
<span class="fc" id="L185">      Stream.of(measure)</span>
<span class="fc" id="L186">        .filter(NON_EMPTY_MEASURE)</span>
<span class="fc" id="L187">        .filter(notBestValueOptimized)</span>
<span class="fc" id="L188">        .map(MeasureToMeasureDto::getMeasureValue)</span>
<span class="fc" id="L189">        .filter(Objects::nonNull)</span>
<span class="fc" id="L190">        .forEach(value -&gt;  {</span>
<span class="fc" id="L191">          checkValueLength(value, metricKey, component, largeValueMetrics);</span>
<span class="fc" id="L192">          measureDto.addValue(metric.getKey(), value);</span>
<span class="fc" id="L193">        });</span>
<span class="fc" id="L194">    }</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">    if (component.getType() == Type.FILE) {</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">      if (computeDuplicationDataMeasure == null) {</span>
<span class="nc" id="L198">        throw new IllegalStateException(&quot;ComputeDuplicationDataMeasure not initialized in container&quot;);</span>
      }
<span class="fc" id="L200">      computeDuplicationDataMeasure.compute(component)</span>
<span class="pc" id="L201">        .ifPresent(duplicationData -&gt; measureDto.addValue(DUPLICATIONS_DATA_KEY, duplicationData));</span>
    }

<span class="fc" id="L204">    return measureDto;</span>
  }

  private static void checkValueLength(Object value, String metricKey, Component component, Set&lt;String&gt; largeValueMetrics) {
<span class="fc bfc" id="L208" title="All 2 branches covered.">    if (value instanceof String strValue) {</span>
<span class="fc" id="L209">      int valueLength = strValue.length();</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">      if (valueLength &gt; 100_000) {</span>
<span class="fc" id="L211">        LOGGER.debug(&quot;Measure with large value persisted: metricKey={}, valueLength={}, componentKey={}, componentUuid={}&quot;,</span>
<span class="fc" id="L212">          metricKey, valueLength, component.getKey(), component.getUuid());</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (!CORE_METRICS_WITH_LARGE_VALUES.contains(metricKey)) {</span>
<span class="fc" id="L214">          largeValueMetrics.add(metricKey);</span>
        }
      }
    }
<span class="fc" id="L218">  }</span>

  private void addLargeValueMetricsWarning(Set&lt;String&gt; largeValueMetrics) {
<span class="fc bfc" id="L221" title="All 2 branches covered.">    if (!largeValueMetrics.isEmpty()) {</span>
<span class="fc" id="L222">      String warningMessage = String.format(&quot;A plugin is storing excessively large data in the following measure(s): %s. This &quot; +</span>
          &quot;is likely to cause significant SonarQube performance degradation and UI slowness. It is recommended to contact your &quot; +
          &quot;administrator to disable the plugin or corresponding feature and reach out to the plugin maintainer for further assistance.&quot;,
<span class="fc" id="L225">        largeValueMetrics.stream().map(metric -&gt; String.format(&quot;'%s'&quot;, metric)).collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="fc" id="L226">      LOGGER.warn(warningMessage);</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">      if (ceTaskMessages != null) {</span>
<span class="fc" id="L228">        ceTaskMessages.add(new CeTaskMessages.Message(warningMessage, System.currentTimeMillis()));</span>
      }
    }
<span class="fc" id="L231">  }</span>

  private static boolean shouldNotPersist(String metricKey) {
<span class="fc" id="L234">    return NOT_TO_PERSIST.contains(metricKey);</span>
  }

  private void persist(Collection&lt;MeasureDto&gt; inserts, Collection&lt;MeasureDto&gt; updates) {
<span class="pc bpc" id="L238" title="1 of 4 branches missed.">    if (inserts.isEmpty() &amp;&amp; updates.isEmpty()) {</span>
<span class="fc" id="L239">      return;</span>
    }
<span class="fc" id="L241">    try (DbSession dbSession = dbClient.openSession(true)) {</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">      for (MeasureDto m : inserts) {</span>
<span class="fc" id="L243">        dbClient.measureDao().insert(dbSession, m);</span>
<span class="fc" id="L244">      }</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">      for (MeasureDto m : updates) {</span>
<span class="fc" id="L246">        dbClient.measureDao().update(dbSession, m);</span>
<span class="fc" id="L247">      }</span>
<span class="fc" id="L248">      dbSession.commit();</span>
    }
<span class="fc" id="L250">  }</span>

  private static class CollectComponentsVisitor extends TypeAwareVisitorAdapter {
<span class="fc" id="L253">    private final List&lt;Component&gt; components = new LinkedList&lt;&gt;();</span>

    private CollectComponentsVisitor() {
<span class="fc" id="L256">      super(CrawlerDepthLimit.LEAVES, PRE_ORDER);</span>
<span class="fc" id="L257">    }</span>

    @Override
    public void visitAny(Component component) {
<span class="fc" id="L261">      components.add(component);</span>
<span class="fc" id="L262">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>