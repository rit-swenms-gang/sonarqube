<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QProfileParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.qualityprofile</a> &gt; <span class="el_source">QProfileParser.java</span></div><h1>QProfileParser.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.qualityprofile;

import java.io.Reader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamException;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.staxmate.SMInputFactory;
import org.codehaus.staxmate.in.SMHierarchicCursor;
import org.codehaus.staxmate.in.SMInputCursor;
import org.sonar.api.issue.impact.Severity;
import org.sonar.api.issue.impact.SoftwareQuality;
import org.sonar.api.rule.RuleKey;
import org.sonar.api.server.ServerSide;
import org.sonar.api.utils.text.XmlWriter;
import org.sonar.db.qualityprofile.ExportRuleDto;
import org.sonar.db.qualityprofile.ExportRuleParamDto;
import org.sonar.db.qualityprofile.QProfileDto;

import static org.sonar.server.qualityprofile.QProfileUtils.parseImpactsToMap;

@ServerSide
<span class="fc" id="L52">public class QProfileParser {</span>
  private static final String ATTRIBUTE_PROFILE = &quot;profile&quot;;
  private static final String ATTRIBUTE_NAME = &quot;name&quot;;
  private static final String ATTRIBUTE_LANGUAGE = &quot;language&quot;;
  private static final String ATTRIBUTE_RULES = &quot;rules&quot;;
  private static final String ATTRIBUTE_RULE = &quot;rule&quot;;
  private static final String ATTRIBUTE_REPOSITORY_KEY = &quot;repositoryKey&quot;;
  private static final String ATTRIBUTE_KEY = &quot;key&quot;;
  private static final String ATTRIBUTE_PRIORITY = &quot;priority&quot;;
  private static final String ATTRIBUTE_IMPACTS = &quot;impacts&quot;;
  private static final String ATTRIBUTE_IMPACT = &quot;impact&quot;;
  private static final String ATTRIBUTE_SEVERITY = &quot;severity&quot;;
  private static final String ATTRIBUTE_SOFTWARE_QUALITY = &quot;softwareQuality&quot;;
  private static final String ATTRIBUTE_PRIORITIZED_RULE = &quot;prioritizedRule&quot;;
  private static final String ATTRIBUTE_TEMPLATE_KEY = &quot;templateKey&quot;;
  private static final String ATTRIBUTE_TYPE = &quot;type&quot;;
  private static final String ATTRIBUTE_DESCRIPTION = &quot;description&quot;;
  private static final String ATTRIBUTE_CLEAN_CODE_ATTRIBUTE = &quot;cleanCodeAttribute&quot;;

  private static final String ATTRIBUTE_PARAMETERS = &quot;parameters&quot;;
  private static final String ATTRIBUTE_PARAMETER = &quot;parameter&quot;;
  private static final String ATTRIBUTE_PARAMETER_KEY = &quot;key&quot;;
  private static final String ATTRIBUTE_PARAMETER_VALUE = &quot;value&quot;;

  public void writeXml(Writer writer, QProfileDto profile, Iterator&lt;ExportRuleDto&gt; rulesToExport) {
<span class="fc" id="L77">    XmlWriter xml = XmlWriter.of(writer).declaration();</span>
<span class="fc" id="L78">    xml.begin(ATTRIBUTE_PROFILE);</span>
<span class="fc" id="L79">    xml.prop(ATTRIBUTE_NAME, profile.getName());</span>
<span class="fc" id="L80">    xml.prop(ATTRIBUTE_LANGUAGE, profile.getLanguage());</span>
<span class="fc" id="L81">    xml.begin(ATTRIBUTE_RULES);</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">    while (rulesToExport.hasNext()) {</span>
<span class="fc" id="L83">      ExportRuleDto ruleToExport = rulesToExport.next();</span>
<span class="fc" id="L84">      xml.begin(ATTRIBUTE_RULE);</span>
<span class="fc" id="L85">      xml.prop(ATTRIBUTE_REPOSITORY_KEY, ruleToExport.getRuleKey().repository());</span>
<span class="fc" id="L86">      xml.prop(ATTRIBUTE_KEY, ruleToExport.getRuleKey().rule());</span>
<span class="fc" id="L87">      xml.prop(ATTRIBUTE_TYPE, ruleToExport.getRuleType().name());</span>
<span class="fc" id="L88">      xml.prop(ATTRIBUTE_PRIORITY, ruleToExport.getSeverityString());</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">      if (StringUtils.isNotEmpty(ruleToExport.getImpacts())) {</span>
<span class="fc" id="L90">        xml.begin(ATTRIBUTE_IMPACTS);</span>
<span class="fc" id="L91">        parseImpactsToMap(ruleToExport.getImpacts()).forEach((quality, severity) -&gt; {</span>
<span class="fc" id="L92">          xml.begin(ATTRIBUTE_IMPACT);</span>
<span class="fc" id="L93">          xml.prop(ATTRIBUTE_SOFTWARE_QUALITY, quality.name());</span>
<span class="fc" id="L94">          xml.prop(ATTRIBUTE_SEVERITY, severity.name());</span>
<span class="fc" id="L95">          xml.end();</span>
<span class="fc" id="L96">        });</span>
<span class="fc" id="L97">        xml.end();</span>
      }
<span class="fc bfc" id="L99" title="All 2 branches covered.">      if (Boolean.TRUE.equals(ruleToExport.getPrioritizedRule())) {</span>
<span class="fc" id="L100">        xml.prop(ATTRIBUTE_PRIORITIZED_RULE, ruleToExport.getPrioritizedRule());</span>
      }

<span class="fc bfc" id="L103" title="All 2 branches covered.">      if (ruleToExport.isCustomRule()) {</span>
<span class="fc" id="L104">        xml.prop(ATTRIBUTE_NAME, ruleToExport.getName());</span>
<span class="fc" id="L105">        xml.prop(ATTRIBUTE_TEMPLATE_KEY, ruleToExport.getTemplateRuleKey().rule());</span>
<span class="fc" id="L106">        xml.prop(ATTRIBUTE_DESCRIPTION, ruleToExport.getDescriptionOrThrow());</span>
<span class="fc" id="L107">        xml.prop(ATTRIBUTE_CLEAN_CODE_ATTRIBUTE, ruleToExport.getCleanCodeAttribute());</span>
      }

<span class="fc" id="L110">      xml.begin(ATTRIBUTE_PARAMETERS);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">      for (ExportRuleParamDto param : ruleToExport.getParams()) {</span>
<span class="fc" id="L112">        xml</span>
<span class="fc" id="L113">          .begin(ATTRIBUTE_PARAMETER)</span>
<span class="fc" id="L114">          .prop(ATTRIBUTE_PARAMETER_KEY, param.getKey())</span>
<span class="fc" id="L115">          .prop(ATTRIBUTE_PARAMETER_VALUE, param.getValue())</span>
<span class="fc" id="L116">          .end();</span>
<span class="fc" id="L117">      }</span>
<span class="fc" id="L118">      xml.end(ATTRIBUTE_PARAMETERS);</span>
<span class="fc" id="L119">      xml.end(ATTRIBUTE_RULE);</span>
<span class="fc" id="L120">    }</span>
<span class="fc" id="L121">    xml.end(ATTRIBUTE_RULES).end(ATTRIBUTE_PROFILE).close();</span>
<span class="fc" id="L122">  }</span>

  public ImportedQProfile readXml(Reader reader) {
<span class="fc" id="L125">    List&lt;ImportedRule&gt; rules = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L126">    String profileName = null;</span>
<span class="fc" id="L127">    String profileLang = null;</span>
    try {
<span class="fc" id="L129">      SMInputFactory inputFactory = initStax();</span>
<span class="fc" id="L130">      SMHierarchicCursor rootC = inputFactory.rootElementCursor(reader);</span>
<span class="fc" id="L131">      rootC.advance(); // &lt;profile&gt;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">      if (!ATTRIBUTE_PROFILE.equals(rootC.getLocalName())) {</span>
<span class="fc" id="L133">        throw new IllegalArgumentException(&quot;Backup XML is not valid. Root element must be &lt;profile&gt;.&quot;);</span>
      }
<span class="fc" id="L135">      SMInputCursor cursor = rootC.childElementCursor();</span>

<span class="fc bfc" id="L137" title="All 2 branches covered.">      while (cursor.getNext() != null) {</span>
<span class="fc" id="L138">        String nodeName = cursor.getLocalName();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (StringUtils.equals(ATTRIBUTE_NAME, nodeName)) {</span>
<span class="fc" id="L140">          profileName = StringUtils.trim(cursor.collectDescendantText(false));</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        } else if (StringUtils.equals(ATTRIBUTE_LANGUAGE, nodeName)) {</span>
<span class="fc" id="L142">          profileLang = StringUtils.trim(cursor.collectDescendantText(false));</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        } else if (StringUtils.equals(ATTRIBUTE_RULES, nodeName)) {</span>
<span class="fc" id="L144">          SMInputCursor rulesCursor = cursor.childElementCursor(&quot;rule&quot;);</span>
<span class="fc" id="L145">          rules = parseRuleActivations(rulesCursor);</span>
        }
<span class="fc" id="L147">      }</span>
<span class="fc" id="L148">    } catch (XMLStreamException e) {</span>
<span class="fc" id="L149">      throw new IllegalArgumentException(&quot;Fail to restore Quality profile backup, XML document is not well formed&quot;, e);</span>
<span class="fc" id="L150">    }</span>
<span class="fc" id="L151">    return new ImportedQProfile(profileName, profileLang, rules);</span>
  }

  private static SMInputFactory initStax() {
<span class="fc" id="L155">    XMLInputFactory xmlFactory = XMLInputFactory.newInstance();</span>
<span class="fc" id="L156">    xmlFactory.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);</span>
<span class="fc" id="L157">    xmlFactory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, Boolean.FALSE);</span>
    // just so it won't try to load DTD in if there's DOCTYPE
<span class="fc" id="L159">    xmlFactory.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);</span>
<span class="fc" id="L160">    xmlFactory.setProperty(XMLInputFactory.IS_VALIDATING, Boolean.FALSE);</span>
<span class="fc" id="L161">    return new SMInputFactory(xmlFactory);</span>
  }

  private static List&lt;ImportedRule&gt; parseRuleActivations(SMInputCursor rulesCursor) throws XMLStreamException {
<span class="fc" id="L165">    List&lt;ImportedRule&gt; activations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L166">    Set&lt;RuleKey&gt; activatedKeys = new HashSet&lt;&gt;();</span>
<span class="fc" id="L167">    List&lt;RuleKey&gt; duplicatedKeys = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">    while (rulesCursor.getNext() != null) {</span>
<span class="fc" id="L169">      SMInputCursor ruleCursor = rulesCursor.childElementCursor();</span>
<span class="fc" id="L170">      Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();</span>
<span class="fc" id="L171">      ImportedRule rule = new ImportedRule();</span>
<span class="fc" id="L172">      readRule(ruleCursor, parameters, rule);</span>

<span class="fc" id="L174">      var ruleKey = rule.getRuleKey();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      if (activatedKeys.contains(ruleKey)) {</span>
<span class="fc" id="L176">        duplicatedKeys.add(ruleKey);</span>
      }
<span class="fc" id="L178">      activatedKeys.add(ruleKey);</span>
<span class="fc" id="L179">      activations.add(rule);</span>
<span class="fc" id="L180">    }</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">    if (!duplicatedKeys.isEmpty()) {</span>
<span class="fc" id="L182">      throw new IllegalArgumentException(&quot;The quality profile cannot be restored as it contains duplicates for the following rules: &quot; +</span>
<span class="fc" id="L183">        duplicatedKeys.stream().map(RuleKey::toString).filter(Objects::nonNull).collect(Collectors.joining(&quot;, &quot;)));</span>
    }
<span class="fc" id="L185">    return activations;</span>
  }

  private static void readRule(SMInputCursor ruleCursor, Map&lt;String, String&gt; parameters, ImportedRule rule) throws XMLStreamException {
<span class="fc bfc" id="L189" title="All 2 branches covered.">    while (ruleCursor.getNext() != null) {</span>
<span class="fc" id="L190">      String nodeName = ruleCursor.getLocalName();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">      if (StringUtils.equals(ATTRIBUTE_REPOSITORY_KEY, nodeName)) {</span>
<span class="fc" id="L192">        rule.setRepository(StringUtils.trim(ruleCursor.collectDescendantText(false)));</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_KEY, nodeName)) {</span>
<span class="fc" id="L194">        rule.setKey(StringUtils.trim(ruleCursor.collectDescendantText(false)));</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_TEMPLATE_KEY, nodeName)) {</span>
<span class="fc" id="L196">        rule.setTemplate(StringUtils.trim(ruleCursor.collectDescendantText(false)));</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_NAME, nodeName)) {</span>
<span class="fc" id="L198">        rule.setName(StringUtils.trim(ruleCursor.collectDescendantText(false)));</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_TYPE, nodeName)) {</span>
<span class="fc" id="L200">        rule.setType(StringUtils.trim(ruleCursor.collectDescendantText(false)));</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_DESCRIPTION, nodeName)) {</span>
<span class="fc" id="L202">        rule.setDescription(StringUtils.trim(ruleCursor.collectDescendantText(false)));</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_CLEAN_CODE_ATTRIBUTE, nodeName)) {</span>
<span class="fc" id="L204">        rule.setCleanCodeAttribute(StringUtils.trim(ruleCursor.collectDescendantText(false)));</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_PRIORITY, nodeName)) {</span>
<span class="fc" id="L206">        rule.setSeverity(StringUtils.trim(ruleCursor.collectDescendantText(false)));</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_IMPACTS, nodeName)) {</span>
<span class="fc" id="L208">        SMInputCursor impactsCursor = ruleCursor.childElementCursor(ATTRIBUTE_IMPACT);</span>
<span class="fc" id="L209">        Map&lt;SoftwareQuality, Severity&gt; impacts = new EnumMap&lt;&gt;(SoftwareQuality.class);</span>
<span class="fc" id="L210">        readImpacts(impactsCursor, impacts);</span>
<span class="fc" id="L211">        rule.setImpacts(impacts);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">      } else if (StringUtils.equals(ATTRIBUTE_PRIORITIZED_RULE, nodeName)) {</span>
<span class="fc" id="L213">        rule.setPrioritizedRule(Boolean.valueOf(StringUtils.trim(ruleCursor.collectDescendantText(false))));</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">      } else if (StringUtils.equals(ATTRIBUTE_PARAMETERS, nodeName)) {</span>
<span class="fc" id="L215">        SMInputCursor propsCursor = ruleCursor.childElementCursor(ATTRIBUTE_PARAMETER);</span>
<span class="fc" id="L216">        readParameters(propsCursor, parameters);</span>
<span class="fc" id="L217">        rule.setParameters(parameters);</span>
      }
<span class="fc" id="L219">    }</span>
<span class="fc" id="L220">  }</span>

  private static void readParameters(SMInputCursor propsCursor, Map&lt;String, String&gt; parameters) throws XMLStreamException {
<span class="fc bfc" id="L223" title="All 2 branches covered.">    while (propsCursor.getNext() != null) {</span>
<span class="fc" id="L224">      SMInputCursor propCursor = propsCursor.childElementCursor();</span>
<span class="fc" id="L225">      String key = null;</span>
<span class="fc" id="L226">      String value = null;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">      while (propCursor.getNext() != null) {</span>
<span class="fc" id="L228">        String nodeName = propCursor.getLocalName();</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (StringUtils.equals(ATTRIBUTE_PARAMETER_KEY, nodeName)) {</span>
<span class="fc" id="L230">          key = StringUtils.trim(propCursor.collectDescendantText(false));</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        } else if (StringUtils.equals(ATTRIBUTE_PARAMETER_VALUE, nodeName)) {</span>
<span class="fc" id="L232">          value = StringUtils.trim(propCursor.collectDescendantText(false));</span>
        }
<span class="fc" id="L234">      }</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">      if (key != null) {</span>
<span class="fc" id="L236">        parameters.put(key, value);</span>
      }
<span class="fc" id="L238">    }</span>
<span class="fc" id="L239">  }</span>

  private static void readImpacts(SMInputCursor impactsCursor, Map&lt;SoftwareQuality, Severity&gt; impacts) throws XMLStreamException {
<span class="fc bfc" id="L242" title="All 2 branches covered.">    while (impactsCursor.getNext() != null) {</span>
<span class="fc" id="L243">      SMInputCursor impactCursor = impactsCursor.childElementCursor();</span>
<span class="fc" id="L244">      SoftwareQuality softwareQuality = null;</span>
<span class="fc" id="L245">      Severity severity = null;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">      while (impactCursor.getNext() != null) {</span>
<span class="fc" id="L247">        String nodeName = impactCursor.getLocalName();</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (StringUtils.equals(ATTRIBUTE_SOFTWARE_QUALITY, nodeName)) {</span>
<span class="fc" id="L249">          softwareQuality = SoftwareQuality.valueOf(StringUtils.trim(impactCursor.collectDescendantText(false)));</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        } else if (StringUtils.equals(ATTRIBUTE_SEVERITY, nodeName)) {</span>
<span class="fc" id="L251">          severity = Severity.valueOf(StringUtils.trim(impactCursor.collectDescendantText(false)));</span>
        }
<span class="fc" id="L253">      }</span>
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">      if (softwareQuality != null &amp;&amp; severity != null) {</span>
<span class="fc" id="L255">        impacts.put(softwareQuality, severity);</span>
      }
<span class="fc" id="L257">    }</span>
<span class="fc" id="L258">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>