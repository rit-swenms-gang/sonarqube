<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LogLevelConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.process.logging</a> &gt; <span class="el_source">LogLevelConfig.java</span></div><h1>LogLevelConfig.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.process.logging;

import ch.qos.logback.classic.Level;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;
import org.sonar.process.ProcessId;

import static java.util.Objects.requireNonNull;
import static org.sonar.process.ProcessProperties.Property.LOG_LEVEL;

public final class LogLevelConfig {
<span class="fc" id="L37">  private static final String SONAR_LOG_LEVEL_PROPERTY = LOG_LEVEL.getKey();</span>
  private static final String PROCESS_NAME_PLACEHOLDER = &quot;XXXX&quot;;
<span class="fc" id="L39">  private static final String SONAR_PROCESS_LOG_LEVEL_PROPERTY = SONAR_LOG_LEVEL_PROPERTY + &quot;.&quot; + PROCESS_NAME_PLACEHOLDER;</span>

  private final Map&lt;String, List&lt;String&gt;&gt; configuredByProperties;
  private final Map&lt;String, Level&gt; configuredByHardcodedLevel;
  private final Set&lt;String&gt; offUnlessTrace;
  private final String rootLoggerName;

<span class="fc" id="L46">  private LogLevelConfig(Builder builder) {</span>
<span class="fc" id="L47">    this.configuredByProperties = Collections.unmodifiableMap(builder.configuredByProperties);</span>
<span class="fc" id="L48">    this.configuredByHardcodedLevel = Collections.unmodifiableMap(builder.configuredByHardcodedLevel);</span>
<span class="fc" id="L49">    this.offUnlessTrace = Collections.unmodifiableSet(builder.offUnlessTrace);</span>
<span class="fc" id="L50">    this.rootLoggerName = builder.rootLoggerName;</span>
<span class="fc" id="L51">  }</span>

  Map&lt;String, List&lt;String&gt;&gt; getConfiguredByProperties() {
<span class="fc" id="L54">    return configuredByProperties;</span>
  }

  Map&lt;String, Level&gt; getConfiguredByHardcodedLevel() {
<span class="fc" id="L58">    return configuredByHardcodedLevel;</span>
  }

  Set&lt;String&gt; getOffUnlessTrace() {
<span class="fc" id="L62">    return offUnlessTrace;</span>
  }

  String getRootLoggerName() {
<span class="fc" id="L66">    return rootLoggerName;</span>
  }

  public static Builder newBuilder(String rootLoggerName) {
<span class="fc" id="L70">    return new Builder(rootLoggerName);</span>
  }

  public static final class Builder {
<span class="fc" id="L74">    private final Map&lt;String, List&lt;String&gt;&gt; configuredByProperties = new HashMap&lt;&gt;();</span>
<span class="fc" id="L75">    private final Map&lt;String, Level&gt; configuredByHardcodedLevel = new HashMap&lt;&gt;();</span>
<span class="fc" id="L76">    private final Set&lt;String&gt; offUnlessTrace = new HashSet&lt;&gt;();</span>
    private final String rootLoggerName;

<span class="fc" id="L79">    private Builder(String rootLoggerName) {</span>
<span class="fc" id="L80">      this.rootLoggerName = requireNonNull(rootLoggerName, &quot;rootLoggerName can't be null&quot;);</span>
<span class="fc" id="L81">    }</span>

    /**
     * Configure the log level of the root logger to be read from the value of properties {@link #SONAR_LOG_LEVEL_PROPERTY} and
     * {@link #SONAR_PROCESS_LOG_LEVEL_PROPERTY}.
     */
    public Builder rootLevelFor(ProcessId processId) {
<span class="fc" id="L88">      checkProcessId(processId);</span>

<span class="fc" id="L90">      levelByProperty(rootLoggerName, SONAR_LOG_LEVEL_PROPERTY, SONAR_PROCESS_LOG_LEVEL_PROPERTY.replace(PROCESS_NAME_PLACEHOLDER, processId.getKey()));</span>
<span class="fc" id="L91">      return this;</span>
    }

    /**
     * Configure the log level of the logger with the specified name to be read from the value of properties
     * {@code sonar.log.level}, {@code sonar.log.level.[process_name]} and {@code sonar.log.level.[process_name].[LogDomain#getKey()]}.
     */
    public Builder levelByDomain(String loggerName, ProcessId processId, LogDomain domain) {
<span class="fc" id="L99">      checkLoggerName(loggerName);</span>
<span class="fc" id="L100">      checkProcessId(processId);</span>
<span class="fc" id="L101">      requireNonNull(domain, &quot;LogDomain can't be null&quot;);</span>
<span class="fc" id="L102">      String processProperty = SONAR_PROCESS_LOG_LEVEL_PROPERTY.replace(PROCESS_NAME_PLACEHOLDER, processId.getKey());</span>
<span class="fc" id="L103">      levelByProperty(loggerName, SONAR_LOG_LEVEL_PROPERTY, processProperty, processProperty + &quot;.&quot; + domain.getKey());</span>
<span class="fc" id="L104">      return this;</span>
    }

    private void levelByProperty(String loggerName, String property, String... otherProperties) {
<span class="fc" id="L108">      ensureUniqueConfiguration(loggerName);</span>
<span class="fc" id="L109">      configuredByProperties.put(loggerName, Stream.concat(Stream.of(property), Arrays.stream(otherProperties)).toList());</span>
<span class="fc" id="L110">    }</span>

    /**
     * Configure the log level of the logger with the specified name to be the specified one and it should never be
     * changed.
     */
    public Builder immutableLevel(String loggerName, Level level) {
<span class="fc" id="L117">      checkLoggerName(loggerName);</span>
<span class="fc" id="L118">      requireNonNull(level, &quot;level can't be null&quot;);</span>
<span class="fc" id="L119">      ensureUniqueConfiguration(loggerName);</span>
<span class="fc" id="L120">      configuredByHardcodedLevel.put(loggerName, level);</span>
<span class="fc" id="L121">      return this;</span>
    }

    private void ensureUniqueConfiguration(String loggerName) {
<span class="fc bfc" id="L125" title="All 2 branches covered.">      if (configuredByProperties.containsKey(loggerName)) {</span>
<span class="fc" id="L126">        throw new IllegalStateException(&quot;Configuration by property already registered for &quot; + loggerName);</span>
      }
<span class="fc bfc" id="L128" title="All 2 branches covered.">      if (configuredByHardcodedLevel.containsKey(loggerName)) {</span>
<span class="fc" id="L129">        throw new IllegalStateException(&quot;Configuration hardcoded level already registered for &quot; + loggerName);</span>
      }
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">      if (offUnlessTrace.contains(loggerName)) {</span>
<span class="nc" id="L132">        throw new IllegalStateException(&quot;Configuration off unless TRACE already registered for &quot; + loggerName);</span>
      }
<span class="fc" id="L134">    }</span>

    private static void checkProcessId(ProcessId processId) {
<span class="fc" id="L137">      requireNonNull(processId, &quot;ProcessId can't be null&quot;);</span>
<span class="fc" id="L138">    }</span>

    private static void checkLoggerName(String loggerName) {
<span class="fc" id="L141">      requireNonNull(loggerName, &quot;loggerName can't be null&quot;);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">      if (loggerName.isEmpty()) {</span>
<span class="fc" id="L143">        throw new IllegalArgumentException(&quot;loggerName can't be empty&quot;);</span>
      }
<span class="fc" id="L145">    }</span>

    public Builder offUnlessTrace(String loggerName) {
<span class="fc" id="L148">      checkLoggerName(loggerName);</span>
<span class="fc" id="L149">      ensureUniqueConfiguration(loggerName);</span>
<span class="fc" id="L150">      offUnlessTrace.add(loggerName);</span>
<span class="fc" id="L151">      return this;</span>
    }

    public LogLevelConfig build() {
<span class="fc" id="L155">      return new LogLevelConfig(this);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>