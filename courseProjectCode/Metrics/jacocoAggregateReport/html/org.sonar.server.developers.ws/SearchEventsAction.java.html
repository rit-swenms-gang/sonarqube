<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SearchEventsAction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.developers.ws</a> &gt; <span class="el_source">SearchEventsAction.java</span></div><h1>SearchEventsAction.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.developers.ws;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import org.sonar.api.platform.Server;
import org.sonar.api.server.ws.Request;
import org.sonar.api.server.ws.Response;
import org.sonar.api.server.ws.WebService;
import org.sonar.db.permission.ProjectPermission;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.component.BranchDto;
import org.sonar.db.component.SnapshotDto;
import org.sonar.db.event.EventDto;
import org.sonar.db.project.ProjectDto;
import org.sonar.server.issue.index.IssueIndex;
import org.sonar.server.issue.index.IssueIndexSyncProgressChecker;
import org.sonar.server.issue.index.ProjectStatistics;
import org.sonar.server.projectanalysis.ws.EventCategory;
import org.sonar.server.user.UserSession;
import org.sonar.server.ws.KeyExamples;
import org.sonarqube.ws.Developers.SearchEventsWsResponse;
import org.sonarqube.ws.Developers.SearchEventsWsResponse.Event;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.lang.String.format;
import static java.lang.String.join;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Comparator.comparing;
import static org.sonar.api.utils.DateUtils.formatDateTime;
import static org.sonar.api.utils.DateUtils.parseDateTimeQuietly;
import static org.sonar.db.component.BranchType.BRANCH;
import static org.sonar.db.component.BranchType.PULL_REQUEST;
import static org.sonar.server.developers.ws.UuidFromPairs.fromDates;
import static org.sonar.server.developers.ws.UuidFromPairs.projectUuids;
import static org.sonar.server.exceptions.BadRequestException.checkRequest;
import static org.sonar.server.ws.WsUtils.writeProtobuf;

public class SearchEventsAction implements DevelopersWsAction {

  public static final String PARAM_PROJECTS = &quot;projects&quot;;
  public static final String PARAM_FROM = &quot;from&quot;;

  private final DbClient dbClient;
  private final UserSession userSession;
  private final Server server;
  private final IssueIndex issueIndex;
  private final IssueIndexSyncProgressChecker issueIndexSyncProgressChecker;

<span class="fc" id="L80">  public SearchEventsAction(DbClient dbClient, UserSession userSession, Server server, IssueIndex issueIndex, IssueIndexSyncProgressChecker issueIndexSyncProgressChecker) {</span>
<span class="fc" id="L81">    this.dbClient = dbClient;</span>
<span class="fc" id="L82">    this.userSession = userSession;</span>
<span class="fc" id="L83">    this.server = server;</span>
<span class="fc" id="L84">    this.issueIndex = issueIndex;</span>
<span class="fc" id="L85">    this.issueIndexSyncProgressChecker = issueIndexSyncProgressChecker;</span>
<span class="fc" id="L86">  }</span>

  @Override
  public void define(WebService.NewController controller) {
<span class="fc" id="L90">    WebService.NewAction action = controller.createAction(&quot;search_events&quot;)</span>
<span class="fc" id="L91">      .setDescription(&quot;Search for events.&lt;br/&gt;&quot; +</span>
        &quot;Requires authentication.&quot;
        + &quot;&lt;br/&gt;When issue indexing is in progress returns 503 service unavailable HTTP code.&quot;)
<span class="fc" id="L94">      .setSince(&quot;1.0&quot;)</span>
<span class="fc" id="L95">      .setInternal(true)</span>
<span class="fc" id="L96">      .setHandler(this)</span>
<span class="fc" id="L97">      .setResponseExample(SearchEventsAction.class.getResource(&quot;search_events-example.json&quot;));</span>

<span class="fc" id="L99">    action.createParam(PARAM_PROJECTS)</span>
<span class="fc" id="L100">      .setRequired(true)</span>
<span class="fc" id="L101">      .setDescription(&quot;Comma-separated list of project keys to search notifications for&quot;)</span>
<span class="fc" id="L102">      .setExampleValue(join(&quot;,&quot;, KeyExamples.KEY_PROJECT_EXAMPLE_001, KeyExamples.KEY_PROJECT_EXAMPLE_002));</span>

<span class="fc" id="L104">    action.createParam(PARAM_FROM)</span>
<span class="fc" id="L105">      .setRequired(true)</span>
<span class="fc" id="L106">      .setDescription(&quot;Comma-separated list of datetimes. Filter events created after the given date (exclusive).&quot;)</span>
<span class="fc" id="L107">      .setExampleValue(&quot;2017-10-19T13:00:00+0200&quot;);</span>
<span class="fc" id="L108">  }</span>

  @Override
  public void handle(Request request, Response response) throws Exception {
<span class="fc" id="L112">    userSession.checkLoggedIn();</span>
<span class="fc" id="L113">    checkIfNeedIssueSync(request.mandatoryParamAsStrings(PARAM_PROJECTS));</span>
<span class="fc" id="L114">    SearchEventsWsResponse.Builder message = SearchEventsWsResponse.newBuilder();</span>
<span class="fc" id="L115">    computeEvents(request).forEach(message::addEvents);</span>
<span class="fc" id="L116">    writeProtobuf(message.build(), request, response);</span>
<span class="fc" id="L117">  }</span>

  private void checkIfNeedIssueSync(List&lt;String&gt; projectKeys) {
<span class="fc" id="L120">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L121">      issueIndexSyncProgressChecker.checkIfAnyComponentsNeedIssueSync(dbSession, projectKeys);</span>
    }
<span class="fc" id="L123">  }</span>

  private Stream&lt;Event&gt; computeEvents(Request request) {
<span class="fc" id="L126">    List&lt;String&gt; projectKeys = request.mandatoryParamAsStrings(PARAM_PROJECTS);</span>
<span class="fc" id="L127">    List&lt;Long&gt; fromDates = mandatoryParamAsDateTimes(request, PARAM_FROM);</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">    if (projectKeys.isEmpty()) {</span>
<span class="fc" id="L130">      return Stream.empty();</span>
    }

<span class="fc" id="L133">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L134">      List&lt;ProjectDto&gt; authorizedProjects = searchProjects(dbSession, projectKeys);</span>
<span class="fc" id="L135">      Map&lt;String, ProjectDto&gt; projectsByUuid = authorizedProjects.stream().collect(Collectors.toMap(ProjectDto::getUuid, Function.identity()));</span>
<span class="fc" id="L136">      List&lt;UuidFromPair&gt; uuidFromPairs = buildUuidFromPairs(fromDates, projectKeys, authorizedProjects);</span>
<span class="fc" id="L137">      List&lt;SnapshotDto&gt; analyses = dbClient.snapshotDao().selectFinishedByProjectUuidsAndFromDates(dbSession, projectUuids(uuidFromPairs), fromDates(uuidFromPairs));</span>

<span class="fc bfc" id="L139" title="All 2 branches covered.">      if (analyses.isEmpty()) {</span>
<span class="fc" id="L140">        return Stream.empty();</span>
      }

<span class="fc" id="L143">      List&lt;String&gt; branchUuids = analyses.stream().map(SnapshotDto::getRootComponentUuid).toList();</span>
<span class="fc" id="L144">      Map&lt;String, BranchDto&gt; branchesByUuids = dbClient.branchDao().selectByUuids(dbSession, branchUuids)</span>
<span class="fc" id="L145">        .stream().collect(Collectors.toMap(BranchDto::getUuid, Function.identity()));</span>

<span class="fc" id="L147">      return Stream.concat(</span>
<span class="fc" id="L148">        computeQualityGateChangeEvents(dbSession, projectsByUuid, branchesByUuids, analyses),</span>
<span class="fc" id="L149">        computeNewIssuesEvents(projectsByUuid, branchesByUuids, uuidFromPairs));</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    }</span>
  }

  private Stream&lt;Event&gt; computeQualityGateChangeEvents(DbSession dbSession, Map&lt;String, ProjectDto&gt; projectsByUuid,
    Map&lt;String, BranchDto&gt; branchesByUuids,
    List&lt;SnapshotDto&gt; analyses) {
<span class="fc" id="L156">    Map&lt;String, EventDto&gt; eventsByComponentUuid = new HashMap&lt;&gt;();</span>
<span class="fc" id="L157">    dbClient.eventDao().selectByAnalysisUuids(dbSession, analyses.stream().map(SnapshotDto::getUuid).toList())</span>
<span class="fc" id="L158">      .stream()</span>
<span class="fc" id="L159">      .sorted(comparing(EventDto::getDate))</span>
<span class="fc" id="L160">      .filter(e -&gt; EventCategory.QUALITY_GATE.getLabel().equals(e.getCategory()))</span>
<span class="fc" id="L161">      .forEach(e -&gt; eventsByComponentUuid.put(e.getComponentUuid(), e));</span>

<span class="pc bpc" id="L163" title="1 of 2 branches missed.">    Predicate&lt;EventDto&gt; branchPredicate = e -&gt; branchesByUuids.get(e.getComponentUuid()).getBranchType() == BRANCH;</span>
<span class="fc" id="L164">    return eventsByComponentUuid.values()</span>
<span class="fc" id="L165">      .stream()</span>
<span class="fc" id="L166">      .sorted(comparing(EventDto::getDate))</span>
<span class="fc" id="L167">      .filter(branchPredicate)</span>
<span class="fc" id="L168">      .map(e -&gt; {</span>
<span class="fc" id="L169">        BranchDto branch = branchesByUuids.get(e.getComponentUuid());</span>
<span class="fc" id="L170">        ProjectDto project = projectsByUuid.get(branch.getProjectUuid());</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        checkState(project != null, &quot;Found event '%s', for a component that we did not search for&quot;, e.getUuid());</span>
<span class="fc" id="L172">        return Event.newBuilder()</span>
<span class="fc" id="L173">          .setCategory(EventCategory.fromLabel(e.getCategory()).name())</span>
<span class="fc" id="L174">          .setProject(project.getKey())</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">          .setMessage(branch.isMain() ? format(&quot;Quality Gate status of project '%s' changed to '%s'&quot;, project.getName(), e.getName())</span>
<span class="fc" id="L176">            : format(&quot;Quality Gate status of project '%s' on branch '%s' changed to '%s'&quot;, project.getName(), branch.getKey(), e.getName()))</span>
<span class="fc" id="L177">          .setLink(computeDashboardLink(project, branch))</span>
<span class="fc" id="L178">          .setDate(formatDateTime(e.getDate()))</span>
<span class="fc" id="L179">          .build();</span>
      });
  }

  private Stream&lt;Event&gt; computeNewIssuesEvents(Map&lt;String, ProjectDto&gt; projectsByUuid, Map&lt;String, BranchDto&gt; branchesByUuids,
    List&lt;UuidFromPair&gt; uuidFromPairs) {
<span class="fc" id="L185">    Map&lt;String, Long&gt; fromsByProjectUuid = uuidFromPairs.stream().collect(Collectors.toMap(</span>
      UuidFromPair::getProjectUuid,
      UuidFromPair::getFrom));
<span class="fc" id="L188">    List&lt;ProjectStatistics&gt; projectStatistics = issueIndex.searchProjectStatistics(projectUuids(uuidFromPairs), fromDates(uuidFromPairs), userSession.getUuid());</span>
<span class="fc" id="L189">    return projectStatistics</span>
<span class="fc" id="L190">      .stream()</span>
<span class="fc" id="L191">      .map(e -&gt; {</span>
<span class="fc" id="L192">        BranchDto branch = branchesByUuids.get(e.getProjectUuid());</span>
<span class="fc" id="L193">        ProjectDto project = projectsByUuid.get(branch.getProjectUuid());</span>
<span class="fc" id="L194">        long issueCount = e.getIssueCount();</span>
<span class="fc" id="L195">        long lastIssueDate = e.getLastIssueDate();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        String branchType = branch.getBranchType().equals(PULL_REQUEST) ? &quot;pull request&quot; : &quot;branch&quot;;</span>
<span class="fc" id="L197">        return Event.newBuilder()</span>
<span class="fc" id="L198">          .setCategory(&quot;NEW_ISSUES&quot;)</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">          .setMessage(format(&quot;You have %s new %s on project '%s'&quot;, issueCount, issueCount == 1 ? &quot;issue&quot; : &quot;issues&quot;,</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            project.getName()) + (branch.isMain() ? &quot;&quot; : format(&quot; on %s '%s'&quot;, branchType, branch.getKey())))</span>
<span class="fc" id="L201">          .setLink(computeIssuesSearchLink(project, branch, fromsByProjectUuid.get(project.getUuid()), userSession.getLogin()))</span>
<span class="fc" id="L202">          .setProject(project.getKey())</span>
<span class="fc" id="L203">          .setDate(formatDateTime(lastIssueDate))</span>
<span class="fc" id="L204">          .build();</span>
      });
  }

  private List&lt;ProjectDto&gt; searchProjects(DbSession dbSession, List&lt;String&gt; projectKeys) {
<span class="fc" id="L209">    List&lt;ProjectDto&gt; projects = dbClient.projectDao().selectProjectsByKeys(dbSession, new HashSet&lt;&gt;(projectKeys));</span>
<span class="fc" id="L210">    return userSession.keepAuthorizedEntities(ProjectPermission.USER, projects);</span>
  }

  private String computeIssuesSearchLink(ProjectDto project, BranchDto branch, long functionalFromDate, String login) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">    String branchParam = branch.getBranchType().equals(PULL_REQUEST) ? &quot;pullRequest&quot; : &quot;branch&quot;;</span>
<span class="fc" id="L215">    String link = format(&quot;%s/project/issues?id=%s&amp;createdAfter=%s&amp;assignees=%s&amp;resolved=false&quot;,</span>
<span class="fc" id="L216">      server.getPublicRootUrl(), encode(project.getKey()), encode(formatDateTime(functionalFromDate)), encode(login));</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">    link += branch.isMain() ? &quot;&quot; : format(&quot;&amp;%s=%s&quot;, branchParam, encode(branch.getKey()));</span>
<span class="fc" id="L218">    return link;</span>
  }

  private String computeDashboardLink(ProjectDto project, BranchDto branch) {
<span class="fc" id="L222">    String link = server.getPublicRootUrl() + &quot;/dashboard?id=&quot; + encode(project.getKey());</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">    link += branch.isMain() ? &quot;&quot; : format(&quot;&amp;branch=%s&quot;, encode(branch.getKey()));</span>
<span class="fc" id="L224">    return link;</span>
  }

  private static List&lt;UuidFromPair&gt; buildUuidFromPairs(List&lt;Long&gt; fromDates, List&lt;String&gt; projectKeys, List&lt;ProjectDto&gt; authorizedProjects) {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">    checkRequest(projectKeys.size() == fromDates.size(), &quot;The number of components (%s) and from dates (%s) must be the same.&quot;, projectKeys.size(), fromDates.size());</span>
<span class="fc" id="L229">    Map&lt;String, Long&gt; fromDatesByProjectKey = IntStream.range(0, projectKeys.size()).boxed()</span>
<span class="fc" id="L230">      .collect(Collectors.toMap(projectKeys::get, fromDates::get));</span>
<span class="fc" id="L231">    return authorizedProjects.stream()</span>
<span class="fc" id="L232">      .map(dto -&gt; new UuidFromPair(dto.getUuid(), fromDatesByProjectKey.get(dto.getKey())))</span>
<span class="fc" id="L233">      .toList();</span>
  }

  private static List&lt;Long&gt; mandatoryParamAsDateTimes(Request request, String param) {
<span class="fc" id="L237">    return request.mandatoryParamAsStrings(param).stream()</span>
<span class="fc" id="L238">      .map(stringDate -&gt; {</span>
<span class="fc" id="L239">        Date date = parseDateTimeQuietly(stringDate);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">        checkArgument(date != null, &quot;'%s' cannot be parsed as either a date or date+time&quot;, stringDate);</span>
<span class="fc" id="L241">        return date.getTime() + 1_000L;</span>
      })
<span class="fc" id="L243">      .toList();</span>
  }

  private static String encode(String text) {
    try {
<span class="fc" id="L248">      return URLEncoder.encode(text, UTF_8.name());</span>
<span class="nc" id="L249">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L250">      throw new IllegalStateException(format(&quot;Cannot encode %s&quot;, text), e);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>