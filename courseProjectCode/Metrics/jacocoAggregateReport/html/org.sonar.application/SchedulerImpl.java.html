<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SchedulerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.application</a> &gt; <span class="el_source">SchedulerImpl.java</span></div><h1>SchedulerImpl.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.application;

import java.util.EnumMap;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.application.command.AbstractCommand;
import org.sonar.application.command.CommandFactory;
import org.sonar.application.config.AppSettings;
import org.sonar.application.config.ClusterSettings;
import org.sonar.application.process.ManagedProcessEventListener;
import org.sonar.application.process.ManagedProcessHandler;
import org.sonar.application.process.ManagedProcessLifecycle;
import org.sonar.application.process.ProcessLifecycleListener;
import org.sonar.process.ProcessId;
import org.sonar.process.ProcessProperties;

import static org.sonar.application.NodeLifecycle.State.FINALIZE_STOPPING;
import static org.sonar.application.NodeLifecycle.State.HARD_STOPPING;
import static org.sonar.application.NodeLifecycle.State.RESTARTING;
import static org.sonar.application.NodeLifecycle.State.STOPPED;
import static org.sonar.application.NodeLifecycle.State.STOPPING;
import static org.sonar.application.process.ManagedProcessHandler.Timeout.newTimeout;
import static org.sonar.process.ProcessProperties.parseTimeoutMs;
import static org.sonar.process.ProcessProperties.Property.CE_GRACEFUL_STOP_TIMEOUT;
import static org.sonar.process.ProcessProperties.Property.WEB_GRACEFUL_STOP_TIMEOUT;

public class SchedulerImpl implements Scheduler, ManagedProcessEventListener, ProcessLifecycleListener, AppStateListener {

<span class="fc" id="L55">  private static final Logger LOG = LoggerFactory.getLogger(SchedulerImpl.class);</span>
<span class="fc" id="L56">  private static final ManagedProcessHandler.Timeout HARD_STOP_TIMEOUT = newTimeout(1, TimeUnit.MINUTES);</span>
<span class="fc" id="L57">  private static int hardStopperThreadIndex = 0;</span>
<span class="fc" id="L58">  private static int restartStopperThreadIndex = 0;</span>

  private final AppSettings settings;
  private final AppReloader appReloader;
  private final CommandFactory commandFactory;
  private final ProcessLauncher processLauncher;
  private final AppState appState;
<span class="fc" id="L65">  private final NodeLifecycle nodeLifecycle = new NodeLifecycle();</span>

<span class="fc" id="L67">  private final CountDownLatch awaitTermination = new CountDownLatch(1);</span>
<span class="fc" id="L68">  private final AtomicBoolean firstWaitingEsLog = new AtomicBoolean(true);</span>
<span class="fc" id="L69">  private final EnumMap&lt;ProcessId, ManagedProcessHandler&gt; processesById = new EnumMap&lt;&gt;(ProcessId.class);</span>
<span class="fc" id="L70">  private final AtomicInteger operationalCountDown = new AtomicInteger();</span>
<span class="fc" id="L71">  private final AtomicInteger stopCountDown = new AtomicInteger(0);</span>
  private RestartStopperThread restartStopperThread;
  private HardStopperThread hardStopperThread;
  private RestarterThread restarterThread;
<span class="fc" id="L75">  private long processWatcherDelayMs = ManagedProcessHandler.DEFAULT_WATCHER_DELAY_MS;</span>

  public SchedulerImpl(AppSettings settings, AppReloader appReloader, CommandFactory commandFactory,
<span class="fc" id="L78">    ProcessLauncher processLauncher, AppState appState) {</span>
<span class="fc" id="L79">    this.settings = settings;</span>
<span class="fc" id="L80">    this.appReloader = appReloader;</span>
<span class="fc" id="L81">    this.commandFactory = commandFactory;</span>
<span class="fc" id="L82">    this.processLauncher = processLauncher;</span>
<span class="fc" id="L83">    this.appState = appState;</span>
<span class="fc" id="L84">    this.appState.addListener(this);</span>
<span class="fc" id="L85">  }</span>

  SchedulerImpl setProcessWatcherDelayMs(long l) {
<span class="fc" id="L88">    this.processWatcherDelayMs = l;</span>
<span class="fc" id="L89">    return this;</span>
  }

  @Override
  public void schedule() throws InterruptedException {
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    if (!nodeLifecycle.tryToMoveTo(NodeLifecycle.State.STARTING)) {</span>
<span class="nc" id="L95">      return;</span>
    }
<span class="fc" id="L97">    firstWaitingEsLog.set(true);</span>
<span class="fc" id="L98">    processesById.clear();</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">    for (ProcessId processId : ClusterSettings.getEnabledProcesses(settings)) {</span>
<span class="fc" id="L101">      ManagedProcessHandler process = ManagedProcessHandler.builder(processId)</span>
<span class="fc" id="L102">        .addProcessLifecycleListener(this)</span>
<span class="fc" id="L103">        .addEventListener(this)</span>
<span class="fc" id="L104">        .setWatcherDelayMs(processWatcherDelayMs)</span>
<span class="fc" id="L105">        .setStopTimeout(stopTimeoutFor(processId, settings))</span>
<span class="fc" id="L106">        .setHardStopTimeout(HARD_STOP_TIMEOUT)</span>
<span class="fc" id="L107">        .setAppSettings(settings)</span>
<span class="fc" id="L108">        .build();</span>
<span class="fc" id="L109">      processesById.put(process.getProcessId(), process);</span>
<span class="fc" id="L110">    }</span>
<span class="fc" id="L111">    operationalCountDown.set(processesById.size());</span>

<span class="fc" id="L113">    tryToStartAll();</span>
<span class="fc" id="L114">  }</span>

  private static ManagedProcessHandler.Timeout stopTimeoutFor(ProcessId processId, AppSettings settings) {
<span class="pc bpc" id="L117" title="1 of 4 branches missed.">    return switch (processId) {</span>
<span class="fc" id="L118">      case ELASTICSEARCH -&gt; HARD_STOP_TIMEOUT;</span>
<span class="fc" id="L119">      case WEB_SERVER -&gt; newTimeout(getStopTimeoutMs(settings, WEB_GRACEFUL_STOP_TIMEOUT), TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L120">      case COMPUTE_ENGINE -&gt; newTimeout(getStopTimeoutMs(settings, CE_GRACEFUL_STOP_TIMEOUT), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L121">      default -&gt; throw new IllegalArgumentException(&quot;Unsupported processId &quot; + processId);</span>
    };
  }

  private static long getStopTimeoutMs(AppSettings settings, ProcessProperties.Property property) {
<span class="fc" id="L126">    String timeoutMs = settings.getValue(property.getKey())</span>
<span class="fc" id="L127">      .orElse(property.getDefaultValue());</span>
    // give some time to CE/Web to shutdown itself after &quot;timeoutMs&quot;
<span class="fc" id="L129">    long gracePeriod = HARD_STOP_TIMEOUT.getUnit().toMillis(HARD_STOP_TIMEOUT.getDuration());</span>
<span class="fc" id="L130">    return parseTimeoutMs(property, timeoutMs) + gracePeriod;</span>
  }

  private void tryToStartAll() throws InterruptedException {
<span class="fc" id="L134">    tryToStartEs();</span>
<span class="fc" id="L135">    tryToStartWeb();</span>
<span class="fc" id="L136">    tryToStartCe();</span>
<span class="fc" id="L137">  }</span>

  private void tryToStartEs() throws InterruptedException {
<span class="fc" id="L140">    ManagedProcessHandler process = processesById.get(ProcessId.ELASTICSEARCH);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (process != null) {</span>
<span class="fc" id="L142">      tryToStartProcess(process, commandFactory::createEsCommand);</span>
    }
<span class="fc" id="L144">  }</span>

  private void tryToStartWeb() throws InterruptedException {
<span class="fc" id="L147">    ManagedProcessHandler process = processesById.get(ProcessId.WEB_SERVER);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">    if (process == null) {</span>
<span class="fc" id="L149">      return;</span>
    }
<span class="fc bfc" id="L151" title="All 2 branches covered.">    if (!isEsOperational()) {</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">      if (firstWaitingEsLog.getAndSet(false)) {</span>
<span class="fc" id="L153">        LOG.info(&quot;Waiting for Elasticsearch to be up and running&quot;);</span>
      }
<span class="fc" id="L155">      return;</span>
    }
<span class="fc bfc" id="L157" title="All 2 branches covered.">    if (appState.tryToLockWebLeader()) {</span>
<span class="fc" id="L158">      tryToStartWebLeader(process);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">    } else if (appState.isOperational(ProcessId.WEB_SERVER, false)) {</span>
<span class="fc" id="L160">      tryToStartProcess(process, () -&gt; commandFactory.createWebCommand(false));</span>
    } else {
<span class="fc" id="L162">      Optional&lt;String&gt; leader = appState.getLeaderHostName();</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">      if (leader.isPresent()) {</span>
<span class="fc" id="L164">        LOG.info(&quot;Waiting for initialization from {}&quot;, leader.get());</span>
      } else {
<span class="nc" id="L166">        LOG.error(&quot;Initialization failed. All nodes must be restarted&quot;);</span>
      }
    }
<span class="fc" id="L169">  }</span>

  /**
   * Tries to start the web leader process. If the process fails to start, the web leader lock is released. If we would not release the lock
   * then all nodes would need to be stopped and restarted.
   */
  private void tryToStartWebLeader(ManagedProcessHandler process) throws InterruptedException {
    try {
<span class="fc" id="L177">      boolean processStarted = tryToStartProcess(process, () -&gt; commandFactory.createWebCommand(true));</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">      if (!processStarted) {</span>
<span class="fc" id="L179">        appState.tryToReleaseWebLeaderLock();</span>
      }
<span class="nc" id="L181">    } catch (InterruptedException e) {</span>
<span class="nc" id="L182">      logProcessStartFailure(process, e);</span>
<span class="nc" id="L183">      appState.tryToReleaseWebLeaderLock();</span>
<span class="nc" id="L184">      throw e;</span>
<span class="fc" id="L185">    }</span>
<span class="fc" id="L186">  }</span>

  private void tryToStartCe() throws InterruptedException {
<span class="fc" id="L189">    ManagedProcessHandler process = processesById.get(ProcessId.COMPUTE_ENGINE);</span>
<span class="pc bpc" id="L190" title="1 of 6 branches missed.">    if (process != null &amp;&amp; appState.isOperational(ProcessId.WEB_SERVER, true) &amp;&amp; isEsOperational()) {</span>
<span class="fc" id="L191">      tryToStartProcess(process, commandFactory::createCeCommand);</span>
    }
<span class="fc" id="L193">  }</span>

  private boolean isEsOperational() {
<span class="fc" id="L196">    boolean requireLocalEs = ClusterSettings.isLocalElasticsearchEnabled(settings);</span>
<span class="fc" id="L197">    return appState.isOperational(ProcessId.ELASTICSEARCH, requireLocalEs);</span>
  }

  private boolean tryToStartProcess(ManagedProcessHandler processHandler, Supplier&lt;AbstractCommand&gt; commandSupplier) throws InterruptedException {
    // starter or restarter thread was interrupted, we should not proceed with starting the process
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">    if (Thread.currentThread().isInterrupted()) {</span>
<span class="nc" id="L203">      throw new InterruptedException();</span>
    }

    try {
<span class="fc" id="L207">      processHandler.start(() -&gt; {</span>
<span class="fc" id="L208">        AbstractCommand command = commandSupplier.get();</span>
<span class="fc" id="L209">        return processLauncher.launch(command);</span>
      });
<span class="fc" id="L211">    } catch (RuntimeException e) {</span>
<span class="fc" id="L212">      logProcessStartFailure(processHandler, e);</span>
<span class="fc" id="L213">      return false;</span>
<span class="fc" id="L214">    }</span>
<span class="fc" id="L215">    return true;</span>
  }

  private static void logProcessStartFailure(ManagedProcessHandler processHandler, Exception e) {
    // failed to start command -&gt; do nothing
    // the process failing to start will move directly to STOP state
    // this early stop of the process will be picked up by onProcessStop (which calls hardStopAsync)
    // through interface ProcessLifecycleListener#onProcessState implemented by SchedulerImpl
<span class="fc" id="L223">    LOG.warn(&quot;Failed to start process [{}] (currentThread={})&quot;,</span>
<span class="fc" id="L224">      processHandler.getProcessId().getHumanReadableName(), Thread.currentThread().getName(), e);</span>
<span class="fc" id="L225">  }</span>

  @Override
  public void stop() {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">    if (nodeLifecycle.tryToMoveTo(STOPPING)) {</span>
<span class="fc" id="L230">      LOG.info(&quot;Stopping SonarQube&quot;);</span>
<span class="fc" id="L231">      stopImpl();</span>
    }
<span class="fc" id="L233">  }</span>

  private void stopImpl() {
    try {
<span class="fc" id="L237">      appState.tryToReleaseWebLeaderLock();</span>
<span class="fc" id="L238">      stopAll();</span>
<span class="fc" id="L239">      finalizeStop();</span>
<span class="nc" id="L240">    } catch (InterruptedException e) {</span>
<span class="nc" id="L241">      LOG.debug(&quot;Stop interrupted&quot;, e);</span>
<span class="nc" id="L242">      Thread.currentThread().interrupt();</span>
<span class="fc" id="L243">    }</span>
<span class="fc" id="L244">  }</span>

  private void stopAll() throws InterruptedException {
    // order is important for non-cluster mode
<span class="fc" id="L248">    LOG.info(&quot;Sonarqube has been requested to stop&quot;);</span>
<span class="fc" id="L249">    stopProcess(ProcessId.COMPUTE_ENGINE);</span>
<span class="fc" id="L250">    stopProcess(ProcessId.WEB_SERVER);</span>
<span class="fc" id="L251">    stopProcess(ProcessId.ELASTICSEARCH);</span>
<span class="fc" id="L252">  }</span>

  /**
   * Request for graceful stop then blocks until process is stopped.
   * Returns immediately if the process is disabled in configuration.
   *
   * @throws InterruptedException if {@link ManagedProcessHandler#hardStop()} throws a {@link InterruptedException}
   */
  private void stopProcess(ProcessId processId) throws InterruptedException {
<span class="fc" id="L261">    ManagedProcessHandler process = processesById.get(processId);</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">    if (process != null) {</span>
<span class="fc" id="L263">      LOG.info(&quot;Stopping [{}] process...&quot;, process.getProcessId().getHumanReadableName());</span>
<span class="fc" id="L264">      process.stop();</span>
    }
<span class="fc" id="L266">  }</span>

  /**
   * Blocks until all processes are quickly stopped. Pending restart, if any, is disabled.
   */
  @Override
  public void hardStop() {
<span class="fc bfc" id="L273" title="All 2 branches covered.">    if (nodeLifecycle.tryToMoveTo(HARD_STOPPING)) {</span>
<span class="fc" id="L274">      LOG.info(&quot;Hard stopping SonarQube&quot;);</span>
<span class="fc" id="L275">      hardStopImpl();</span>
    }
<span class="fc" id="L277">  }</span>

  private void hardStopImpl() {
    try {
<span class="fc" id="L281">      hardStopAll();</span>
<span class="nc" id="L282">    } catch (InterruptedException e) {</span>
      // ignore and assume SQ stop is handled by another thread
<span class="nc" id="L284">      LOG.debug(&quot;Stopping all processes was interrupted in the middle of a hard stop&quot; +</span>
<span class="nc" id="L285">        &quot; (current thread name is \&quot;{}\&quot;)&quot;, Thread.currentThread().getName());</span>
<span class="nc" id="L286">      Thread.currentThread().interrupt();</span>
    } finally {
<span class="fc" id="L288">      finalizeStop();</span>
    }
<span class="fc" id="L290">  }</span>

  private void hardStopAll() throws InterruptedException {
    // order is important for non-cluster mode
<span class="fc" id="L294">    hardStopProcess(ProcessId.COMPUTE_ENGINE);</span>
<span class="fc" id="L295">    hardStopProcess(ProcessId.WEB_SERVER);</span>
<span class="fc" id="L296">    hardStopProcess(ProcessId.ELASTICSEARCH);</span>
<span class="fc" id="L297">  }</span>

  /**
   * This might be called twice: once by the state listener and once by the stop/hardStop implementations.
   * The reason is that if all process are already stopped (may occur, eg., when stopping because restart of 1st process failed),
   * the node state won't be updated on process stopped callback.
   */
  private void finalizeStop() {
<span class="fc bfc" id="L305" title="All 2 branches covered.">    if (nodeLifecycle.tryToMoveTo(FINALIZE_STOPPING)) {</span>
<span class="fc" id="L306">      interrupt(restartStopperThread);</span>
<span class="fc" id="L307">      interrupt(hardStopperThread);</span>
<span class="fc" id="L308">      interrupt(restarterThread);</span>
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">      if (nodeLifecycle.tryToMoveTo(STOPPED)) {</span>
<span class="fc" id="L310">        LOG.info(&quot;SonarQube is stopped&quot;);</span>
      }
<span class="fc" id="L312">      awaitTermination.countDown();</span>
    }
<span class="fc" id="L314">  }</span>

  private static void interrupt(@Nullable Thread thread) {
<span class="fc" id="L317">    Thread currentThread = Thread.currentThread();</span>
    // prevent current thread from interrupting itself
<span class="fc bfc" id="L319" title="All 4 branches covered.">    if (thread != null &amp;&amp; currentThread != thread) {</span>
<span class="fc" id="L320">      thread.interrupt();</span>
<span class="fc" id="L321">      LOG.trace(&quot;{} interrupted {}&quot;, currentThread.getName(), thread.getName(), new Exception(&quot;(capturing stacktrace for debugging purpose)&quot;));</span>
    }
<span class="fc" id="L323">  }</span>

  /**
   * Request for graceful stop then blocks until process is stopped.
   * Returns immediately if the process is disabled in configuration.
   *
   * @throws InterruptedException if {@link ManagedProcessHandler#hardStop()} throws a {@link InterruptedException}
   */
  private void hardStopProcess(ProcessId processId) throws InterruptedException {
<span class="fc" id="L332">    ManagedProcessHandler process = processesById.get(processId);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">    if (process != null) {</span>
<span class="fc" id="L334">      process.hardStop();</span>
    }
<span class="fc" id="L336">  }</span>

  @Override
  public void awaitTermination() {
    try {
<span class="fc" id="L341">      awaitTermination.await();</span>
<span class="nc" id="L342">    } catch (InterruptedException e) {</span>
<span class="nc" id="L343">      Thread.currentThread().interrupt();</span>
<span class="fc" id="L344">    }</span>
<span class="fc" id="L345">  }</span>

  @Override
  public void onManagedProcessEvent(ProcessId processId, Type type) {
<span class="fc bfc" id="L349" title="All 2 branches covered.">    if (type == Type.OPERATIONAL) {</span>
<span class="fc" id="L350">      onProcessOperational(processId);</span>
<span class="pc bpc" id="L351" title="2 of 4 branches missed.">    } else if (type == Type.ASK_FOR_RESTART &amp;&amp; nodeLifecycle.tryToMoveTo(RESTARTING)) {</span>
<span class="fc" id="L352">      LOG.info(&quot;SQ restart requested by Process[{}]&quot;, processId.getHumanReadableName());</span>
<span class="fc" id="L353">      stopAsyncForRestart();</span>
    }
<span class="fc" id="L355">  }</span>

  private void onProcessOperational(ProcessId processId) {
<span class="fc" id="L358">    LOG.info(&quot;Process[{}] is up&quot;, processId.getKey());</span>
<span class="fc" id="L359">    appState.setOperational(processId);</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">    boolean lastProcessStarted = operationalCountDown.decrementAndGet() == 0;</span>
<span class="pc bpc" id="L361" title="1 of 4 branches missed.">    if (lastProcessStarted &amp;&amp; nodeLifecycle.tryToMoveTo(NodeLifecycle.State.OPERATIONAL)) {</span>
<span class="nc" id="L362">      LOG.info(&quot;SonarQube is operational&quot;);</span>
    }
<span class="fc" id="L364">  }</span>

  @Override
  public void onAppStateOperational(ProcessId processId) {
<span class="fc bfc" id="L368" title="All 2 branches covered.">    if (nodeLifecycle.getState() == NodeLifecycle.State.STARTING) {</span>
      try {
<span class="fc" id="L370">        tryToStartAll();</span>
<span class="nc" id="L371">      } catch (InterruptedException e) {</span>
        // startup process was interrupted, let's assume it means shutdown was requested
<span class="nc" id="L373">        LOG.debug(&quot;Startup process was interrupted on notification that process [{}] was operational&quot;, processId.getHumanReadableName(), e);</span>
<span class="nc" id="L374">        hardStopAsync();</span>
<span class="nc" id="L375">        Thread.currentThread().interrupt();</span>
<span class="fc" id="L376">      }</span>
    }
<span class="fc" id="L378">  }</span>

  @Override
  public void onProcessState(ProcessId processId, ManagedProcessLifecycle.State to) {
<span class="fc bfc" id="L382" title="All 3 branches covered.">    switch (to) {</span>
      case STOPPED:
<span class="fc" id="L384">        onProcessStop(processId);</span>
<span class="fc" id="L385">        break;</span>
      case STARTING:
<span class="fc" id="L387">        stopCountDown.incrementAndGet();</span>
<span class="fc" id="L388">        break;</span>
      default:
        // Nothing to do
        break;
    }
<span class="fc" id="L393">  }</span>

  private void onProcessStop(ProcessId processId) {
<span class="fc" id="L396">    LOG.info(&quot;Process[{}] is stopped&quot;, processId.getHumanReadableName());</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">    boolean lastProcessStopped = stopCountDown.decrementAndGet() == 0;</span>
<span class="fc bfc" id="L398" title="All 3 branches covered.">    switch (nodeLifecycle.getState()) {</span>
      case RESTARTING:
<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (lastProcessStopped) {</span>
<span class="fc" id="L401">          LOG.info(&quot;SonarQube is restarting&quot;);</span>
<span class="fc" id="L402">          restartAsync();</span>
        }
        break;
      case HARD_STOPPING, STOPPING:
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (lastProcessStopped) {</span>
<span class="fc" id="L407">          finalizeStop();</span>
        }
        break;
      default:
        // a sub process disappeared while this wasn't requested, SQ should be shutdown completely
<span class="fc" id="L412">        hardStopAsync();</span>
    }
<span class="fc" id="L414">  }</span>

  private void hardStopAsync() {
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">    if (hardStopperThread != null) {</span>
<span class="nc" id="L418">      logThreadRecreated(&quot;Hard stopper&quot;, hardStopperThread);</span>
<span class="nc" id="L419">      hardStopperThread.interrupt();</span>
    }

<span class="fc" id="L422">    hardStopperThread = new HardStopperThread();</span>
<span class="fc" id="L423">    hardStopperThread.start();</span>
<span class="fc" id="L424">  }</span>

  private void stopAsyncForRestart() {
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">    if (restartStopperThread != null) {</span>
<span class="nc" id="L428">      logThreadRecreated(&quot;Restart stopper&quot;, restartStopperThread);</span>
<span class="nc" id="L429">      restartStopperThread.interrupt();</span>
    }

<span class="fc" id="L432">    restartStopperThread = new RestartStopperThread();</span>
<span class="fc" id="L433">    restartStopperThread.start();</span>
<span class="fc" id="L434">  }</span>

  private static void logThreadRecreated(String threadType, Thread existingThread) {
<span class="nc" id="L437">    LOG.atDebug()</span>
<span class="nc" id="L438">      .addArgument(threadType)</span>
<span class="nc" id="L439">      .addArgument(Thread.currentThread().getName())</span>
<span class="nc" id="L440">      .addArgument(existingThread.getName())</span>
<span class="nc" id="L441">      .addArgument(new Exception(&quot;(capturing stack trace for debugging purpose)&quot;))</span>
<span class="nc" id="L442">      .log(&quot;{} thread was not null (currentThread={},existingThread={})&quot;);</span>
<span class="nc" id="L443">  }</span>

  private void restartAsync() {
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">    if (restarterThread != null) {</span>
<span class="nc" id="L447">      LOG.debug(&quot;Restarter thread was not null (name is \&quot;{}\&quot;)&quot;, restarterThread.getName(), new Exception());</span>
<span class="nc" id="L448">      restarterThread.interrupt();</span>
    }

<span class="fc" id="L451">    restarterThread = new RestarterThread();</span>
<span class="fc" id="L452">    restarterThread.start();</span>
<span class="fc" id="L453">  }</span>

  private class RestarterThread extends Thread {
<span class="fc" id="L456">    private RestarterThread() {</span>
<span class="fc" id="L457">      super(&quot;Restarter&quot;);</span>
<span class="fc" id="L458">    }</span>

    @Override
    public void run() {
      try {
<span class="fc" id="L463">        appReloader.reload(settings);</span>
<span class="fc" id="L464">        schedule();</span>
<span class="nc" id="L465">      } catch (InterruptedException e) {</span>
        // restart was interrupted, most likely by a stop thread, restart must be aborted
<span class="nc" id="L467">        LOG.debug(&quot;{} thread was interrupted&quot;, getName(), e);</span>
<span class="nc" id="L468">        super.interrupt();</span>
<span class="fc" id="L469">      } catch (Exception e) {</span>
<span class="fc" id="L470">        LOG.error(&quot;Failed to restart&quot;, e);</span>
<span class="fc" id="L471">        hardStop();</span>
<span class="pc" id="L472">      }</span>
<span class="fc" id="L473">    }</span>
  }

  private static int nextRestartStopperThreadIndex() {
<span class="fc" id="L477">    return restartStopperThreadIndex++;</span>
  }

  private static int nextHardStopperThreadIndex() {
<span class="fc" id="L481">    return hardStopperThreadIndex++;</span>
  }

  private class RestartStopperThread extends Thread {

<span class="fc" id="L486">    private RestartStopperThread() {</span>
<span class="fc" id="L487">      super(&quot;RestartStopper-&quot; + nextRestartStopperThreadIndex());</span>
<span class="fc" id="L488">    }</span>

    @Override
    public void run() {
<span class="fc" id="L492">      stopImpl();</span>
<span class="fc" id="L493">    }</span>
  }

  private class HardStopperThread extends Thread {

<span class="fc" id="L498">    private HardStopperThread() {</span>
<span class="fc" id="L499">      super(&quot;HardStopper-&quot; + nextHardStopperThreadIndex());</span>
<span class="fc" id="L500">    }</span>

    @Override
    public void run() {
<span class="pc bpc" id="L504" title="1 of 2 branches missed.">      if (nodeLifecycle.tryToMoveTo(HARD_STOPPING)) {</span>
<span class="fc" id="L505">        hardStopImpl();</span>
      }
<span class="fc" id="L507">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>