<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProcessLauncherImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.application</a> &gt; <span class="el_source">ProcessLauncherImpl.java</span></div><h1>ProcessLauncherImpl.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.application;

import com.google.common.net.HostAndPort;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.function.Supplier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.application.command.AbstractCommand;
import org.sonar.application.command.JavaCommand;
import org.sonar.application.command.JvmOptions;
import org.sonar.application.es.EsConnectorImpl;
import org.sonar.application.es.EsInstallation;
import org.sonar.application.es.EsKeyStoreCli;
import org.sonar.application.process.EsManagedProcess;
import org.sonar.application.process.ManagedProcess;
import org.sonar.application.process.ProcessCommandsManagedProcess;
import org.sonar.process.FileUtils2;
import org.sonar.process.ProcessId;
import org.sonar.process.sharedmemoryfile.AllProcessesCommands;
import org.sonar.process.sharedmemoryfile.ProcessCommands;

import static com.google.common.base.Preconditions.checkArgument;
import static java.lang.String.format;
import static java.util.Collections.singleton;
import static org.sonar.application.es.EsKeyStoreCli.BOOTSTRAP_PASSWORD_PROPERTY_KEY;
import static org.sonar.application.es.EsKeyStoreCli.HTTP_KEYSTORE_PASSWORD_PROPERTY_KEY;
import static org.sonar.application.es.EsKeyStoreCli.KEYSTORE_PASSWORD_PROPERTY_KEY;
import static org.sonar.application.es.EsKeyStoreCli.TRUSTSTORE_PASSWORD_PROPERTY_KEY;
import static org.sonar.process.ProcessEntryPoint.PROPERTY_GRACEFUL_STOP_TIMEOUT_MS;
import static org.sonar.process.ProcessEntryPoint.PROPERTY_PROCESS_INDEX;
import static org.sonar.process.ProcessEntryPoint.PROPERTY_PROCESS_KEY;
import static org.sonar.process.ProcessEntryPoint.PROPERTY_SHARED_PATH;

public class ProcessLauncherImpl implements ProcessLauncher {
<span class="fc" id="L66">  private static final Logger LOG = LoggerFactory.getLogger(ProcessLauncherImpl.class);</span>

  private final File tempDir;
  private final AllProcessesCommands allProcessesCommands;
  private final Supplier&lt;ProcessBuilder&gt; processBuilderSupplier;

  public ProcessLauncherImpl(File tempDir) {
<span class="nc" id="L73">    this(tempDir, new AllProcessesCommands(tempDir), JavaLangProcessBuilder::new);</span>
<span class="nc" id="L74">  }</span>

<span class="fc" id="L76">  ProcessLauncherImpl(File tempDir, AllProcessesCommands allProcessesCommands, Supplier&lt;ProcessBuilder&gt; processBuilderSupplier) {</span>
<span class="fc" id="L77">    this.tempDir = tempDir;</span>
<span class="fc" id="L78">    this.allProcessesCommands = allProcessesCommands;</span>
<span class="fc" id="L79">    this.processBuilderSupplier = processBuilderSupplier;</span>
<span class="fc" id="L80">  }</span>

  @Override
  public void close() {
<span class="nc" id="L84">    allProcessesCommands.close();</span>
<span class="nc" id="L85">  }</span>

  public ManagedProcess launch(AbstractCommand command) {
<span class="fc" id="L88">    EsInstallation esInstallation = command.getEsInstallation();</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">    if (esInstallation != null) {</span>
<span class="fc" id="L90">      cleanupOutdatedEsData(esInstallation);</span>
<span class="fc" id="L91">      writeConfFiles(esInstallation);</span>
    }

    Process process;
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">    if (command instanceof JavaCommand&lt;?&gt; javaCommand) {</span>
<span class="fc" id="L96">      process = launchJava(javaCommand);</span>
    } else {
<span class="nc" id="L98">      throw new IllegalStateException(&quot;Unexpected type of command: &quot; + command.getClass());</span>
    }

<span class="fc" id="L101">    ProcessId processId = command.getProcessId();</span>
    try {
<span class="fc bfc" id="L103" title="All 2 branches covered.">      if (processId == ProcessId.ELASTICSEARCH) {</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">        checkArgument(esInstallation != null, &quot;Incorrect configuration EsInstallation is null&quot;);</span>
<span class="fc" id="L105">        EsConnectorImpl esConnector = new EsConnectorImpl(singleton(HostAndPort.fromParts(esInstallation.getHost(),</span>
<span class="fc" id="L106">          esInstallation.getHttpPort())), esInstallation.getBootstrapPassword(), esInstallation.getHttpKeyStoreLocation(),</span>
<span class="fc" id="L107">          esInstallation.getHttpKeyStorePassword().orElse(null));</span>
<span class="fc" id="L108">        return new EsManagedProcess(process, processId, esConnector);</span>
      } else {
<span class="fc" id="L110">        ProcessCommands commands = allProcessesCommands.createAfterClean(processId.getIpcIndex());</span>
<span class="fc" id="L111">        return new ProcessCommandsManagedProcess(process, processId, commands);</span>
      }
<span class="nc" id="L113">    } catch (Exception e) {</span>
      // just in case
<span class="nc bnc" id="L115" title="All 2 branches missed.">      if (process != null) {</span>
<span class="nc" id="L116">        process.destroyForcibly();</span>
      }
<span class="nc" id="L118">      throw new IllegalStateException(format(&quot;Fail to launch monitor of process [%s]&quot;, processId.getHumanReadableName()), e);</span>
    }
  }

  private static void cleanupOutdatedEsData(EsInstallation esInstallation) {
<span class="fc" id="L123">    esInstallation.getOutdatedSearchDirectories()</span>
<span class="fc" id="L124">      .forEach(outdatedDir -&gt; {</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (outdatedDir.exists()) {</span>
<span class="fc" id="L126">          LOG.info(&quot;Deleting outdated search index data directory {}&quot;, outdatedDir.getAbsolutePath());</span>
          try {
<span class="fc" id="L128">            FileUtils2.deleteDirectory(outdatedDir);</span>

<span class="pc bpc" id="L130" title="1 of 2 branches missed.">            if (outdatedDir.exists()) {</span>
<span class="nc" id="L131">              LOG.info(&quot;Failed to delete outdated search index data directory {}&quot;, outdatedDir);</span>
            }
<span class="nc" id="L133">          } catch (IOException e) {</span>
<span class="nc" id="L134">            LOG.info(&quot;Failed to delete outdated search index data directory {}&quot;, outdatedDir.getAbsolutePath(), e);</span>
<span class="fc" id="L135">          }</span>
        }
<span class="fc" id="L137">      });</span>
<span class="fc" id="L138">  }</span>

  private void writeConfFiles(EsInstallation esInstallation) {
<span class="fc" id="L141">    File confDir = esInstallation.getConfDirectory();</span>

<span class="fc" id="L143">    pruneElasticsearchConfDirectory(confDir);</span>
<span class="fc" id="L144">    createElasticsearchConfDirectory(confDir);</span>
<span class="fc" id="L145">    setupElasticsearchSecurity(esInstallation);</span>

<span class="fc" id="L147">    esInstallation.getEsYmlSettings().writeToYmlSettingsFile(esInstallation.getElasticsearchYml());</span>
<span class="fc" id="L148">    esInstallation.getEsJvmOptions().writeToJvmOptionFile(esInstallation.getJvmOptions());</span>
<span class="fc" id="L149">    storeElasticsearchLog4j2Properties(esInstallation);</span>
<span class="fc" id="L150">  }</span>

  private static void pruneElasticsearchConfDirectory(File confDir) {
    try {
<span class="fc" id="L154">      Files.deleteIfExists(confDir.toPath());</span>
<span class="nc" id="L155">    } catch (IOException e) {</span>
<span class="nc" id="L156">      throw new IllegalStateException(&quot;Could not delete Elasticsearch temporary conf directory&quot;, e);</span>
<span class="fc" id="L157">    }</span>
<span class="fc" id="L158">  }</span>

  private static void createElasticsearchConfDirectory(File confDir) {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">    if (!confDir.mkdirs()) {</span>
<span class="nc" id="L162">      String error = format(&quot;Failed to create temporary configuration directory [%s]&quot;, confDir.getAbsolutePath());</span>
<span class="nc" id="L163">      LOG.error(error);</span>
<span class="nc" id="L164">      throw new IllegalStateException(error);</span>
    }
<span class="fc" id="L166">  }</span>

  private void setupElasticsearchSecurity(EsInstallation esInstallation) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">    if (esInstallation.isSecurityEnabled()) {</span>
<span class="fc" id="L170">      EsKeyStoreCli keyStoreCli = EsKeyStoreCli.getInstance(esInstallation);</span>

<span class="fc" id="L172">      setupElasticsearchAuthentication(esInstallation, keyStoreCli);</span>
<span class="fc" id="L173">      setupElasticsearchHttpEncryption(esInstallation, keyStoreCli);</span>

<span class="fc" id="L175">      keyStoreCli.executeWith(this::launchJava);</span>
    }
<span class="fc" id="L177">  }</span>

  private static void setupElasticsearchAuthentication(EsInstallation esInstallation, EsKeyStoreCli keyStoreCli) {
<span class="fc" id="L180">    keyStoreCli.store(BOOTSTRAP_PASSWORD_PROPERTY_KEY, esInstallation.getBootstrapPassword());</span>

<span class="fc" id="L182">    String esConfPath = esInstallation.getConfDirectory().getAbsolutePath();</span>

<span class="fc" id="L184">    Path trustStoreLocation = esInstallation.getTrustStoreLocation();</span>
<span class="fc" id="L185">    Path keyStoreLocation = esInstallation.getKeyStoreLocation();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">    if (trustStoreLocation.equals(keyStoreLocation)) {</span>
<span class="fc" id="L187">      copyFile(trustStoreLocation, Paths.get(esConfPath, trustStoreLocation.toFile().getName()));</span>
    } else {
<span class="fc" id="L189">      copyFile(trustStoreLocation, Paths.get(esConfPath, trustStoreLocation.toFile().getName()));</span>
<span class="fc" id="L190">      copyFile(keyStoreLocation, Paths.get(esConfPath, keyStoreLocation.toFile().getName()));</span>
    }

<span class="fc" id="L193">    esInstallation.getTrustStorePassword().ifPresent(s -&gt; keyStoreCli.store(TRUSTSTORE_PASSWORD_PROPERTY_KEY, s));</span>
<span class="fc" id="L194">    esInstallation.getKeyStorePassword().ifPresent(s -&gt; keyStoreCli.store(KEYSTORE_PASSWORD_PROPERTY_KEY, s));</span>
<span class="fc" id="L195">  }</span>

  private static void setupElasticsearchHttpEncryption(EsInstallation esInstallation, EsKeyStoreCli keyStoreCli) {
<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (esInstallation.isHttpEncryptionEnabled()) {</span>
<span class="fc" id="L199">      String esConfPath = esInstallation.getConfDirectory().getAbsolutePath();</span>
<span class="fc" id="L200">      Path httpKeyStoreLocation = esInstallation.getHttpKeyStoreLocation();</span>
<span class="fc" id="L201">      copyFile(httpKeyStoreLocation, Paths.get(esConfPath, httpKeyStoreLocation.toFile().getName()));</span>
<span class="fc" id="L202">      esInstallation.getHttpKeyStorePassword().ifPresent(s -&gt; keyStoreCli.store(HTTP_KEYSTORE_PASSWORD_PROPERTY_KEY, s));</span>
    }
<span class="fc" id="L204">  }</span>

  private static void copyFile(Path from, Path to) {
    try {
<span class="fc" id="L208">      Files.copy(from, to, StandardCopyOption.REPLACE_EXISTING);</span>
<span class="nc" id="L209">    } catch (IOException e) {</span>
<span class="nc" id="L210">      throw new IllegalStateException(&quot;Could not copy file: &quot; + from, e);</span>
<span class="fc" id="L211">    }</span>
<span class="fc" id="L212">  }</span>

  private static void storeElasticsearchLog4j2Properties(EsInstallation esInstallation) {
<span class="fc" id="L215">    try (FileOutputStream fileOutputStream = new FileOutputStream(esInstallation.getLog4j2PropertiesLocation())) {</span>
<span class="fc" id="L216">      esInstallation.getLog4j2Properties().store(fileOutputStream, &quot;log4j2 properties file for ES bundled in SonarQube&quot;);</span>
<span class="nc" id="L217">    } catch (IOException e) {</span>
<span class="nc" id="L218">      throw new IllegalStateException(&quot;Failed to write ES configuration files&quot;, e);</span>
<span class="fc" id="L219">    }</span>
<span class="fc" id="L220">  }</span>

  private &lt;T extends JvmOptions&gt; Process launchJava(JavaCommand&lt;T&gt; javaCommand) {
<span class="fc" id="L223">    ProcessId processId = javaCommand.getProcessId();</span>
    try {
<span class="fc" id="L225">      ProcessBuilder processBuilder = create(javaCommand);</span>
<span class="fc" id="L226">      logLaunchedCommand(javaCommand, processBuilder);</span>
<span class="fc" id="L227">      return processBuilder.start();</span>
<span class="fc" id="L228">    } catch (Exception e) {</span>
<span class="fc" id="L229">      throw new IllegalStateException(format(&quot;Fail to launch process [%s]&quot;, processId.getHumanReadableName()), e);</span>
    }
  }

  private static &lt;T extends AbstractCommand&gt; void logLaunchedCommand(AbstractCommand&lt;T&gt; command, ProcessBuilder processBuilder) {
<span class="fc" id="L234">    LOG.atInfo()</span>
<span class="fc" id="L235">      .addArgument(command::getProcessId)</span>
<span class="fc" id="L236">      .addArgument(() -&gt; command.getWorkDir().getAbsolutePath())</span>
<span class="fc" id="L237">      .addArgument(() -&gt; String.join(&quot; &quot;, processBuilder.command()))</span>
<span class="fc" id="L238">      .log(&quot;Launch process[{}] from [{}]: {}&quot;);</span>
<span class="fc" id="L239">  }</span>

  private &lt;T extends JvmOptions&gt; ProcessBuilder create(JavaCommand&lt;T&gt; javaCommand) {
<span class="fc" id="L242">    List&lt;String&gt; commands = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L243">    commands.add(buildJavaPath());</span>
<span class="fc" id="L244">    commands.addAll(javaCommand.getJvmOptions().getAll());</span>
<span class="fc" id="L245">    commands.addAll(buildClasspath(javaCommand));</span>
<span class="fc" id="L246">    commands.add(javaCommand.getClassName());</span>
<span class="fc" id="L247">    commands.addAll(javaCommand.getParameters());</span>

<span class="fc bfc" id="L249" title="All 2 branches covered.">    if (javaCommand.getReadsArgumentsFromFile()) {</span>
<span class="fc" id="L250">      commands.add(buildPropertiesFile(javaCommand).getAbsolutePath());</span>
    } else {
<span class="fc" id="L252">      javaCommand.getArguments().forEach((key, value) -&gt; {</span>
<span class="pc bpc" id="L253" title="2 of 4 branches missed.">        if (value != null &amp;&amp; !value.isEmpty()) {</span>
<span class="fc" id="L254">          commands.add(&quot;-E&quot; + key + &quot;=&quot; + value);</span>
        }
<span class="fc" id="L256">      });</span>
    }

<span class="fc" id="L259">    return create(javaCommand, commands);</span>
  }

  private ProcessBuilder create(AbstractCommand&lt;?&gt; command, List&lt;String&gt; commands) {
<span class="fc" id="L263">    ProcessBuilder processBuilder = processBuilderSupplier.get();</span>
<span class="fc" id="L264">    processBuilder.command(commands);</span>
<span class="fc" id="L265">    processBuilder.directory(command.getWorkDir());</span>
<span class="fc" id="L266">    Map&lt;String, String&gt; environment = processBuilder.environment();</span>
<span class="fc" id="L267">    environment.putAll(command.getEnvVariables());</span>
<span class="fc" id="L268">    command.getSuppressedEnvVariables().forEach(environment::remove);</span>
<span class="fc" id="L269">    processBuilder.redirectErrorStream(true);</span>
<span class="fc" id="L270">    return processBuilder;</span>
  }

  private static String buildJavaPath() {
<span class="fc" id="L274">    String separator = System.getProperty(&quot;file.separator&quot;);</span>
<span class="fc" id="L275">    return new File(new File(System.getProperty(&quot;java.home&quot;)), &quot;bin&quot; + separator + &quot;java&quot;).getAbsolutePath();</span>
  }

  private static &lt;T extends JvmOptions&gt; List&lt;String&gt; buildClasspath(JavaCommand&lt;T&gt; javaCommand) {
<span class="fc" id="L279">    String pathSeparator = System.getProperty(&quot;path.separator&quot;);</span>
<span class="fc" id="L280">    return Arrays.asList(&quot;-cp&quot;, String.join(pathSeparator, javaCommand.getClasspath()));</span>
  }

  private File buildPropertiesFile(JavaCommand javaCommand) {
<span class="fc" id="L284">    File propertiesFile = null;</span>
    try {
<span class="fc" id="L286">      propertiesFile = File.createTempFile(&quot;sq-process&quot;, &quot;properties&quot;, tempDir);</span>
<span class="fc" id="L287">      Properties props = new Properties();</span>
<span class="fc" id="L288">      props.putAll(javaCommand.getArguments());</span>
<span class="fc" id="L289">      props.setProperty(PROPERTY_PROCESS_KEY, javaCommand.getProcessId().getKey());</span>
<span class="fc" id="L290">      props.setProperty(PROPERTY_PROCESS_INDEX, Integer.toString(javaCommand.getProcessId().getIpcIndex()));</span>
<span class="fc" id="L291">      props.setProperty(PROPERTY_GRACEFUL_STOP_TIMEOUT_MS, javaCommand.getGracefulStopTimeoutMs() + &quot;&quot;);</span>
<span class="fc" id="L292">      props.setProperty(PROPERTY_SHARED_PATH, tempDir.getAbsolutePath());</span>
<span class="fc" id="L293">      try (OutputStream out = new FileOutputStream(propertiesFile)) {</span>
<span class="fc" id="L294">        props.store(out, format(&quot;Temporary properties file for command [%s]&quot;, javaCommand.getProcessId().getKey()));</span>
      }
<span class="fc" id="L296">      return propertiesFile;</span>
<span class="nc" id="L297">    } catch (Exception e) {</span>
<span class="nc" id="L298">      throw new IllegalStateException(&quot;Cannot write temporary settings to &quot; + propertiesFile, e);</span>
    }
  }

  /**
   * An interface of the methods of {@link java.lang.ProcessBuilder} that we use in {@link ProcessLauncherImpl}.
   * &lt;p&gt;Allows testing creating processes without actualling creating them at OS level&lt;/p&gt;
   */
  public interface ProcessBuilder {
    List&lt;String&gt; command();

    ProcessBuilder command(List&lt;String&gt; commands);

    ProcessBuilder directory(File dir);

    Map&lt;String, String&gt; environment();

    ProcessBuilder redirectErrorStream(boolean b);

    Process start() throws IOException;
  }

<span class="nc" id="L320">  private static class JavaLangProcessBuilder implements ProcessBuilder {</span>
<span class="nc" id="L321">    private final java.lang.ProcessBuilder builder = new java.lang.ProcessBuilder();</span>

    /**
     * @see java.lang.ProcessBuilder#command()
     */
    @Override
    public List&lt;String&gt; command() {
<span class="nc" id="L328">      return builder.command();</span>
    }

    /**
     * @see java.lang.ProcessBuilder#command(List)
     */
    @Override
    public ProcessBuilder command(List&lt;String&gt; commands) {
<span class="nc" id="L336">      builder.command(commands);</span>
<span class="nc" id="L337">      return this;</span>
    }

    /**
     * @see java.lang.ProcessBuilder#directory(File)
     */
    @Override
    public ProcessBuilder directory(File dir) {
<span class="nc" id="L345">      builder.directory(dir);</span>
<span class="nc" id="L346">      return this;</span>
    }

    /**
     * @see java.lang.ProcessBuilder#environment()
     */
    @Override
    public Map&lt;String, String&gt; environment() {
<span class="nc" id="L354">      return builder.environment();</span>
    }

    /**
     * @see java.lang.ProcessBuilder#redirectErrorStream(boolean)
     */
    @Override
    public ProcessBuilder redirectErrorStream(boolean b) {
<span class="nc" id="L362">      builder.redirectErrorStream(b);</span>
<span class="nc" id="L363">      return this;</span>
    }

    /**
     * @see java.lang.ProcessBuilder#start()
     */
    @Override
    public Process start() throws IOException {
<span class="nc" id="L371">      return builder.start();</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>