<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NewCodePeriodResolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.ce.task.projectanalysis.period</a> &gt; <span class="el_source">NewCodePeriodResolver.java</span></div><h1>NewCodePeriodResolver.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.ce.task.projectanalysis.period;

import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.sonar.api.utils.DateUtils;
import org.sonar.api.utils.MessageException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.ce.task.projectanalysis.analysis.AnalysisMetadataHolder;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.component.SnapshotDto;
import org.sonar.db.component.SnapshotQuery;
import org.sonar.db.event.EventDto;
import org.sonar.db.newcodeperiod.NewCodePeriodDto;
import org.sonar.db.newcodeperiod.NewCodePeriodParser;
import org.sonar.db.newcodeperiod.NewCodePeriodType;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static java.lang.String.format;
import static org.sonar.db.component.SnapshotDto.STATUS_PROCESSED;
import static org.sonar.db.component.SnapshotQuery.SORT_FIELD.BY_DATE;
import static org.sonar.db.component.SnapshotQuery.SORT_ORDER.ASC;

public class NewCodePeriodResolver {
<span class="fc" id="L52">  private static final Logger LOG = LoggerFactory.getLogger(NewCodePeriodResolver.class);</span>

  private final DbClient dbClient;
  private final AnalysisMetadataHolder analysisMetadataHolder;

<span class="fc" id="L57">  public NewCodePeriodResolver(DbClient dbClient, AnalysisMetadataHolder analysisMetadataHolder) {</span>
<span class="fc" id="L58">    this.dbClient = dbClient;</span>
<span class="fc" id="L59">    this.analysisMetadataHolder = analysisMetadataHolder;</span>
<span class="fc" id="L60">  }</span>

  @CheckForNull
  public Period resolve(DbSession dbSession, String branchUuid, NewCodePeriodDto newCodePeriodDto, String projectVersion) {
<span class="fc" id="L64">    return toPeriod(newCodePeriodDto.getType(), newCodePeriodDto.getValue(), dbSession, projectVersion, branchUuid);</span>
  }

  @CheckForNull
  private Period toPeriod(NewCodePeriodType type, @Nullable String value, DbSession dbSession, String projectVersion, String rootUuid) {
<span class="pc bpc" id="L69" title="1 of 5 branches missed.">    switch (type) {</span>
      case NUMBER_OF_DAYS:
<span class="fc" id="L71">        checkNotNullValue(value, type);</span>
<span class="fc" id="L72">        Integer days = NewCodePeriodParser.parseDays(value);</span>
<span class="fc" id="L73">        return resolveByDays(dbSession, rootUuid, days, value, analysisMetadataHolder.getAnalysisDate());</span>
      case PREVIOUS_VERSION:
<span class="fc" id="L75">        return resolveByPreviousVersion(dbSession, rootUuid, projectVersion);</span>
      case SPECIFIC_ANALYSIS:
<span class="fc" id="L77">        checkNotNullValue(value, type);</span>
<span class="fc" id="L78">        return resolveBySpecificAnalysis(dbSession, rootUuid, value);</span>
      case REFERENCE_BRANCH:
<span class="fc" id="L80">        checkNotNullValue(value, type);</span>
<span class="fc" id="L81">        return resolveByReferenceBranch(value);</span>
      default:
<span class="nc" id="L83">        throw new IllegalStateException(&quot;Unexpected type: &quot; + type);</span>
    }
  }

  private static Period resolveByReferenceBranch(String value) {
<span class="fc" id="L88">    return newPeriod(NewCodePeriodType.REFERENCE_BRANCH, value, null);</span>
  }

  private Period resolveBySpecificAnalysis(DbSession dbSession, String rootUuid, String value) {
<span class="fc" id="L92">    SnapshotDto baseline = dbClient.snapshotDao().selectByUuid(dbSession, value)</span>
<span class="fc" id="L93">      .filter(t -&gt; t.getRootComponentUuid().equals(rootUuid))</span>
<span class="fc" id="L94">      .orElseThrow(() -&gt; new IllegalStateException(&quot;Analysis '&quot; + value + &quot;' of project '&quot; + rootUuid</span>
        + &quot;' defined as the baseline does not exist&quot;));
<span class="fc" id="L96">    LOG.debug(&quot;Resolving new code period with a specific analysis&quot;);</span>
<span class="fc" id="L97">    return newPeriod(NewCodePeriodType.SPECIFIC_ANALYSIS, value, baseline.getCreatedAt());</span>
  }

  private Period resolveByPreviousVersion(DbSession dbSession, String rootComponentUuid, String projectVersion) {
<span class="fc" id="L101">    List&lt;EventDto&gt; versions = dbClient.eventDao().selectVersionsByMostRecentFirst(dbSession, rootComponentUuid);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">    if (versions.isEmpty()) {</span>
<span class="fc" id="L103">      return findOldestAnalysis(dbSession, rootComponentUuid);</span>
    }

<span class="fc" id="L106">    String mostRecentVersion = Optional.ofNullable(versions.iterator().next().getName())</span>
<span class="pc" id="L107">      .orElseThrow(() -&gt; new IllegalStateException(&quot;selectVersionsByMostRecentFirst returned a DTO which didn't have a name&quot;));</span>

<span class="fc bfc" id="L109" title="All 4 branches covered.">    if (versions.size() == 1 &amp;&amp; projectVersion.equals(mostRecentVersion)) {</span>
<span class="fc" id="L110">      return findOldestAnalysis(dbSession, rootComponentUuid);</span>
    }

<span class="fc" id="L113">    return resolvePreviousVersion(dbSession, projectVersion, versions, mostRecentVersion);</span>
  }

  private Period resolveByDays(DbSession dbSession, String rootUuid, Integer days, String value, long referenceDate) {
<span class="fc bfc" id="L117" title="All 2 branches covered.">    checkPeriodProperty(days &gt; 0, value, &quot;number of days is &lt;= 0&quot;);</span>
<span class="fc" id="L118">    List&lt;SnapshotDto&gt; snapshots = dbClient.snapshotDao().selectAnalysesByQuery(dbSession, createCommonQuery(rootUuid)</span>
<span class="fc" id="L119">      .setCreatedBefore(referenceDate).setSort(BY_DATE, ASC));</span>

<span class="fc" id="L121">    Instant targetDate = DateUtils.addDays(Instant.ofEpochMilli(referenceDate), -days);</span>
<span class="fc" id="L122">    LOG.debug(&quot;Resolving new code period by {} days: {}&quot;, days, supplierToString(() -&gt; logDate(targetDate)));</span>
<span class="fc" id="L123">    SnapshotDto snapshot = findNearestSnapshotToTargetDate(snapshots, targetDate);</span>
<span class="fc" id="L124">    return newPeriod(NewCodePeriodType.NUMBER_OF_DAYS, String.valueOf((int) days), snapshot.getCreatedAt());</span>
  }

  private Period resolvePreviousVersion(DbSession dbSession, String currentVersion, List&lt;EventDto&gt; versions, String mostRecentVersion) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">    EventDto previousVersion = versions.get(currentVersion.equals(mostRecentVersion) ? 1 : 0);</span>
<span class="fc" id="L129">    LOG.debug(&quot;Resolving new code period by previous version: {}&quot;, previousVersion.getName());</span>
<span class="fc" id="L130">    return newPeriod(dbSession, previousVersion);</span>
  }

  private Period findOldestAnalysis(DbSession dbSession, String rootComponentUuid) {
<span class="fc" id="L134">    LOG.debug(&quot;Resolving first analysis as new code period as there is only one existing version&quot;);</span>
<span class="fc" id="L135">    Optional&lt;Period&gt; period = dbClient.snapshotDao().selectOldestAnalysis(dbSession, rootComponentUuid)</span>
<span class="fc" id="L136">      .map(dto -&gt; newPeriod(NewCodePeriodType.PREVIOUS_VERSION, null, dto.getCreatedAt()));</span>
<span class="fc" id="L137">    ensureNotOnFirstAnalysis(period.isPresent());</span>
<span class="fc" id="L138">    return period.get();</span>
  }

  private Period newPeriod(DbSession dbSession, EventDto previousVersion) {
<span class="fc" id="L142">    Optional&lt;Period&gt; period = dbClient.snapshotDao().selectByUuid(dbSession, previousVersion.getAnalysisUuid())</span>
<span class="fc" id="L143">      .map(dto -&gt; newPeriod(NewCodePeriodType.PREVIOUS_VERSION, dto.getProjectVersion(), dto.getCreatedAt()));</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">    if (!period.isPresent()) {</span>
<span class="nc" id="L145">      throw new IllegalStateException(format(&quot;Analysis '%s' for version event '%s' has been deleted&quot;,</span>
<span class="nc" id="L146">        previousVersion.getAnalysisUuid(), previousVersion.getName()));</span>
    }
<span class="fc" id="L148">    return period.get();</span>
  }

  private static Period newPeriod(NewCodePeriodType type, @Nullable String value, @Nullable Long date) {
<span class="fc" id="L152">    return new Period(type.name(), value, date);</span>
  }

  private static Object supplierToString(Supplier&lt;String&gt; s) {
<span class="fc" id="L156">    return new Object() {</span>
      @Override
      public String toString() {
<span class="fc" id="L159">        return s.get();</span>
      }
    };
  }

  private static SnapshotQuery createCommonQuery(String projectUuid) {
<span class="fc" id="L165">    return new SnapshotQuery().setRootComponentUuid(projectUuid).setStatus(STATUS_PROCESSED);</span>
  }

  private static SnapshotDto findNearestSnapshotToTargetDate(List&lt;SnapshotDto&gt; snapshots, Instant targetDate) {
    // FIXME shouldn't this be the first analysis after targetDate?
<span class="fc" id="L170">    Duration bestDuration = null;</span>
<span class="fc" id="L171">    SnapshotDto nearest = null;</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">    ensureNotOnFirstAnalysis(!snapshots.isEmpty());</span>

<span class="fc bfc" id="L175" title="All 2 branches covered.">    for (SnapshotDto snapshot : snapshots) {</span>
<span class="fc" id="L176">      Instant createdAt = Instant.ofEpochMilli(snapshot.getCreatedAt());</span>
<span class="fc" id="L177">      Duration duration = Duration.between(targetDate, createdAt).abs();</span>
<span class="pc bpc" id="L178" title="3 of 4 branches missed.">      if (bestDuration == null || duration.compareTo(bestDuration) &lt;= 0) {</span>
<span class="fc" id="L179">        bestDuration = duration;</span>
<span class="fc" id="L180">        nearest = snapshot;</span>
      }
<span class="fc" id="L182">    }</span>
<span class="fc" id="L183">    return nearest;</span>
  }

  private static void checkPeriodProperty(boolean test, String propertyValue, String testDescription, Object... args) {
<span class="fc bfc" id="L187" title="All 2 branches covered.">    if (!test) {</span>
<span class="fc" id="L188">      LOG.debug(&quot;Invalid code period '{}': {}&quot;, propertyValue, supplierToString(() -&gt; format(testDescription, args)));</span>
<span class="fc" id="L189">      throw MessageException.of(format(&quot;Invalid new code period. '%s' is not one of: &quot; +</span>
        &quot;integer &gt; 0, date before current analysis j, \&quot;previous_version\&quot;, or version string that exists in the project' \n&quot; +
        &quot;Please contact a project administrator to correct this setting&quot;, propertyValue));
    }
<span class="fc" id="L193">  }</span>

  private static void ensureNotOnFirstAnalysis(boolean expression) {
<span class="fc" id="L196">    checkState(expression, &quot;Attempting to resolve period while no analysis exist for project&quot;);</span>
<span class="fc" id="L197">  }</span>

  private static void checkNotNullValue(@Nullable String value, NewCodePeriodType type) {
<span class="fc" id="L200">    checkNotNull(value, &quot;Value can't be null with type %s&quot;, type);</span>
<span class="fc" id="L201">  }</span>

  private static String logDate(Instant instant) {
<span class="fc" id="L204">    return DateUtils.formatDate(instant.truncatedTo(ChronoUnit.SECONDS));</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>