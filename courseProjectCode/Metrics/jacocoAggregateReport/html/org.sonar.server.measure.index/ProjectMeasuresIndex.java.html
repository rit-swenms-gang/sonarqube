<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProjectMeasuresIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.measure.index</a> &gt; <span class="el_source">ProjectMeasuresIndex.java</span></div><h1>ProjectMeasuresIndex.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.measure.index;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import org.apache.lucene.search.TotalHits;
import org.apache.lucene.search.join.ScoreMode;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.core.TimeValue;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.search.aggregations.AbstractAggregationBuilder;
import org.elasticsearch.search.aggregations.AggregationBuilders;
import org.elasticsearch.search.aggregations.BucketOrder;
import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation.Bucket;
import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;
import org.elasticsearch.search.aggregations.bucket.filter.FiltersAggregator.KeyedFilter;
import org.elasticsearch.search.aggregations.bucket.nested.Nested;
import org.elasticsearch.search.aggregations.bucket.range.RangeAggregationBuilder;
import org.elasticsearch.search.aggregations.bucket.terms.IncludeExclude;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;
import org.elasticsearch.search.aggregations.metrics.Sum;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.sort.FieldSortBuilder;
import org.elasticsearch.search.sort.NestedSortBuilder;
import org.sonar.db.component.ComponentQualifiers;
import org.sonar.api.server.ServerSide;
import org.sonar.api.utils.System2;
import org.sonar.server.es.EsClient;
import org.sonar.server.es.SearchIdResult;
import org.sonar.server.es.SearchOptions;
import org.sonar.server.es.newindex.DefaultIndexSettingsElement;
import org.sonar.server.es.searchrequest.NestedFieldTopAggregationDefinition;
import org.sonar.server.es.searchrequest.RequestFiltersComputer;
import org.sonar.server.es.searchrequest.RequestFiltersComputer.AllFilters;
import org.sonar.server.es.searchrequest.SimpleFieldTopAggregationDefinition;
import org.sonar.server.es.searchrequest.SubAggregationHelper;
import org.sonar.server.es.searchrequest.TopAggregationDefinition;
import org.sonar.server.es.searchrequest.TopAggregationDefinition.NestedFieldFilterScope;
import org.sonar.server.es.searchrequest.TopAggregationDefinition.SimpleFieldFilterScope;
import org.sonar.server.es.searchrequest.TopAggregationHelper;
import org.sonar.server.measure.index.ProjectMeasuresQuery.MetricCriterion;
import org.sonar.server.permission.index.WebAuthorizationTypeSupport;

import static com.google.common.base.Preconditions.checkArgument;
import static java.util.Collections.emptyList;
import static java.util.Optional.ofNullable;
import static org.elasticsearch.index.query.QueryBuilders.boolQuery;
import static org.elasticsearch.index.query.QueryBuilders.nestedQuery;
import static org.elasticsearch.index.query.QueryBuilders.rangeQuery;
import static org.elasticsearch.index.query.QueryBuilders.termQuery;
import static org.elasticsearch.index.query.QueryBuilders.termsQuery;
import static org.elasticsearch.search.aggregations.AggregationBuilders.filters;
import static org.elasticsearch.search.aggregations.AggregationBuilders.sum;
import static org.elasticsearch.search.sort.SortOrder.ASC;
import static org.elasticsearch.search.sort.SortOrder.DESC;
import static org.sonar.api.measures.CoreMetrics.ALERT_STATUS_KEY;
import static org.sonar.api.measures.CoreMetrics.COVERAGE_KEY;
import static org.sonar.api.measures.CoreMetrics.DUPLICATED_LINES_DENSITY_KEY;
import static org.sonar.api.measures.CoreMetrics.NCLOC_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_COVERAGE_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_DUPLICATED_LINES_DENSITY_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_LINES_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_MAINTAINABILITY_RATING_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_RELIABILITY_RATING_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_SECURITY_HOTSPOTS_REVIEWED_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_SECURITY_RATING_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_SECURITY_REVIEW_RATING_KEY;
import static org.sonar.api.measures.CoreMetrics.RELIABILITY_RATING_KEY;
import static org.sonar.api.measures.CoreMetrics.SECURITY_HOTSPOTS_REVIEWED_KEY;
import static org.sonar.api.measures.CoreMetrics.SECURITY_RATING_KEY;
import static org.sonar.api.measures.CoreMetrics.SECURITY_REVIEW_RATING_KEY;
import static org.sonar.api.measures.CoreMetrics.SQALE_RATING_KEY;
import static org.sonar.core.metric.SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_MAINTAINABILITY_RATING_KEY;
import static org.sonar.core.metric.SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_RELIABILITY_RATING_KEY;
import static org.sonar.core.metric.SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_SECURITY_RATING_KEY;
import static org.sonar.core.metric.SoftwareQualitiesMetrics.SOFTWARE_QUALITY_MAINTAINABILITY_RATING_KEY;
import static org.sonar.core.metric.SoftwareQualitiesMetrics.SOFTWARE_QUALITY_RELIABILITY_RATING_KEY;
import static org.sonar.core.metric.SoftwareQualitiesMetrics.SOFTWARE_QUALITY_SECURITY_RATING_KEY;
import static org.sonar.server.es.EsUtils.escapeSpecialRegexChars;
import static org.sonar.server.es.EsUtils.termsToMap;
import static org.sonar.server.es.IndexType.FIELD_INDEX_TYPE;
import static org.sonar.server.es.SearchOptions.MAX_PAGE_SIZE;
import static org.sonar.server.es.searchrequest.TopAggregationDefinition.STICKY;
import static org.sonar.server.es.searchrequest.TopAggregationHelper.NO_EXTRA_FILTER;
import static org.sonar.server.measure.index.ProjectMeasuresDoc.QUALITY_GATE_STATUS;
import static org.sonar.server.measure.index.ProjectMeasuresIndex.Facet.ALERT_STATUS;
import static org.sonar.server.measure.index.ProjectMeasuresIndex.Facet.LANGUAGES;
import static org.sonar.server.measure.index.ProjectMeasuresIndex.Facet.TAGS;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_ANALYSED_AT;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_CREATED_AT;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_KEY;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_LANGUAGES;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_MEASURES;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_MEASURES_MEASURE_KEY;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_MEASURES_MEASURE_VALUE;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_NAME;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_NCLOC_DISTRIBUTION;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_NCLOC_DISTRIBUTION_LANGUAGE;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_NCLOC_DISTRIBUTION_NCLOC;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_QUALIFIER;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_QUALITY_GATE_STATUS;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.FIELD_TAGS;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.SUB_FIELD_MEASURES_KEY;
import static org.sonar.server.measure.index.ProjectMeasuresIndexDefinition.TYPE_PROJECT_MEASURES;
import static org.sonar.server.measure.index.ProjectMeasuresQuery.SORT_BY_CREATION_DATE;
import static org.sonar.server.measure.index.ProjectMeasuresQuery.SORT_BY_LAST_ANALYSIS_DATE;
import static org.sonar.server.measure.index.ProjectMeasuresQuery.SORT_BY_NAME;
import static org.sonarqube.ws.client.project.ProjectsWsParameters.FILTER_LANGUAGES;
import static org.sonarqube.ws.client.project.ProjectsWsParameters.FILTER_QUALIFIER;
import static org.sonarqube.ws.client.project.ProjectsWsParameters.FILTER_TAGS;

@ServerSide
public class ProjectMeasuresIndex {
  private static final int FACET_DEFAULT_SIZE = 10;

<span class="fc" id="L149">  private static final double[] LINES_THRESHOLDS = {1_000D, 10_000D, 100_000D, 500_000D};</span>
<span class="fc" id="L150">  private static final double[] COVERAGE_THRESHOLDS = {30D, 50D, 70D, 80D};</span>
<span class="fc" id="L151">  private static final double[] SECURITY_REVIEW_RATING_THRESHOLDS = {30D, 50D, 70D, 80D};</span>
<span class="fc" id="L152">  private static final double[] DUPLICATIONS_THRESHOLDS = {3D, 5D, 10D, 20D};</span>
  private static final int SCROLL_SIZE = 5000;
<span class="fc" id="L154">  private static final TimeValue KEEP_ALIVE_SCROLL_DURATION = TimeValue.timeValueMinutes(1L);</span>

<span class="fc" id="L156">  public enum Facet {</span>
<span class="fc" id="L157">    NCLOC(new RangeMeasureFacet(NCLOC_KEY, LINES_THRESHOLDS)),</span>
<span class="fc" id="L158">    NEW_LINES(new RangeMeasureFacet(NEW_LINES_KEY, LINES_THRESHOLDS)),</span>
<span class="fc" id="L159">    DUPLICATED_LINES_DENSITY(new RangeWithNoDataMeasureFacet(DUPLICATED_LINES_DENSITY_KEY, DUPLICATIONS_THRESHOLDS)),</span>
<span class="fc" id="L160">    NEW_DUPLICATED_LINES_DENSITY(new RangeWithNoDataMeasureFacet(NEW_DUPLICATED_LINES_DENSITY_KEY, DUPLICATIONS_THRESHOLDS)),</span>
<span class="fc" id="L161">    COVERAGE(new RangeWithNoDataMeasureFacet(COVERAGE_KEY, COVERAGE_THRESHOLDS)),</span>
<span class="fc" id="L162">    NEW_COVERAGE(new RangeWithNoDataMeasureFacet(NEW_COVERAGE_KEY, COVERAGE_THRESHOLDS)),</span>

    //RuleType ratings
<span class="fc" id="L165">    SQALE_RATING(new RatingMeasureFacet(SQALE_RATING_KEY)),</span>
<span class="fc" id="L166">    NEW_MAINTAINABILITY_RATING(new RatingMeasureFacet(NEW_MAINTAINABILITY_RATING_KEY)),</span>
<span class="fc" id="L167">    RELIABILITY_RATING(new RatingMeasureFacet(RELIABILITY_RATING_KEY)),</span>
<span class="fc" id="L168">    NEW_RELIABILITY_RATING(new RatingMeasureFacet(NEW_RELIABILITY_RATING_KEY)),</span>
<span class="fc" id="L169">    SECURITY_RATING(new RatingMeasureFacet(SECURITY_RATING_KEY)),</span>
<span class="fc" id="L170">    NEW_SECURITY_RATING(new RatingMeasureFacet(NEW_SECURITY_RATING_KEY)),</span>
<span class="fc" id="L171">    SECURITY_REVIEW_RATING(new RatingMeasureFacet(SECURITY_REVIEW_RATING_KEY)),</span>
<span class="fc" id="L172">    NEW_SECURITY_REVIEW_RATING(new RatingMeasureFacet(NEW_SECURITY_REVIEW_RATING_KEY)),</span>

    //Software quality ratings
<span class="fc" id="L175">    SOFTWARE_QUALITY_MAINTAINABILITY_RATING(new RatingMeasureFacet(SOFTWARE_QUALITY_MAINTAINABILITY_RATING_KEY)),</span>
<span class="fc" id="L176">    NEW_SOFTWARE_QUALITY_MAINTAINABILITY_RATING(new RatingMeasureFacet(NEW_SOFTWARE_QUALITY_MAINTAINABILITY_RATING_KEY)),</span>
<span class="fc" id="L177">    SOFTWARE_QUALITY_RELIABILITY_RATING(new RatingMeasureFacet(SOFTWARE_QUALITY_RELIABILITY_RATING_KEY)),</span>
<span class="fc" id="L178">    NEW_SOFTWARE_QUALITY_RELIABILITY_RATING(new RatingMeasureFacet(NEW_SOFTWARE_QUALITY_RELIABILITY_RATING_KEY)),</span>
<span class="fc" id="L179">    SOFTWARE_QUALITY_SECURITY_RATING(new RatingMeasureFacet(SOFTWARE_QUALITY_SECURITY_RATING_KEY)),</span>
<span class="fc" id="L180">    NEW_SOFTWARE_QUALITY_SECURITY_RATING(new RatingMeasureFacet(NEW_SOFTWARE_QUALITY_SECURITY_RATING_KEY)),</span>

<span class="fc" id="L182">    SECURITY_HOTSPOTS_REVIEWED(new RangeMeasureFacet(SECURITY_HOTSPOTS_REVIEWED_KEY, SECURITY_REVIEW_RATING_THRESHOLDS)),</span>
<span class="fc" id="L183">    NEW_SECURITY_HOTSPOTS_REVIEWED(new RangeMeasureFacet(NEW_SECURITY_HOTSPOTS_REVIEWED_KEY, SECURITY_REVIEW_RATING_THRESHOLDS)),</span>
<span class="fc" id="L184">    ALERT_STATUS(new MeasureFacet(ALERT_STATUS_KEY, ProjectMeasuresIndex::buildAlertStatusFacet)),</span>
<span class="fc" id="L185">    LANGUAGES(FILTER_LANGUAGES, FIELD_LANGUAGES, STICKY, ProjectMeasuresIndex::buildLanguageFacet),</span>
<span class="fc" id="L186">    QUALIFIER(FILTER_QUALIFIER, FIELD_QUALIFIER, STICKY, ProjectMeasuresIndex::buildQualifierFacet),</span>
<span class="fc" id="L187">    TAGS(FILTER_TAGS, FIELD_TAGS, STICKY, ProjectMeasuresIndex::buildTagsFacet);</span>

    private final String name;
    private final TopAggregationDefinition&lt;?&gt; topAggregation;
    private final FacetBuilder facetBuilder;

<span class="fc" id="L193">    Facet(String name, String fieldName, boolean sticky, FacetBuilder facetBuilder) {</span>
<span class="fc" id="L194">      this.name = name;</span>
<span class="fc" id="L195">      this.topAggregation = new SimpleFieldTopAggregationDefinition(fieldName, sticky);</span>
<span class="fc" id="L196">      this.facetBuilder = facetBuilder;</span>
<span class="fc" id="L197">    }</span>

<span class="fc" id="L199">    Facet(MeasureFacet measureFacet) {</span>
<span class="fc" id="L200">      this.name = measureFacet.metricKey;</span>
<span class="fc" id="L201">      this.topAggregation = measureFacet.topAggregation;</span>
<span class="fc" id="L202">      this.facetBuilder = measureFacet.facetBuilder;</span>
<span class="fc" id="L203">    }</span>

    public String getName() {
<span class="fc" id="L206">      return name;</span>
    }

    public TopAggregationDefinition&lt;?&gt; getTopAggregationDef() {
<span class="fc" id="L210">      return topAggregation;</span>
    }

    public TopAggregationDefinition.FilterScope getFilterScope() {
<span class="fc" id="L214">      return topAggregation.getFilterScope();</span>
    }

    public FacetBuilder getFacetBuilder() {
<span class="fc" id="L218">      return facetBuilder;</span>
    }
  }

<span class="fc" id="L222">  private static final Map&lt;String, Facet&gt; FACETS_BY_NAME = Arrays.stream(Facet.values())</span>
<span class="fc" id="L223">    .collect(Collectors.toMap(Facet::getName, Function.identity()));</span>

  private final EsClient client;
  private final WebAuthorizationTypeSupport authorizationTypeSupport;
  private final System2 system2;

<span class="fc" id="L229">  public ProjectMeasuresIndex(EsClient client, WebAuthorizationTypeSupport authorizationTypeSupport, System2 system2) {</span>
<span class="fc" id="L230">    this.client = client;</span>
<span class="fc" id="L231">    this.authorizationTypeSupport = authorizationTypeSupport;</span>
<span class="fc" id="L232">    this.system2 = system2;</span>
<span class="fc" id="L233">  }</span>

  public SearchIdResult&lt;String&gt; search(ProjectMeasuresQuery query, SearchOptions searchOptions) {
<span class="fc" id="L236">    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()</span>
<span class="fc" id="L237">      .fetchSource(false)</span>
<span class="fc" id="L238">      .trackTotalHits(true)</span>
<span class="fc" id="L239">      .from(searchOptions.getOffset())</span>
<span class="fc" id="L240">      .size(searchOptions.getLimit());</span>

<span class="fc" id="L242">    AllFilters allFilters = createFilters(query);</span>
<span class="fc" id="L243">    RequestFiltersComputer filtersComputer = createFiltersComputer(searchOptions, allFilters);</span>
<span class="fc" id="L244">    addFacets(searchSourceBuilder, searchOptions, filtersComputer, query);</span>
<span class="fc" id="L245">    addSort(query, searchSourceBuilder);</span>

<span class="fc" id="L247">    filtersComputer.getQueryFilters().ifPresent(searchSourceBuilder::query);</span>
<span class="fc" id="L248">    filtersComputer.getPostFilters().ifPresent(searchSourceBuilder::postFilter);</span>
<span class="fc" id="L249">    SearchResponse response = client.search(EsClient.prepareSearch(TYPE_PROJECT_MEASURES.getMainType())</span>
<span class="fc" id="L250">      .source(searchSourceBuilder));</span>
<span class="fc" id="L251">    return new SearchIdResult&lt;&gt;(response, id -&gt; id, system2.getDefaultTimeZone().toZoneId());</span>
  }

  private static RequestFiltersComputer createFiltersComputer(SearchOptions searchOptions, AllFilters allFilters) {
<span class="fc" id="L255">    Collection&lt;String&gt; facetNames = searchOptions.getFacets();</span>
<span class="fc" id="L256">    Set&lt;TopAggregationDefinition&lt;?&gt;&gt; facets = facetNames.stream()</span>
<span class="fc" id="L257">      .map(FACETS_BY_NAME::get)</span>
<span class="fc" id="L258">      .filter(Objects::nonNull)</span>
<span class="fc" id="L259">      .map(Facet::getTopAggregationDef)</span>
<span class="fc" id="L260">      .collect(Collectors.toSet());</span>
<span class="fc" id="L261">    return new RequestFiltersComputer(allFilters, facets);</span>
  }

  public ProjectMeasuresStatistics searchSupportStatistics() {
<span class="fc" id="L265">    SearchRequest projectMeasuresSearchRequest = buildProjectMeasureSearchRequest();</span>
<span class="fc" id="L266">    SearchResponse projectMeasures = client.search(projectMeasuresSearchRequest);</span>
<span class="fc" id="L267">    return buildProjectMeasuresStatistics(projectMeasures);</span>
  }

  private static SearchRequest buildProjectMeasureSearchRequest() {
<span class="fc" id="L271">    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()</span>
<span class="fc" id="L272">      .fetchSource(false)</span>
<span class="fc" id="L273">      .size(0);</span>

<span class="fc" id="L275">    BoolQueryBuilder esFilter = boolQuery()</span>
<span class="fc" id="L276">      .filter(termQuery(FIELD_INDEX_TYPE, TYPE_PROJECT_MEASURES.getName()))</span>
<span class="fc" id="L277">      .filter(termQuery(FIELD_QUALIFIER, ComponentQualifiers.PROJECT));</span>
<span class="fc" id="L278">    searchSourceBuilder.query(esFilter);</span>
<span class="fc" id="L279">    searchSourceBuilder.aggregation(AggregationBuilders.terms(FIELD_LANGUAGES)</span>
<span class="fc" id="L280">      .field(FIELD_LANGUAGES)</span>
<span class="fc" id="L281">      .size(MAX_PAGE_SIZE)</span>
<span class="fc" id="L282">      .minDocCount(1)</span>
<span class="fc" id="L283">      .order(BucketOrder.count(false)));</span>
<span class="fc" id="L284">    searchSourceBuilder.aggregation(AggregationBuilders.nested(FIELD_NCLOC_DISTRIBUTION, FIELD_NCLOC_DISTRIBUTION)</span>
<span class="fc" id="L285">      .subAggregation(AggregationBuilders.terms(FIELD_NCLOC_DISTRIBUTION + &quot;_terms&quot;)</span>
<span class="fc" id="L286">        .field(FIELD_NCLOC_DISTRIBUTION_LANGUAGE)</span>
<span class="fc" id="L287">        .size(MAX_PAGE_SIZE)</span>
<span class="fc" id="L288">        .minDocCount(1)</span>
<span class="fc" id="L289">        .order(BucketOrder.count(false))</span>
<span class="fc" id="L290">        .subAggregation(sum(FIELD_NCLOC_DISTRIBUTION_NCLOC).field(FIELD_NCLOC_DISTRIBUTION_NCLOC))));</span>
<span class="fc" id="L291">    searchSourceBuilder.aggregation(AggregationBuilders.nested(NCLOC_KEY, FIELD_MEASURES)</span>
<span class="fc" id="L292">      .subAggregation(AggregationBuilders.filter(NCLOC_KEY + &quot;_filter&quot;, termQuery(FIELD_MEASURES_MEASURE_KEY, NCLOC_KEY))</span>
<span class="fc" id="L293">        .subAggregation(sum(NCLOC_KEY + &quot;_filter_sum&quot;).field(FIELD_MEASURES_MEASURE_VALUE))));</span>
<span class="fc" id="L294">    searchSourceBuilder.size(SCROLL_SIZE);</span>

<span class="fc" id="L296">    return EsClient.prepareSearch(TYPE_PROJECT_MEASURES.getMainType()).source(searchSourceBuilder).scroll(KEEP_ALIVE_SCROLL_DURATION);</span>
  }

  private static ProjectMeasuresStatistics buildProjectMeasuresStatistics(SearchResponse response) {
<span class="fc" id="L300">    ProjectMeasuresStatistics.Builder statistics = ProjectMeasuresStatistics.builder();</span>
<span class="fc" id="L301">    statistics.setProjectCount(getTotalHits(response.getHits().getTotalHits()).value);</span>
<span class="fc" id="L302">    statistics.setProjectCountByLanguage(termsToMap(response.getAggregations().get(FIELD_LANGUAGES)));</span>

<span class="fc" id="L304">    Function&lt;Terms.Bucket, Long&gt; bucketToNcloc = bucket -&gt; Math.round(((Sum) bucket.getAggregations().get(FIELD_NCLOC_DISTRIBUTION_NCLOC)).getValue());</span>
<span class="fc" id="L305">    Map&lt;String, Long&gt; nclocByLanguage = Stream.of((Nested) response.getAggregations().get(FIELD_NCLOC_DISTRIBUTION))</span>
<span class="fc" id="L306">      .map(nested -&gt; (Terms) nested.getAggregations().get(nested.getName() + &quot;_terms&quot;))</span>
<span class="fc" id="L307">      .flatMap(terms -&gt; terms.getBuckets().stream())</span>
<span class="fc" id="L308">      .collect(Collectors.toMap(Bucket::getKeyAsString, bucketToNcloc));</span>
<span class="fc" id="L309">    statistics.setNclocByLanguage(nclocByLanguage);</span>

<span class="fc" id="L311">    return statistics.build();</span>
  }

  private static TotalHits getTotalHits(@Nullable TotalHits totalHits) {
<span class="pc" id="L315">    return ofNullable(totalHits).orElseThrow(() -&gt; new IllegalStateException(&quot;Could not get total hits of search results&quot;));</span>
  }

  private static void addSort(ProjectMeasuresQuery query, SearchSourceBuilder requestBuilder) {
<span class="fc" id="L319">    String sort = query.getSort();</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">    if (SORT_BY_NAME.equals(sort)) {</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">      requestBuilder.sort(DefaultIndexSettingsElement.SORTABLE_ANALYZER.subField(FIELD_NAME), query.isAsc() ? ASC : DESC);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">    } else if (SORT_BY_LAST_ANALYSIS_DATE.equals(sort)) {</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">      requestBuilder.sort(FIELD_ANALYSED_AT, query.isAsc() ? ASC : DESC);</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">    } else if (SORT_BY_CREATION_DATE.equals(sort)) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">      requestBuilder.sort(FIELD_CREATED_AT, query.isAsc() ? ASC : DESC);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">    } else if (ALERT_STATUS_KEY.equals(sort)) {</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">      requestBuilder.sort(FIELD_QUALITY_GATE_STATUS, query.isAsc() ? ASC : DESC);</span>
<span class="fc" id="L328">      requestBuilder.sort(DefaultIndexSettingsElement.SORTABLE_ANALYZER.subField(FIELD_NAME), ASC);</span>
    } else {
<span class="fc" id="L330">      addMetricSort(query, requestBuilder, sort);</span>
<span class="fc" id="L331">      requestBuilder.sort(DefaultIndexSettingsElement.SORTABLE_ANALYZER.subField(FIELD_NAME), ASC);</span>
    }
    // last sort is by key in order to be deterministic when same value
<span class="fc" id="L334">    requestBuilder.sort(FIELD_KEY, ASC);</span>
<span class="fc" id="L335">  }</span>

  private static void addMetricSort(ProjectMeasuresQuery query, SearchSourceBuilder requestBuilder, String sort) {
<span class="fc" id="L338">    requestBuilder.sort(</span>
      new FieldSortBuilder(FIELD_MEASURES_MEASURE_VALUE)
<span class="fc" id="L340">        .setNestedSort(</span>
          new NestedSortBuilder(FIELD_MEASURES)
<span class="fc" id="L342">            .setFilter(termQuery(FIELD_MEASURES_MEASURE_KEY, sort)))</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">        .order(query.isAsc() ? ASC : DESC));</span>
<span class="fc" id="L344">  }</span>

  private static void addFacets(SearchSourceBuilder esRequest, SearchOptions options, RequestFiltersComputer filtersComputer, ProjectMeasuresQuery query) {
<span class="fc" id="L347">    TopAggregationHelper topAggregationHelper = new TopAggregationHelper(filtersComputer, new SubAggregationHelper());</span>
<span class="fc" id="L348">    options.getFacets().stream()</span>
<span class="fc" id="L349">      .map(FACETS_BY_NAME::get)</span>
<span class="fc" id="L350">      .filter(Objects::nonNull)</span>
<span class="fc" id="L351">      .map(facet -&gt; facet.getFacetBuilder().buildFacet(facet, query, topAggregationHelper))</span>
<span class="fc" id="L352">      .forEach(esRequest::aggregation);</span>
<span class="fc" id="L353">  }</span>

  private static AbstractAggregationBuilder&lt;?&gt; createRangeFacet(String metricKey, double[] thresholds) {
<span class="fc" id="L356">    RangeAggregationBuilder rangeAgg = AggregationBuilders.range(metricKey)</span>
<span class="fc" id="L357">      .field(FIELD_MEASURES_MEASURE_VALUE);</span>
<span class="fc" id="L358">    final int lastIndex = thresholds.length - 1;</span>
<span class="fc" id="L359">    IntStream.range(0, thresholds.length)</span>
<span class="fc" id="L360">      .forEach(i -&gt; {</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (i == 0) {</span>
<span class="fc" id="L362">          rangeAgg.addUnboundedTo(thresholds[0]);</span>
<span class="fc" id="L363">          rangeAgg.addRange(thresholds[0], thresholds[1]);</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        } else if (i == lastIndex) {</span>
<span class="fc" id="L365">          rangeAgg.addUnboundedFrom(thresholds[lastIndex]);</span>
        } else {
<span class="fc" id="L367">          rangeAgg.addRange(thresholds[i], thresholds[i + 1]);</span>
        }
<span class="fc" id="L369">      });</span>

<span class="fc" id="L371">    return AggregationBuilders.nested(&quot;nested_&quot; + metricKey, FIELD_MEASURES)</span>
<span class="fc" id="L372">      .subAggregation(</span>
<span class="fc" id="L373">        AggregationBuilders.filter(&quot;filter_&quot; + metricKey, termsQuery(FIELD_MEASURES_MEASURE_KEY, metricKey))</span>
<span class="fc" id="L374">          .subAggregation(rangeAgg));</span>
  }

  private static AbstractAggregationBuilder&lt;?&gt; createQualityGateFacet() {
<span class="fc" id="L378">    return filters(</span>
      ALERT_STATUS_KEY,
      QUALITY_GATE_STATUS
<span class="fc" id="L381">        .entrySet()</span>
<span class="fc" id="L382">        .stream()</span>
<span class="fc" id="L383">        .map(entry -&gt; new KeyedFilter(entry.getKey(), termQuery(FIELD_QUALITY_GATE_STATUS, entry.getValue())))</span>
<span class="fc" id="L384">        .toArray(KeyedFilter[]::new));</span>
  }

  private static AbstractAggregationBuilder&lt;?&gt; createQualifierFacet() {
<span class="fc" id="L388">    return filters(</span>
      FILTER_QUALIFIER,
<span class="fc" id="L390">      Stream.of(ComponentQualifiers.APP, ComponentQualifiers.PROJECT)</span>
<span class="fc" id="L391">        .map(qualifier -&gt; new KeyedFilter(qualifier, termQuery(FIELD_QUALIFIER, qualifier)))</span>
<span class="fc" id="L392">        .toArray(KeyedFilter[]::new));</span>
  }

  private AllFilters createFilters(ProjectMeasuresQuery query) {
<span class="fc" id="L396">    AllFilters filters = RequestFiltersComputer.newAllFilters();</span>
<span class="fc" id="L397">    filters.addFilter(</span>
      &quot;__indexType&quot;, new SimpleFieldFilterScope(FIELD_INDEX_TYPE),
<span class="fc" id="L399">      termQuery(FIELD_INDEX_TYPE, TYPE_PROJECT_MEASURES.getName()));</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">    if (!query.isIgnoreAuthorization()) {</span>
<span class="fc" id="L401">      filters.addFilter(&quot;__authorization&quot;, new SimpleFieldFilterScope(&quot;parent&quot;), authorizationTypeSupport.createQueryFilter());</span>
    }
<span class="fc" id="L403">    Multimap&lt;String, MetricCriterion&gt; metricCriterionMultimap = ArrayListMultimap.create();</span>
<span class="fc" id="L404">    query.getMetricCriteria()</span>
<span class="fc" id="L405">      .forEach(metricCriterion -&gt; metricCriterionMultimap.put(metricCriterion.getMetricKey(), metricCriterion));</span>
<span class="fc" id="L406">    metricCriterionMultimap.asMap().forEach((key, value) -&gt; {</span>
<span class="fc" id="L407">      BoolQueryBuilder metricFilters = boolQuery();</span>
<span class="fc" id="L408">      value</span>
<span class="fc" id="L409">        .stream()</span>
<span class="fc" id="L410">        .map(ProjectMeasuresIndex::toQuery)</span>
<span class="fc" id="L411">        .forEach(metricFilters::must);</span>
<span class="fc" id="L412">      filters.addFilter(key, new NestedFieldFilterScope&lt;&gt;(FIELD_MEASURES, SUB_FIELD_MEASURES_KEY, key), metricFilters);</span>
<span class="fc" id="L413">    });</span>

<span class="fc" id="L415">    query.getQualityGateStatus().ifPresent(qualityGateStatus -&gt; filters.addFilter(</span>
<span class="fc" id="L416">      ALERT_STATUS_KEY, ALERT_STATUS.getFilterScope(),</span>
<span class="fc" id="L417">      termQuery(FIELD_QUALITY_GATE_STATUS, QUALITY_GATE_STATUS.get(qualityGateStatus.name()))));</span>

<span class="fc" id="L419">    query.getProjectUuids().ifPresent(projectUuids -&gt; filters.addFilter(</span>
      &quot;ids&quot;, new SimpleFieldFilterScope(&quot;_id&quot;),
<span class="fc" id="L421">      termsQuery(&quot;_id&quot;, projectUuids)));</span>

<span class="fc" id="L423">    query.getLanguages()</span>
<span class="fc" id="L424">      .ifPresent(languages -&gt; filters.addFilter(FILTER_LANGUAGES, LANGUAGES.getFilterScope(), termsQuery(FIELD_LANGUAGES, languages)));</span>

<span class="fc" id="L426">    query.getTags().ifPresent(tags -&gt; filters.addFilter(FIELD_TAGS, TAGS.getFilterScope(), termsQuery(FIELD_TAGS, tags)));</span>

<span class="fc" id="L428">    query.getQualifiers()</span>
<span class="fc" id="L429">      .ifPresent(qualifiers -&gt; filters.addFilter(FIELD_QUALIFIER, new SimpleFieldFilterScope(FIELD_QUALIFIER), termsQuery(FIELD_QUALIFIER, qualifiers)));</span>

<span class="fc" id="L431">    query.getQueryText()</span>
<span class="fc" id="L432">      .map(ProjectsTextSearchQueryFactory::createQuery)</span>
<span class="fc" id="L433">      .ifPresent(queryBuilder -&gt; filters.addFilter(&quot;textQuery&quot;, new SimpleFieldFilterScope(FIELD_NAME), queryBuilder));</span>
<span class="fc" id="L434">    return filters;</span>
  }

  private static QueryBuilder toQuery(MetricCriterion criterion) {
<span class="fc bfc" id="L438" title="All 2 branches covered.">    if (criterion.isNoData()) {</span>
<span class="fc" id="L439">      return boolQuery().mustNot(</span>
<span class="fc" id="L440">        nestedQuery(</span>
          FIELD_MEASURES,
<span class="fc" id="L442">          termQuery(FIELD_MEASURES_MEASURE_KEY, criterion.getMetricKey()),</span>
          ScoreMode.Avg));
    }
<span class="fc" id="L445">    return nestedQuery(</span>
      FIELD_MEASURES,
<span class="fc" id="L447">      boolQuery()</span>
<span class="fc" id="L448">        .filter(termQuery(FIELD_MEASURES_MEASURE_KEY, criterion.getMetricKey()))</span>
<span class="fc" id="L449">        .filter(toValueQuery(criterion)),</span>
      ScoreMode.Avg);
  }

  private static QueryBuilder toValueQuery(MetricCriterion criterion) {
<span class="fc" id="L454">    String fieldName = FIELD_MEASURES_MEASURE_VALUE;</span>

<span class="pc bpc" id="L456" title="1 of 6 branches missed.">    switch (criterion.getOperator()) {</span>
      case GT:
<span class="fc" id="L458">        return rangeQuery(fieldName).gt(criterion.getValue());</span>
      case GTE:
<span class="fc" id="L460">        return rangeQuery(fieldName).gte(criterion.getValue());</span>
      case LT:
<span class="fc" id="L462">        return rangeQuery(fieldName).lt(criterion.getValue());</span>
      case LTE:
<span class="fc" id="L464">        return rangeQuery(fieldName).lte(criterion.getValue());</span>
      case EQ:
<span class="fc" id="L466">        return termQuery(fieldName, criterion.getValue());</span>
      default:
<span class="nc" id="L468">        throw new IllegalStateException(&quot;Metric criteria non supported: &quot; + criterion.getOperator().name());</span>
    }
  }

  public List&lt;String&gt; searchTags(@Nullable String textQuery, int page, int size) {
<span class="fc" id="L473">    int maxPageSize = 100;</span>
<span class="fc" id="L474">    int maxPage = 20;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">    checkArgument(size &lt;= maxPageSize, &quot;Page size must be lower than or equals to &quot; + maxPageSize);</span>
<span class="pc bpc" id="L476" title="1 of 4 branches missed.">    checkArgument(page &gt; 0 &amp;&amp; page &lt;= maxPage, &quot;Page must be between 0 and &quot; + maxPage);</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">    if (size &lt;= 0) {</span>
<span class="fc" id="L479">      return emptyList();</span>
    }

<span class="fc" id="L482">    TermsAggregationBuilder tagFacet = AggregationBuilders.terms(FIELD_TAGS)</span>
<span class="fc" id="L483">      .field(FIELD_TAGS)</span>
<span class="fc" id="L484">      .size(size * page)</span>
<span class="fc" id="L485">      .minDocCount(1)</span>
<span class="fc" id="L486">      .order(BucketOrder.key(true));</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">    if (textQuery != null) {</span>
<span class="fc" id="L488">      tagFacet.includeExclude(new IncludeExclude(&quot;.*&quot; + escapeSpecialRegexChars(textQuery) + &quot;.*&quot;, null));</span>
    }

<span class="fc" id="L491">    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()</span>
<span class="fc" id="L492">      .query(authorizationTypeSupport.createQueryFilter())</span>
<span class="fc" id="L493">      .fetchSource(false)</span>
<span class="fc" id="L494">      .aggregation(tagFacet);</span>

<span class="fc" id="L496">    SearchResponse response = client.search(EsClient.prepareSearch(TYPE_PROJECT_MEASURES.getMainType())</span>
<span class="fc" id="L497">      .source(searchSourceBuilder));</span>

<span class="fc" id="L499">    Terms aggregation = response.getAggregations().get(FIELD_TAGS);</span>

<span class="fc" id="L501">    return aggregation.getBuckets().stream()</span>
<span class="fc" id="L502">      .skip((page - 1) * size)</span>
<span class="fc" id="L503">      .map(Bucket::getKeyAsString)</span>
<span class="fc" id="L504">      .toList();</span>
  }

  private interface FacetBuilder {
    FilterAggregationBuilder buildFacet(Facet facet, ProjectMeasuresQuery query, TopAggregationHelper topAggregationHelper);
  }

  /**
   * A sticky facet on field {@link ProjectMeasuresIndexDefinition#FIELD_MEASURES_MEASURE_KEY}.
   */
  private static class MeasureFacet {
    private final String metricKey;
    private final TopAggregationDefinition&lt;?&gt; topAggregation;
    private final FacetBuilder facetBuilder;

<span class="fc" id="L519">    private MeasureFacet(String metricKey, FacetBuilder facetBuilder) {</span>
<span class="fc" id="L520">      this.metricKey = metricKey;</span>
<span class="fc" id="L521">      this.topAggregation = new NestedFieldTopAggregationDefinition&lt;&gt;(FIELD_MEASURES_MEASURE_KEY, metricKey, STICKY);</span>
<span class="fc" id="L522">      this.facetBuilder = facetBuilder;</span>
<span class="fc" id="L523">    }</span>
  }

  private static final class RangeMeasureFacet extends MeasureFacet {

    private RangeMeasureFacet(String metricKey, double[] thresholds) {
<span class="fc" id="L529">      super(metricKey, new MetricRangeFacetBuilder(metricKey, thresholds));</span>
<span class="fc" id="L530">    }</span>

    private static final class MetricRangeFacetBuilder implements FacetBuilder {
      private final String metricKey;
      private final double[] thresholds;

<span class="fc" id="L536">      private MetricRangeFacetBuilder(String metricKey, double[] thresholds) {</span>
<span class="fc" id="L537">        this.metricKey = metricKey;</span>
<span class="fc" id="L538">        this.thresholds = thresholds;</span>
<span class="fc" id="L539">      }</span>

      @Override
      public FilterAggregationBuilder buildFacet(Facet facet, ProjectMeasuresQuery query, TopAggregationHelper topAggregationHelper) {
<span class="fc" id="L543">        return topAggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L544">          facet.getName(), facet.getTopAggregationDef(),</span>
          NO_EXTRA_FILTER,
<span class="fc" id="L546">          t -&gt; t.subAggregation(createRangeFacet(metricKey, thresholds)));</span>
      }
    }
  }

  private static final class RangeWithNoDataMeasureFacet extends MeasureFacet {

    private RangeWithNoDataMeasureFacet(String metricKey, double[] thresholds) {
<span class="fc" id="L554">      super(metricKey, new MetricRangeWithNoDataFacetBuilder(metricKey, thresholds));</span>
<span class="fc" id="L555">    }</span>

    private static final class MetricRangeWithNoDataFacetBuilder implements FacetBuilder {
      private final String metricKey;
      private final double[] thresholds;

<span class="fc" id="L561">      private MetricRangeWithNoDataFacetBuilder(String metricKey, double[] thresholds) {</span>
<span class="fc" id="L562">        this.metricKey = metricKey;</span>
<span class="fc" id="L563">        this.thresholds = thresholds;</span>
<span class="fc" id="L564">      }</span>

      @Override
      public FilterAggregationBuilder buildFacet(Facet facet, ProjectMeasuresQuery query, TopAggregationHelper topAggregationHelper) {
<span class="fc" id="L568">        return topAggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L569">          facet.getName(), facet.getTopAggregationDef(),</span>
          NO_EXTRA_FILTER,
<span class="fc" id="L571">          t -&gt; t.subAggregation(createRangeFacet(metricKey, thresholds))</span>
<span class="fc" id="L572">            .subAggregation(createNoDataFacet(metricKey)));</span>
      }

      private static AbstractAggregationBuilder&lt;?&gt; createNoDataFacet(String metricKey) {
<span class="fc" id="L576">        return AggregationBuilders.filter(</span>
          &quot;no_data_&quot; + metricKey,
<span class="fc" id="L578">          boolQuery().mustNot(nestedQuery(FIELD_MEASURES, termQuery(FIELD_MEASURES_MEASURE_KEY, metricKey), ScoreMode.Avg)));</span>
      }
    }
  }

  private static class RatingMeasureFacet extends MeasureFacet {

    private RatingMeasureFacet(String metricKey) {
<span class="fc" id="L586">      super(metricKey, new MetricRatingFacetBuilder(metricKey));</span>
<span class="fc" id="L587">    }</span>

    private static class MetricRatingFacetBuilder implements FacetBuilder {
      private final String metricKey;

<span class="fc" id="L592">      private MetricRatingFacetBuilder(String metricKey) {</span>
<span class="fc" id="L593">        this.metricKey = metricKey;</span>
<span class="fc" id="L594">      }</span>

      @Override
      public FilterAggregationBuilder buildFacet(Facet facet, ProjectMeasuresQuery query, TopAggregationHelper topAggregationHelper) {
<span class="fc" id="L598">        return topAggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L599">          facet.getName(), facet.getTopAggregationDef(),</span>
          NO_EXTRA_FILTER,
<span class="fc" id="L601">          t -&gt; t.subAggregation(createMeasureRatingFacet(metricKey)));</span>
      }

      private static AbstractAggregationBuilder&lt;?&gt; createMeasureRatingFacet(String metricKey) {
<span class="fc" id="L605">        return AggregationBuilders.nested(&quot;nested_&quot; + metricKey, FIELD_MEASURES)</span>
<span class="fc" id="L606">          .subAggregation(</span>
<span class="fc" id="L607">            AggregationBuilders.filter(&quot;filter_&quot; + metricKey, termsQuery(FIELD_MEASURES_MEASURE_KEY, metricKey))</span>
<span class="fc" id="L608">              .subAggregation(filters(metricKey,</span>
<span class="fc" id="L609">                new KeyedFilter(&quot;1&quot;, termQuery(FIELD_MEASURES_MEASURE_VALUE, 1D)),</span>
<span class="fc" id="L610">                new KeyedFilter(&quot;2&quot;, termQuery(FIELD_MEASURES_MEASURE_VALUE, 2D)),</span>
<span class="fc" id="L611">                new KeyedFilter(&quot;3&quot;, termQuery(FIELD_MEASURES_MEASURE_VALUE, 3D)),</span>
<span class="fc" id="L612">                new KeyedFilter(&quot;4&quot;, termQuery(FIELD_MEASURES_MEASURE_VALUE, 4D)),</span>
<span class="fc" id="L613">                new KeyedFilter(&quot;5&quot;, termQuery(FIELD_MEASURES_MEASURE_VALUE, 5D)))));</span>
      }
    }
  }

  private static FilterAggregationBuilder buildLanguageFacet(Facet facet, ProjectMeasuresQuery query, TopAggregationHelper topAggregationHelper) {
    // optional selected languages sub-aggregation
<span class="fc" id="L620">    Consumer&lt;FilterAggregationBuilder&gt; extraSubAgg = t -&gt; query.getLanguages()</span>
<span class="fc" id="L621">      .flatMap(languages -&gt; topAggregationHelper.getSubAggregationHelper()</span>
<span class="fc" id="L622">        .buildSelectedItemsAggregation(FILTER_LANGUAGES, facet.getTopAggregationDef(), languages.toArray()))</span>
<span class="fc" id="L623">      .ifPresent(t::subAggregation);</span>
<span class="fc" id="L624">    return topAggregationHelper.buildTermTopAggregation(</span>
<span class="fc" id="L625">      FILTER_LANGUAGES, facet.getTopAggregationDef(), FACET_DEFAULT_SIZE,</span>
      NO_EXTRA_FILTER, extraSubAgg);
  }

  private static FilterAggregationBuilder buildAlertStatusFacet(Facet facet, ProjectMeasuresQuery query, TopAggregationHelper topAggregationHelper) {
<span class="fc" id="L630">    return topAggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L631">      facet.getName(), facet.getTopAggregationDef(),</span>
      NO_EXTRA_FILTER,
<span class="fc" id="L633">      t -&gt; t.subAggregation(createQualityGateFacet()));</span>
  }

  private static FilterAggregationBuilder buildTagsFacet(Facet facet, ProjectMeasuresQuery query, TopAggregationHelper topAggregationHelper) {
    // optional selected tags sub-aggregation
<span class="fc" id="L638">    Consumer&lt;FilterAggregationBuilder&gt; extraSubAgg = t -&gt; query.getTags()</span>
<span class="fc" id="L639">      .flatMap(tags -&gt; topAggregationHelper.getSubAggregationHelper()</span>
<span class="fc" id="L640">        .buildSelectedItemsAggregation(FILTER_TAGS, facet.getTopAggregationDef(), tags.toArray()))</span>
<span class="fc" id="L641">      .ifPresent(t::subAggregation);</span>
<span class="fc" id="L642">    return topAggregationHelper.buildTermTopAggregation(</span>
<span class="fc" id="L643">      FILTER_TAGS, facet.getTopAggregationDef(), FACET_DEFAULT_SIZE,</span>
      NO_EXTRA_FILTER, extraSubAgg);
  }

  private static FilterAggregationBuilder buildQualifierFacet(Facet facet, ProjectMeasuresQuery query, TopAggregationHelper topAggregationHelper) {
<span class="fc" id="L648">    return topAggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L649">      facet.getName(), facet.getTopAggregationDef(),</span>
      NO_EXTRA_FILTER,
<span class="fc" id="L651">      t -&gt; t.subAggregation(createQualifierFacet()));</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>