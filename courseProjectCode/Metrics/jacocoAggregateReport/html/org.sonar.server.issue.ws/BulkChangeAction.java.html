<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BulkChangeAction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.issue.ws</a> &gt; <span class="el_source">BulkChangeAction.java</span></div><h1>BulkChangeAction.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.issue.ws;

import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.rule.RuleKey;
import org.sonar.api.rule.Severity;
import org.sonar.api.server.ws.Change;
import org.sonar.api.server.ws.Request;
import org.sonar.api.server.ws.Response;
import org.sonar.api.server.ws.WebService;
import org.sonar.api.utils.System2;
import org.sonar.core.issue.DefaultIssue;
import org.sonar.core.issue.IssueChangeContext;
import org.sonar.core.rule.RuleType;
import org.sonar.db.DbClient;
import org.sonar.db.DbSession;
import org.sonar.db.component.BranchDto;
import org.sonar.db.component.BranchType;
import org.sonar.db.component.ComponentDto;
import org.sonar.db.issue.IssueDto;
import org.sonar.db.permission.ProjectPermission;
import org.sonar.db.rule.RuleDto;
import org.sonar.db.user.UserDto;
import org.sonar.server.issue.Action;
import org.sonar.server.issue.ActionContext;
import org.sonar.server.issue.AddTagsAction;
import org.sonar.server.issue.AssignAction;
import org.sonar.server.issue.IssueChangePostProcessor;
import org.sonar.server.issue.RemoveTagsAction;
import org.sonar.server.issue.WebIssueStorage;
import org.sonar.server.issue.notification.IssuesChangesNotificationBuilder;
import org.sonar.server.issue.notification.IssuesChangesNotificationBuilder.ChangedIssue;
import org.sonar.server.issue.notification.IssuesChangesNotificationBuilder.Project;
import org.sonar.server.issue.notification.IssuesChangesNotificationBuilder.User;
import org.sonar.server.issue.notification.IssuesChangesNotificationBuilder.UserChange;
import org.sonar.server.issue.notification.IssuesChangesNotificationSerializer;
import org.sonar.server.notification.NotificationManager;
import org.sonar.server.pushapi.issues.IssueChangeEventService;
import org.sonar.server.user.UserSession;
import org.sonarqube.ws.Issues;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.lang.String.format;
import static java.util.Map.of;
import static java.util.Objects.requireNonNull;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.toMap;
import static org.sonar.api.rule.Severity.BLOCKER;
import static org.sonar.core.issue.IssueChangeContext.issueChangeContextByUserBuilder;
import static org.sonar.core.rule.RuleType.BUG;
import static org.sonar.core.rule.RuleType.SECURITY_HOTSPOT;
import static org.sonar.core.util.Uuids.UUID_EXAMPLE_01;
import static org.sonar.core.util.Uuids.UUID_EXAMPLE_02;
import static org.sonar.server.es.SearchOptions.MAX_PAGE_SIZE;
import static org.sonar.server.issue.AbstractChangeTagsAction.TAGS_PARAMETER;
import static org.sonar.server.issue.AssignAction.ASSIGNEE_PARAMETER;
import static org.sonar.server.issue.CommentAction.COMMENT_KEY;
import static org.sonar.server.issue.CommentAction.COMMENT_PROPERTY;
import static org.sonar.server.issue.SetSeverityAction.SET_SEVERITY_KEY;
import static org.sonar.server.issue.SetSeverityAction.SEVERITY_PARAMETER;
import static org.sonar.server.issue.SetTypeAction.SET_TYPE_KEY;
import static org.sonar.server.issue.SetTypeAction.TYPE_PARAMETER;
import static org.sonar.server.issue.TransitionAction.DO_TRANSITION_KEY;
import static org.sonar.server.issue.TransitionAction.TRANSITION_PARAMETER;
import static org.sonar.server.issue.workflow.codequalityissue.CodeQualityIssueWorkflowTransition.ACCEPT;
import static org.sonar.server.issue.workflow.codequalityissue.CodeQualityIssueWorkflowTransition.CONFIRM;
import static org.sonar.server.issue.workflow.codequalityissue.CodeQualityIssueWorkflowTransition.FALSE_POSITIVE;
import static org.sonar.server.issue.workflow.codequalityissue.CodeQualityIssueWorkflowTransition.REOPEN;
import static org.sonar.server.issue.workflow.codequalityissue.CodeQualityIssueWorkflowTransition.RESOLVE;
import static org.sonar.server.issue.workflow.codequalityissue.CodeQualityIssueWorkflowTransition.UNCONFIRM;
import static org.sonar.server.issue.workflow.codequalityissue.CodeQualityIssueWorkflowTransition.WONT_FIX;
import static org.sonar.server.issue.workflow.securityhotspot.SecurityHotspotWorkflowTransition.RESET_AS_TO_REVIEW;
import static org.sonar.server.issue.workflow.securityhotspot.SecurityHotspotWorkflowTransition.RESOLVE_AS_REVIEWED;
import static org.sonar.server.ws.WsUtils.writeProtobuf;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.ACTION_BULK_CHANGE;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_ADD_TAGS;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_ASSIGN;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_COMMENT;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_DO_TRANSITION;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_ISSUES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_REMOVE_TAGS;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_SEND_NOTIFICATIONS;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_SET_SEVERITY;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_SET_TYPE;

public class BulkChangeAction implements IssuesWsAction {

<span class="fc" id="L122">  private static final Logger LOG = LoggerFactory.getLogger(BulkChangeAction.class);</span>
<span class="fc" id="L123">  private static final List&lt;String&gt; ACTIONS_TO_DISTRIBUTE = List.of(SET_SEVERITY_KEY, SET_TYPE_KEY, DO_TRANSITION_KEY);</span>

  private final System2 system2;
  private final UserSession userSession;
  private final DbClient dbClient;
  private final WebIssueStorage issueStorage;
  private final NotificationManager notificationService;
  private final List&lt;Action&gt; actions;
  private final IssueChangePostProcessor issueChangePostProcessor;
  private final IssuesChangesNotificationSerializer notificationSerializer;
  private final IssueChangeEventService issueChangeEventService;

  public BulkChangeAction(System2 system2, UserSession userSession, DbClient dbClient, WebIssueStorage issueStorage,
    NotificationManager notificationService, List&lt;Action&gt; actions,
    IssueChangePostProcessor issueChangePostProcessor, IssuesChangesNotificationSerializer notificationSerializer,
<span class="fc" id="L138">    IssueChangeEventService issueChangeEventService) {</span>
<span class="fc" id="L139">    this.system2 = system2;</span>
<span class="fc" id="L140">    this.userSession = userSession;</span>
<span class="fc" id="L141">    this.dbClient = dbClient;</span>
<span class="fc" id="L142">    this.issueStorage = issueStorage;</span>
<span class="fc" id="L143">    this.notificationService = notificationService;</span>
<span class="fc" id="L144">    this.actions = actions;</span>
<span class="fc" id="L145">    this.issueChangePostProcessor = issueChangePostProcessor;</span>
<span class="fc" id="L146">    this.notificationSerializer = notificationSerializer;</span>
<span class="fc" id="L147">    this.issueChangeEventService = issueChangeEventService;</span>
<span class="fc" id="L148">  }</span>

  @Override
  public void define(WebService.NewController context) {
<span class="fc" id="L152">    WebService.NewAction action = context.createAction(ACTION_BULK_CHANGE)</span>
<span class="fc" id="L153">      .setDescription(&quot;Bulk change on issues. Up to 500 issues can be updated. &lt;br/&gt;&quot; +</span>
        &quot;Requires authentication.&quot;)
<span class="fc" id="L155">      .setSince(&quot;3.7&quot;)</span>
<span class="fc" id="L156">      .setChangelog(</span>
<span class="fc" id="L157">        new Change(&quot;10.8&quot;, format(&quot;The parameters '%s' and '%s' are not deprecated anymore.&quot;, PARAM_SET_SEVERITY, PARAM_SET_TYPE)),</span>
        new Change(&quot;10.4&quot;, (&quot;Transitions '%s' and '%s' are now deprecated. Use transition '%s' instead. &quot; +
<span class="fc" id="L159">          &quot;The transition '%s' is deprecated too.&quot;).formatted(WONT_FIX, CONFIRM, ACCEPT, UNCONFIRM)),</span>
<span class="fc" id="L160">        new Change(&quot;10.4&quot;, &quot;Transition '%s' is now supported.&quot;.formatted(ACCEPT)),</span>
<span class="fc" id="L161">        new Change(&quot;10.2&quot;, format(&quot;Parameters '%s' and '%s' are now deprecated.&quot;, PARAM_SET_SEVERITY, PARAM_SET_TYPE)),</span>
        new Change(&quot;8.2&quot;, &quot;Security hotspots are no longer supported and will be ignored.&quot;),
<span class="fc" id="L163">        new Change(&quot;8.2&quot;, format(&quot;Transitions '%s', '%s' and '%s' are no more supported&quot;, &quot;setinreview&quot;, RESOLVE_AS_REVIEWED, &quot;openasvulnerability&quot;)),</span>
        new Change(&quot;6.3&quot;, &quot;'actions' parameter is ignored&quot;))
<span class="fc" id="L165">      .setHandler(this)</span>
<span class="fc" id="L166">      .setResponseExample(getClass().getResource(&quot;bulk_change-example.json&quot;))</span>
<span class="fc" id="L167">      .setPost(true);</span>

<span class="fc" id="L169">    action.createParam(PARAM_ISSUES)</span>
<span class="fc" id="L170">      .setDescription(&quot;Comma-separated list of issue keys&quot;)</span>
<span class="fc" id="L171">      .setRequired(true)</span>
<span class="fc" id="L172">      .setExampleValue(UUID_EXAMPLE_01 + &quot;,&quot; + UUID_EXAMPLE_02);</span>
<span class="fc" id="L173">    action.createParam(PARAM_ASSIGN)</span>
<span class="fc" id="L174">      .setDescription(&quot;To assign the list of issues to a specific user (login), or un-assign all the issues&quot;)</span>
<span class="fc" id="L175">      .setExampleValue(&quot;john.smith&quot;);</span>
<span class="fc" id="L176">    action.createParam(PARAM_SET_SEVERITY)</span>
<span class="fc" id="L177">      .setDescription(&quot;To change the severity of the list of issues&quot;)</span>
<span class="fc" id="L178">      .setExampleValue(BLOCKER)</span>
<span class="fc" id="L179">      .setPossibleValues(Severity.ALL);</span>
<span class="fc" id="L180">    action.createParam(PARAM_SET_TYPE)</span>
<span class="fc" id="L181">      .setDescription(&quot;To change the type of the list of issues&quot;)</span>
<span class="fc" id="L182">      .setExampleValue(BUG)</span>
<span class="fc" id="L183">      .setPossibleValues(RuleType.names())</span>
<span class="fc" id="L184">      .setSince(&quot;5.5&quot;);</span>
<span class="fc" id="L185">    action.createParam(PARAM_DO_TRANSITION)</span>
<span class="fc" id="L186">      .setDescription(&quot;Transition&quot;)</span>
<span class="fc" id="L187">      .setExampleValue(REOPEN)</span>
<span class="fc" id="L188">      .setPossibleValues(List.of(</span>
<span class="fc" id="L189">        CONFIRM.getKey(),</span>
<span class="fc" id="L190">        UNCONFIRM.getKey(),</span>
<span class="fc" id="L191">        REOPEN.getKey(),</span>
<span class="fc" id="L192">        RESOLVE.getKey(),</span>
<span class="fc" id="L193">        FALSE_POSITIVE.getKey(),</span>
<span class="fc" id="L194">        WONT_FIX.getKey(),</span>
<span class="fc" id="L195">        RESOLVE_AS_REVIEWED.getKey(),</span>
<span class="fc" id="L196">        RESET_AS_TO_REVIEW.getKey(),</span>
<span class="fc" id="L197">        ACCEPT.getKey()));</span>
<span class="fc" id="L198">    action.createParam(PARAM_ADD_TAGS)</span>
<span class="fc" id="L199">      .setDescription(&quot;Add tags&quot;)</span>
<span class="fc" id="L200">      .setExampleValue(&quot;security,java8&quot;);</span>
<span class="fc" id="L201">    action.createParam(PARAM_REMOVE_TAGS)</span>
<span class="fc" id="L202">      .setDescription(&quot;Remove tags&quot;)</span>
<span class="fc" id="L203">      .setExampleValue(&quot;security,java8&quot;);</span>
<span class="fc" id="L204">    action.createParam(PARAM_COMMENT)</span>
<span class="fc" id="L205">      .setDescription(&quot;Add a comment. &quot;</span>
        + &quot;The comment will only be added to issues that are affected either by a change of type or a change of severity as a result of the same WS call.&quot;)
<span class="fc" id="L207">      .setExampleValue(&quot;Here is my comment&quot;);</span>
<span class="fc" id="L208">    action.createParam(PARAM_SEND_NOTIFICATIONS)</span>
<span class="fc" id="L209">      .setSince(&quot;4.0&quot;)</span>
<span class="fc" id="L210">      .setBooleanPossibleValues()</span>
<span class="fc" id="L211">      .setDefaultValue(&quot;false&quot;);</span>
<span class="fc" id="L212">  }</span>

  @Override
  public void handle(Request request, Response response) throws Exception {
<span class="fc" id="L216">    userSession.checkLoggedIn();</span>
<span class="fc" id="L217">    try (DbSession dbSession = dbClient.openSession(false)) {</span>
<span class="fc" id="L218">      BulkChangeResult result = executeBulkChange(dbSession, request);</span>
<span class="fc" id="L219">      writeProtobuf(toWsResponse(result), request, response);</span>
    }
<span class="fc" id="L221">  }</span>

  private BulkChangeResult executeBulkChange(DbSession dbSession, Request request) {
<span class="fc" id="L224">    BulkChangeData bulkChangeData = new BulkChangeData(dbSession, request);</span>
<span class="fc" id="L225">    BulkChangeResult result = new BulkChangeResult(bulkChangeData.issues.size());</span>
<span class="fc" id="L226">    IssueChangeContext issueChangeContext = issueChangeContextByUserBuilder(new Date(system2.now()), userSession.getUuid()).build();</span>

<span class="fc" id="L228">    List&lt;DefaultIssue&gt; items = bulkChangeData.issues.stream()</span>
<span class="fc" id="L229">      .filter(bulkChange(issueChangeContext, bulkChangeData, result))</span>
<span class="fc" id="L230">      .toList();</span>
<span class="fc" id="L231">    issueStorage.save(dbSession, items);</span>

<span class="fc" id="L233">    refreshLiveMeasures(dbSession, bulkChangeData, result);</span>

<span class="fc" id="L235">    Set&lt;String&gt; assigneeUuids = items.stream().map(DefaultIssue::assignee).filter(Objects::nonNull).collect(Collectors.toSet());</span>
<span class="fc" id="L236">    Map&lt;String, UserDto&gt; userDtoByUuid = dbClient.userDao().selectByUuids(dbSession, assigneeUuids).stream().collect(toMap(UserDto::getUuid, u -&gt; u));</span>
<span class="fc" id="L237">    String authorUuid = requireNonNull(userSession.getUuid(), &quot;User uuid cannot be null&quot;);</span>
<span class="fc" id="L238">    UserDto author = dbClient.userDao().selectByUuid(dbSession, authorUuid);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">    checkState(author != null, &quot;User with uuid '%s' does not exist&quot;);</span>
<span class="fc" id="L240">    sendNotification(items, bulkChangeData, userDtoByUuid, author);</span>
<span class="fc" id="L241">    distributeEvents(items, bulkChangeData);</span>

<span class="fc" id="L243">    return result;</span>
  }

  private void refreshLiveMeasures(DbSession dbSession, BulkChangeData data, BulkChangeResult result) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">    if (!data.shouldRefreshMeasures()) {</span>
<span class="fc" id="L248">      return;</span>
    }
<span class="fc" id="L250">    Set&lt;String&gt; touchedComponentUuids = result.success.stream()</span>
<span class="fc" id="L251">      .map(DefaultIssue::componentUuid)</span>
<span class="fc" id="L252">      .collect(Collectors.toSet());</span>
<span class="fc" id="L253">    List&lt;ComponentDto&gt; touchedComponents = touchedComponentUuids.stream()</span>
<span class="fc" id="L254">      .map(data.componentsByUuid::get)</span>
<span class="fc" id="L255">      .toList();</span>

<span class="fc" id="L257">    List&lt;DefaultIssue&gt; changedIssues = data.issues.stream().filter(result.success::contains).toList();</span>
<span class="fc" id="L258">    issueChangePostProcessor.process(dbSession, changedIssues, touchedComponents, false);</span>
<span class="fc" id="L259">  }</span>

  private static Predicate&lt;DefaultIssue&gt; bulkChange(IssueChangeContext issueChangeContext, BulkChangeData bulkChangeData, BulkChangeResult result) {
<span class="fc" id="L262">    return issue -&gt; {</span>
<span class="fc" id="L263">      ActionContext actionContext = new ActionContext(issue, bulkChangeData.originalIssueByKey.get(issue.key()), issueChangeContext,</span>
<span class="fc" id="L264">        bulkChangeData.branchComponentByUuid.get(issue.projectUuid()));</span>
<span class="fc" id="L265">      bulkChangeData.getActionsWithoutComment().forEach(applyAction(actionContext, bulkChangeData, result));</span>
<span class="fc" id="L266">      addCommentIfNeeded(actionContext, bulkChangeData);</span>
<span class="fc" id="L267">      return result.success.contains(issue);</span>
    };
  }

  private static Consumer&lt;Action&gt; applyAction(ActionContext actionContext, BulkChangeData bulkChangeData, BulkChangeResult result) {
<span class="fc" id="L272">    return action -&gt; {</span>
<span class="fc" id="L273">      DefaultIssue issue = actionContext.issue();</span>
      try {
<span class="fc bfc" id="L275" title="All 4 branches covered.">        if (action.supports(issue) &amp;&amp; action.execute(bulkChangeData.getProperties(action.key()), actionContext)) {</span>
<span class="fc" id="L276">          result.increaseSuccess(issue);</span>
        }
<span class="nc" id="L278">      } catch (Exception e) {</span>
<span class="nc" id="L279">        result.increaseFailure();</span>
<span class="nc" id="L280">        LOG.error(format(&quot;An error occur when trying to apply the action : %s on issue : %s. This issue has been ignored. Error is '%s'&quot;,</span>
<span class="nc" id="L281">          action.key(), issue.key(), e.getMessage()), e);</span>
<span class="fc" id="L282">      }</span>
<span class="fc" id="L283">    };</span>
  }

  private static void addCommentIfNeeded(ActionContext actionContext, BulkChangeData bulkChangeData) {
<span class="fc" id="L287">    bulkChangeData.getCommentAction().ifPresent(action -&gt; action.execute(bulkChangeData.getProperties(action.key()), actionContext));</span>
<span class="fc" id="L288">  }</span>

  private void sendNotification(Collection&lt;DefaultIssue&gt; issues, BulkChangeData bulkChangeData, Map&lt;String, UserDto&gt; userDtoByUuid, UserDto author) {
<span class="fc bfc" id="L291" title="All 2 branches covered.">    if (!bulkChangeData.sendNotification) {</span>
<span class="fc" id="L292">      return;</span>
    }
<span class="fc" id="L294">    Set&lt;ChangedIssue&gt; changedIssues = issues.stream()</span>
      // should not happen but filter it out anyway to avoid NPE in oldestUpdateDate call below
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">      .filter(issue -&gt; issue.updateDate() != null)</span>
<span class="fc" id="L297">      .map(issue -&gt; toNotification(bulkChangeData, userDtoByUuid, issue))</span>
<span class="fc" id="L298">      .filter(Objects::nonNull)</span>
<span class="fc" id="L299">      .collect(Collectors.toSet());</span>

<span class="fc bfc" id="L301" title="All 2 branches covered.">    if (changedIssues.isEmpty()) {</span>
<span class="fc" id="L302">      return;</span>
    }

<span class="fc" id="L305">    IssuesChangesNotificationBuilder builder = new IssuesChangesNotificationBuilder(</span>
      changedIssues,
<span class="fc" id="L307">      new UserChange(oldestUpdateDate(issues), new User(author.getUuid(), author.getLogin(), author.getName())));</span>
<span class="fc" id="L308">    notificationService.scheduleForSending(notificationSerializer.serialize(builder));</span>
<span class="fc" id="L309">  }</span>

  private void distributeEvents(Collection&lt;DefaultIssue&gt; issues, BulkChangeData bulkChangeData) {
<span class="fc" id="L312">    boolean anyActionToDistribute = bulkChangeData.availableActions</span>
<span class="fc" id="L313">      .stream()</span>
<span class="fc" id="L314">      .anyMatch(a -&gt; ACTIONS_TO_DISTRIBUTE.contains(a.key()));</span>

<span class="fc bfc" id="L316" title="All 2 branches covered.">    if (!anyActionToDistribute) {</span>
<span class="fc" id="L317">      return;</span>
    }

<span class="fc" id="L320">    Set&lt;DefaultIssue&gt; changedIssues = issues.stream()</span>
      // should not happen but filter it out anyway to avoid NPE in oldestUpdateDate call below
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">      .filter(issue -&gt; issue.updateDate() != null)</span>
<span class="fc" id="L323">      .filter(Objects::nonNull)</span>
<span class="fc" id="L324">      .collect(Collectors.toSet());</span>

<span class="fc bfc" id="L326" title="All 2 branches covered.">    if (changedIssues.isEmpty()) {</span>
<span class="fc" id="L327">      return;</span>
    }

<span class="fc" id="L330">    issueChangeEventService.distributeIssueChangeEvent(issues, bulkChangeData.branchComponentByUuid, bulkChangeData.branchesByProjectUuid);</span>
<span class="fc" id="L331">  }</span>

  @CheckForNull
  private ChangedIssue toNotification(BulkChangeData bulkChangeData, Map&lt;String, UserDto&gt; userDtoByUuid, DefaultIssue issue) {
<span class="fc" id="L335">    BranchDto branchDto = bulkChangeData.branchesByProjectUuid.get(issue.projectUuid());</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">    if (!hasNotificationSupport(branchDto)) {</span>
<span class="fc" id="L337">      return null;</span>
    }

<span class="fc" id="L340">    RuleDto ruleDefinitionDto = bulkChangeData.rulesByKey.get(issue.ruleKey());</span>
<span class="fc" id="L341">    ComponentDto projectDto = bulkChangeData.branchComponentByUuid.get(issue.projectUuid());</span>
<span class="pc bpc" id="L342" title="2 of 4 branches missed.">    if (ruleDefinitionDto == null || projectDto == null) {</span>
<span class="nc" id="L343">      return null;</span>
    }
<span class="fc" id="L345">    IssueDto oldIssueDto = bulkChangeData.originalIssueByKey.get(issue.key());</span>

<span class="fc" id="L347">    Optional&lt;UserDto&gt; assignee = Optional.ofNullable(issue.assignee()).map(userDtoByUuid::get);</span>
<span class="fc" id="L348">    return new ChangedIssue.Builder(issue.key())</span>
<span class="fc" id="L349">      .setNewStatus(issue.status())</span>
<span class="fc" id="L350">      .setNewIssueStatus(issue.issueStatus())</span>
<span class="fc" id="L351">      .setOldIssueStatus(oldIssueDto.getIssueStatus())</span>
<span class="pc" id="L352">      .setAssignee(assignee.map(u -&gt; new User(u.getUuid(), u.getLogin(), u.getName())).orElse(null))</span>
<span class="fc" id="L353">      .setRule(new IssuesChangesNotificationBuilder.Rule(ruleDefinitionDto.getKey(), RuleType.valueOfNullable(ruleDefinitionDto.getType()), ruleDefinitionDto.getName()))</span>
<span class="fc" id="L354">      .setProject(new Project.Builder(projectDto.uuid())</span>
<span class="fc" id="L355">        .setKey(projectDto.getKey())</span>
<span class="fc" id="L356">        .setProjectName(projectDto.name())</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        .setBranchName(branchDto.isMain() ? null : branchDto.getKey())</span>
<span class="fc" id="L358">        .build())</span>
<span class="fc" id="L359">      .build();</span>
  }

  private static boolean hasNotificationSupport(@Nullable BranchDto branch) {
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">    return branch != null &amp;&amp; branch.getBranchType() != BranchType.PULL_REQUEST;</span>
  }

  private static long oldestUpdateDate(Collection&lt;DefaultIssue&gt; issues) {
<span class="fc" id="L367">    long res = Long.MAX_VALUE;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">    for (DefaultIssue issue : issues) {</span>
<span class="fc" id="L369">      long issueUpdateDate = issue.updateDate().getTime();</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">      if (issueUpdateDate &lt; res) {</span>
<span class="fc" id="L371">        res = issueUpdateDate;</span>
      }
<span class="fc" id="L373">    }</span>
<span class="fc" id="L374">    return res;</span>
  }

  private static Issues.BulkChangeWsResponse toWsResponse(BulkChangeResult result) {
<span class="fc" id="L378">    return Issues.BulkChangeWsResponse.newBuilder()</span>
<span class="fc" id="L379">      .setTotal(result.countTotal())</span>
<span class="fc" id="L380">      .setSuccess(result.countSuccess())</span>
<span class="fc" id="L381">      .setIgnored((long) result.countTotal() - (result.countSuccess() + result.countFailures()))</span>
<span class="fc" id="L382">      .setFailures(result.countFailures())</span>
<span class="fc" id="L383">      .build();</span>
  }

  private class BulkChangeData {
    private final Map&lt;String, Map&lt;String, Object&gt;&gt; propertiesByActions;
    private final boolean sendNotification;
    private final Collection&lt;DefaultIssue&gt; issues;
    private final Map&lt;String, ComponentDto&gt; branchComponentByUuid;
    private final Map&lt;String, BranchDto&gt; branchesByProjectUuid;
    private final Map&lt;String, ComponentDto&gt; componentsByUuid;
    private final Map&lt;RuleKey, RuleDto&gt; rulesByKey;
    private final List&lt;Action&gt; availableActions;
    private final Map&lt;String, IssueDto&gt; originalIssueByKey;

<span class="fc" id="L397">    BulkChangeData(DbSession dbSession, Request request) {</span>
<span class="fc" id="L398">      this.sendNotification = request.mandatoryParamAsBoolean(PARAM_SEND_NOTIFICATIONS);</span>
<span class="fc" id="L399">      this.propertiesByActions = toPropertiesByActions(request);</span>

<span class="fc" id="L401">      List&lt;String&gt; issueKeys = request.mandatoryParamAsStrings(PARAM_ISSUES);</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">      checkArgument(issueKeys.size() &lt;= MAX_PAGE_SIZE, &quot;Number of issues is limited to %s&quot;, MAX_PAGE_SIZE);</span>
<span class="fc" id="L403">      List&lt;IssueDto&gt; allIssues = dbClient.issueDao().selectByKeys(dbSession, issueKeys)</span>
<span class="fc" id="L404">        .stream()</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        .filter(issueDto -&gt; SECURITY_HOTSPOT.getDbConstant() != issueDto.getType())</span>
<span class="fc" id="L406">        .toList();</span>

<span class="fc" id="L408">      List&lt;ComponentDto&gt; allBranches = getComponents(dbSession, allIssues.stream().map(IssueDto::getProjectUuid).collect(Collectors.toSet()));</span>
<span class="fc" id="L409">      this.branchComponentByUuid = getAuthorizedComponents(allBranches).stream().collect(toMap(ComponentDto::uuid, identity()));</span>
<span class="fc" id="L410">      this.branchesByProjectUuid = dbClient.branchDao().selectByUuids(dbSession, branchComponentByUuid.keySet()).stream()</span>
<span class="fc" id="L411">        .collect(toMap(BranchDto::getUuid, identity()));</span>
<span class="fc" id="L412">      List&lt;IssueDto&gt; authorizedIssues = getAuthorizedIssues(allIssues);</span>
<span class="fc" id="L413">      this.originalIssueByKey = authorizedIssues.stream().collect(toMap(IssueDto::getKee, identity()));</span>
<span class="fc" id="L414">      this.issues = toDefaultIssues(authorizedIssues);</span>
<span class="fc" id="L415">      this.componentsByUuid = getComponents(dbSession,</span>
<span class="fc" id="L416">        issues.stream().map(DefaultIssue::componentUuid).collect(Collectors.toSet())).stream()</span>
<span class="fc" id="L417">        .collect(toMap(ComponentDto::uuid, identity()));</span>
<span class="fc" id="L418">      this.rulesByKey = dbClient.ruleDao().selectByKeys(dbSession,</span>
<span class="fc" id="L419">        issues.stream().map(DefaultIssue::ruleKey).collect(Collectors.toSet())).stream()</span>
<span class="fc" id="L420">        .collect(toMap(RuleDto::getKey, identity()));</span>

<span class="fc" id="L422">      this.availableActions = actions.stream()</span>
<span class="fc" id="L423">        .filter(action -&gt; propertiesByActions.containsKey(action.key()))</span>
<span class="fc" id="L424">        .filter(action -&gt; action.verify(getProperties(action.key()), issues, userSession))</span>
<span class="fc" id="L425">        .toList();</span>
<span class="fc" id="L426">    }</span>

    private List&lt;ComponentDto&gt; getComponents(DbSession dbSession, Collection&lt;String&gt; componentUuids) {
<span class="fc" id="L429">      return dbClient.componentDao().selectByUuids(dbSession, componentUuids);</span>
    }

    private List&lt;ComponentDto&gt; getAuthorizedComponents(List&lt;ComponentDto&gt; projectDtos) {
<span class="fc" id="L433">      return userSession.keepAuthorizedComponents(ProjectPermission.USER, projectDtos);</span>
    }

    private List&lt;IssueDto&gt; getAuthorizedIssues(List&lt;IssueDto&gt; allIssues) {
<span class="fc" id="L437">      Set&lt;String&gt; branchUuids = branchComponentByUuid.values().stream().map(ComponentDto::uuid).collect(Collectors.toSet());</span>
<span class="fc" id="L438">      return allIssues.stream()</span>
<span class="fc" id="L439">        .filter(issue -&gt; branchUuids.contains(issue.getProjectUuid()))</span>
<span class="fc" id="L440">        .toList();</span>
    }

    private List&lt;DefaultIssue&gt; toDefaultIssues(List&lt;IssueDto&gt; allIssues) {
<span class="fc" id="L444">      return allIssues.stream()</span>
<span class="fc" id="L445">        .map(IssueDto::toDefaultIssue)</span>
<span class="fc" id="L446">        .toList();</span>
    }

    Map&lt;String, Object&gt; getProperties(String actionKey) {
<span class="fc" id="L450">      return propertiesByActions.get(actionKey);</span>
    }

    List&lt;Action&gt; getActionsWithoutComment() {
<span class="fc bfc" id="L454" title="All 2 branches covered.">      return availableActions.stream().filter(action -&gt; !action.key().equals(COMMENT_KEY)).toList();</span>
    }

    Optional&lt;Action&gt; getCommentAction() {
<span class="fc" id="L458">      return availableActions.stream().filter(action -&gt; action.key().equals(COMMENT_KEY)).findFirst();</span>
    }

    private Map&lt;String, Map&lt;String, Object&gt;&gt; toPropertiesByActions(Request request) {
<span class="fc" id="L462">      Map&lt;String, Map&lt;String, Object&gt;&gt; properties = new HashMap&lt;&gt;();</span>
<span class="fc" id="L463">      request.getParam(PARAM_ASSIGN, value -&gt; properties.put(AssignAction.ASSIGN_KEY, new HashMap&lt;&gt;(of(ASSIGNEE_PARAMETER, value))));</span>
<span class="fc" id="L464">      request.getParam(PARAM_SET_SEVERITY, value -&gt; properties.put(SET_SEVERITY_KEY, new HashMap&lt;&gt;(of(SEVERITY_PARAMETER, value))));</span>
<span class="fc" id="L465">      request.getParam(PARAM_SET_TYPE, value -&gt; properties.put(SET_TYPE_KEY, new HashMap&lt;&gt;(of(TYPE_PARAMETER, value))));</span>
<span class="fc" id="L466">      request.getParam(PARAM_DO_TRANSITION, value -&gt; properties.put(DO_TRANSITION_KEY, new HashMap&lt;&gt;(of(TRANSITION_PARAMETER, value))));</span>
<span class="fc" id="L467">      request.getParam(PARAM_ADD_TAGS, value -&gt; properties.put(AddTagsAction.KEY, new HashMap&lt;&gt;(of(TAGS_PARAMETER, value))));</span>
<span class="pc" id="L468">      request.getParam(PARAM_REMOVE_TAGS, value -&gt; properties.put(RemoveTagsAction.KEY, new HashMap&lt;&gt;(of(TAGS_PARAMETER, value))));</span>
<span class="fc" id="L469">      request.getParam(PARAM_COMMENT, value -&gt; properties.put(COMMENT_KEY, new HashMap&lt;&gt;(of(COMMENT_PROPERTY, value))));</span>
<span class="fc" id="L470">      checkAtLeastOneActionIsDefined(properties.keySet());</span>
<span class="fc" id="L471">      return properties;</span>
    }

    private void checkAtLeastOneActionIsDefined(Set&lt;String&gt; actions) {
<span class="fc bfc" id="L475" title="All 2 branches covered.">      long actionsDefined = actions.stream().filter(action -&gt; !action.equals(COMMENT_KEY)).count();</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">      checkArgument(actionsDefined &gt; 0, &quot;At least one action must be provided&quot;);</span>
<span class="fc" id="L477">    }</span>

    private boolean shouldRefreshMeasures() {
<span class="fc" id="L480">      return availableActions.stream().anyMatch(Action::shouldRefreshMeasures);</span>
    }
  }

  private static class BulkChangeResult {
    private final int total;
<span class="fc" id="L486">    private final Set&lt;DefaultIssue&gt; success = new HashSet&lt;&gt;();</span>
<span class="fc" id="L487">    private int failures = 0;</span>

<span class="fc" id="L489">    BulkChangeResult(int total) {</span>
<span class="fc" id="L490">      this.total = total;</span>
<span class="fc" id="L491">    }</span>

    void increaseSuccess(DefaultIssue issue) {
<span class="fc" id="L494">      this.success.add(issue);</span>
<span class="fc" id="L495">    }</span>

    void increaseFailure() {
<span class="nc" id="L498">      this.failures++;</span>
<span class="nc" id="L499">    }</span>

    int countTotal() {
<span class="fc" id="L502">      return total;</span>
    }

    int countSuccess() {
<span class="fc" id="L506">      return success.size();</span>
    }

    int countFailures() {
<span class="fc" id="L510">      return failures;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>