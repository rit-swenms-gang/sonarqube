<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OkHttpClientBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonarqube.ws.client</a> &gt; <span class="el_source">OkHttpClientBuilder.java</span></div><h1>OkHttpClientBuilder.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonarqube.ws.client;

import java.io.FileInputStream;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.Proxy;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;
import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;
import okhttp3.ConnectionSpec;
import okhttp3.Credentials;
import okhttp3.Interceptor;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.logging.HttpLoggingInterceptor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Arrays.asList;
import static org.sonarqube.ws.WsUtils.nullToEmpty;

/**
 * Helper to build an instance of {@link okhttp3.OkHttpClient} that
 * correctly supports HTTPS and proxy authentication. It also handles
 * sending of User-Agent header.
 */
<span class="fc" id="L62">public class OkHttpClientBuilder {</span>

<span class="fc" id="L64">  private static final Logger LOG = LoggerFactory.getLogger(OkHttpClientBuilder.class);</span>

  private static final String NONE = &quot;NONE&quot;;
  private static final String P11KEYSTORE = &quot;PKCS11&quot;;
  private static final String PROXY_AUTHORIZATION = &quot;Proxy-Authorization&quot;;

  private String userAgent;
  private Proxy proxy;
  private String credentials;
  private String proxyLogin;
  private String proxyPassword;
  private Boolean followRedirects;
<span class="fc" id="L76">  private long connectTimeoutMs = -1;</span>
<span class="fc" id="L77">  private long readTimeoutMs = -1;</span>
<span class="fc" id="L78">  private long responseTimeoutMs = -1;</span>
<span class="fc" id="L79">  private SSLSocketFactory sslSocketFactory = null;</span>
<span class="fc" id="L80">  private X509TrustManager sslTrustManager = null;</span>
<span class="fc" id="L81">  private boolean acceptGzip = false;</span>

  /**
   * Optional User-Agent. If set, then all the requests sent by the
   * {@link OkHttpClient} will include the header &quot;User-Agent&quot;.
   */
  public OkHttpClientBuilder setUserAgent(@Nullable String s) {
<span class="fc" id="L88">    this.userAgent = s;</span>
<span class="fc" id="L89">    return this;</span>
  }

  /**
   * Optional SSL socket factory with which SSL sockets will be created to establish SSL connections.
   * If not set, a default SSL socket factory will be used, base d on the JVM's default key store.
   */
  public OkHttpClientBuilder setSSLSocketFactory(@Nullable SSLSocketFactory sslSocketFactory) {
<span class="fc" id="L97">    this.sslSocketFactory = sslSocketFactory;</span>
<span class="fc" id="L98">    return this;</span>
  }

  /**
   * Optional SSL trust manager used to validate certificates.
   * If not set, a default system trust manager will be used, based on the JVM's default truststore.
   */
  public OkHttpClientBuilder setTrustManager(@Nullable X509TrustManager sslTrustManager) {
<span class="fc" id="L106">    this.sslTrustManager = sslTrustManager;</span>
<span class="fc" id="L107">    return this;</span>
  }

  /**
   * Optional proxy. If set, then all the requests sent by the
   * {@link OkHttpClient} will reach the proxy. If not set,
   * then the system-wide proxy is used.
   */
  public OkHttpClientBuilder setProxy(@Nullable Proxy proxy) {
<span class="fc" id="L116">    this.proxy = proxy;</span>
<span class="fc" id="L117">    return this;</span>
  }

  /**
   * Login required for proxy authentication.
   */
  public OkHttpClientBuilder setProxyLogin(@Nullable String s) {
<span class="fc" id="L124">    this.proxyLogin = s;</span>
<span class="fc" id="L125">    return this;</span>
  }

  /**
   * This flag decides whether the client should accept GZIP encoding. Default is false.
   */
  public OkHttpClientBuilder acceptGzip(boolean acceptGzip) {
<span class="fc" id="L132">    this.acceptGzip = acceptGzip;</span>
<span class="fc" id="L133">    return this;</span>
  }

  /**
   * Password used for proxy authentication. It is ignored if
   * proxy login is not defined (see {@link #setProxyLogin(String)}).
   * It can be null or empty when login is defined.
   */
  public OkHttpClientBuilder setProxyPassword(@Nullable String s) {
<span class="fc" id="L142">    this.proxyPassword = s;</span>
<span class="fc" id="L143">    return this;</span>
  }

  /**
   * Sets the default connect timeout for new connections. A value of 0 means no timeout.
   * Default is defined by OkHttp (10 seconds in OkHttp 3.3).
   */
  public OkHttpClientBuilder setConnectTimeoutMs(long l) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">    if (l &lt; 0) {</span>
<span class="fc" id="L152">      throw new IllegalArgumentException(&quot;Connect timeout must be positive. Got &quot; + l);</span>
    }
<span class="fc" id="L154">    this.connectTimeoutMs = l;</span>
<span class="fc" id="L155">    return this;</span>
  }

  /**
   * Set credentials that will be passed on every request
   */
  public OkHttpClientBuilder setCredentials(String credentials) {
<span class="fc" id="L162">    this.credentials = credentials;</span>
<span class="fc" id="L163">    return this;</span>
  }

  /**
   * Sets the default read timeout for new connections. A value of 0 means no timeout.
   * Default is defined by OkHttp (10 seconds in OkHttp 3.3).
   */
  public OkHttpClientBuilder setReadTimeoutMs(long l) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">    if (l &lt; 0) {</span>
<span class="fc" id="L172">      throw new IllegalArgumentException(&quot;Read timeout must be positive. Got &quot; + l);</span>
    }
<span class="fc" id="L174">    this.readTimeoutMs = l;</span>
<span class="fc" id="L175">    return this;</span>
  }

  /**
   * Sets the default response timeout for new connections. A value of 0 means no timeout.
   * Default is to have no timeout.
   */
  public OkHttpClientBuilder setResponseTimeoutMs(long l) {
<span class="fc bfc" id="L183" title="All 2 branches covered.">    if (l &lt; 0) {</span>
<span class="fc" id="L184">      throw new IllegalArgumentException(&quot;Response timeout must be positive. Got &quot; + l);</span>
    }
<span class="fc" id="L186">    this.responseTimeoutMs = l;</span>
<span class="fc" id="L187">    return this;</span>
  }

  /**
   * Set if redirects should be followed or not.
   * Default is defined by OkHttp (true, follow redirects).
   */
  public OkHttpClientBuilder setFollowRedirects(Boolean followRedirects) {
<span class="fc" id="L195">    this.followRedirects = followRedirects;</span>
<span class="fc" id="L196">    return this;</span>
  }

  public OkHttpClient build() {
<span class="fc" id="L200">    OkHttpClient.Builder builder = new OkHttpClient.Builder();</span>
<span class="fc" id="L201">    builder.proxy(proxy);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">    if (connectTimeoutMs &gt;= 0) {</span>
<span class="fc" id="L203">      builder.connectTimeout(connectTimeoutMs, TimeUnit.MILLISECONDS);</span>
    }
<span class="fc bfc" id="L205" title="All 2 branches covered.">    if (readTimeoutMs &gt;= 0) {</span>
<span class="fc" id="L206">      builder.readTimeout(readTimeoutMs, TimeUnit.MILLISECONDS);</span>
    }
<span class="fc bfc" id="L208" title="All 2 branches covered.">    if (responseTimeoutMs &gt;= 0) {</span>
<span class="fc" id="L209">      builder.callTimeout(responseTimeoutMs, TimeUnit.MILLISECONDS);</span>
    }
<span class="fc" id="L211">    builder.addNetworkInterceptor(this::addHeaders);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">    if (!acceptGzip) {</span>
<span class="fc" id="L213">      builder.addNetworkInterceptor(new GzipRejectorInterceptor());</span>
    }
<span class="fc bfc" id="L215" title="All 2 branches covered.">    if (proxyLogin != null) {</span>
<span class="fc" id="L216">      builder.proxyAuthenticator((route, response) -&gt; {</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (response.request().header(PROXY_AUTHORIZATION) != null) {</span>
          // Give up, we've already attempted to authenticate.
<span class="fc" id="L219">          return null;</span>
        }
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (HttpURLConnection.HTTP_PROXY_AUTH == response.code()) {</span>
<span class="fc" id="L222">          String credential = Credentials.basic(proxyLogin, nullToEmpty(proxyPassword), UTF_8);</span>
<span class="fc" id="L223">          return response.request().newBuilder().header(PROXY_AUTHORIZATION, credential).build();</span>
        }
<span class="nc" id="L225">        return null;</span>
      });
    }
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (followRedirects != null) {</span>
<span class="fc" id="L229">      builder.followRedirects(followRedirects);</span>
<span class="fc" id="L230">      builder.followSslRedirects(followRedirects);</span>
    }

<span class="fc" id="L233">    ConnectionSpec tls = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)</span>
<span class="fc" id="L234">      .allEnabledTlsVersions()</span>
<span class="fc" id="L235">      .allEnabledCipherSuites()</span>
<span class="fc" id="L236">      .supportsTlsExtensions(true)</span>
<span class="fc" id="L237">      .build();</span>
<span class="fc" id="L238">    builder.connectionSpecs(asList(tls, ConnectionSpec.CLEARTEXT));</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">    X509TrustManager trustManager = sslTrustManager != null ? sslTrustManager : systemDefaultTrustManager();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    SSLSocketFactory sslFactory = sslSocketFactory != null ? sslSocketFactory : systemDefaultSslSocketFactory(trustManager);</span>
<span class="fc" id="L242">    builder.sslSocketFactory(sslFactory, trustManager);</span>

<span class="fc" id="L244">    builder.addInterceptor(buildLoggingInterceptor());</span>

<span class="fc" id="L246">    return builder.build();</span>
  }

  private static HttpLoggingInterceptor buildLoggingInterceptor() {
<span class="fc" id="L250">    var logging = new HttpLoggingInterceptor(LOG::debug);</span>
<span class="fc" id="L251">    logging.setLevel(HttpLoggingInterceptor.Level.BASIC);</span>
<span class="fc" id="L252">    return logging;</span>
  }

  private Response addHeaders(Interceptor.Chain chain) throws IOException {
<span class="fc" id="L256">    Request.Builder newRequest = chain.request().newBuilder();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">    if (userAgent != null) {</span>
<span class="fc" id="L258">      newRequest.header(&quot;User-Agent&quot;, userAgent);</span>
    }
<span class="fc bfc" id="L260" title="All 2 branches covered.">    if (credentials != null) {</span>
<span class="fc" id="L261">      newRequest.header(&quot;Authorization&quot;, credentials);</span>
    }
<span class="fc" id="L263">    return chain.proceed(newRequest.build());</span>
  }

  private static X509TrustManager systemDefaultTrustManager() {
    try {
<span class="fc" id="L268">      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="fc" id="L269">      trustManagerFactory.init((KeyStore) null);</span>
<span class="fc" id="L270">      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();</span>
<span class="pc bpc" id="L271" title="2 of 4 branches missed.">      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {</span>
<span class="nc" id="L272">        throw new IllegalStateException(&quot;Unexpected default trust managers:&quot; + Arrays.toString(trustManagers));</span>
      }
<span class="fc" id="L274">      return (X509TrustManager) trustManagers[0];</span>
<span class="nc" id="L275">    } catch (GeneralSecurityException e) {</span>
      // The system has no TLS. Just give up.
<span class="nc" id="L277">      throw new AssertionError(e);</span>
    }
  }

  private static SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
    KeyManager[] defaultKeyManager;
    try {
<span class="fc" id="L284">      defaultKeyManager = getDefaultKeyManager();</span>
<span class="nc" id="L285">    } catch (Exception e) {</span>
<span class="nc" id="L286">      throw new IllegalStateException(&quot;Unable to get default key manager&quot;, e);</span>
<span class="fc" id="L287">    }</span>
    try {
<span class="fc" id="L289">      SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
<span class="fc" id="L290">      sslContext.init(defaultKeyManager, new TrustManager[] {trustManager}, null);</span>
<span class="fc" id="L291">      return sslContext.getSocketFactory();</span>
<span class="nc" id="L292">    } catch (GeneralSecurityException e) {</span>
      // The system has no TLS. Just give up.
<span class="nc" id="L294">      throw new AssertionError(e);</span>
    }
  }

  private static void logDebug(String msg) {
<span class="fc" id="L299">    boolean debugEnabled = &quot;all&quot;.equals(System.getProperty(&quot;javax.net.debug&quot;));</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">    if (debugEnabled) {</span>
<span class="nc" id="L301">      System.out.println(msg);</span>
    }
<span class="fc" id="L303">  }</span>

  /**
   * Inspired from sun.security.ssl.SSLContextImpl#getDefaultKeyManager()
   */
  private static synchronized KeyManager[] getDefaultKeyManager() throws KeyStoreException, NoSuchProviderException,
    IOException, CertificateException, NoSuchAlgorithmException, UnrecoverableKeyException {
<span class="fc" id="L310">    final String defaultKeyStore = System.getProperty(&quot;javax.net.ssl.keyStore&quot;, &quot;&quot;);</span>
<span class="fc" id="L311">    String defaultKeyStoreType = System.getProperty(&quot;javax.net.ssl.keyStoreType&quot;, KeyStore.getDefaultType());</span>
<span class="fc" id="L312">    String defaultKeyStoreProvider = System.getProperty(&quot;javax.net.ssl.keyStoreProvider&quot;, &quot;&quot;);</span>

<span class="fc" id="L314">    logDebug(&quot;keyStore is : &quot; + defaultKeyStore);</span>
<span class="fc" id="L315">    logDebug(&quot;keyStore type is : &quot; + defaultKeyStoreType);</span>
<span class="fc" id="L316">    logDebug(&quot;keyStore provider is : &quot; + defaultKeyStoreProvider);</span>

<span class="pc bpc" id="L318" title="3 of 4 branches missed.">    if (P11KEYSTORE.equals(defaultKeyStoreType) &amp;&amp; !NONE.equals(defaultKeyStore)) {</span>
<span class="nc" id="L319">      throw new IllegalArgumentException(&quot;if keyStoreType is &quot; + P11KEYSTORE + &quot;, then keyStore must be &quot; + NONE);</span>
    }

<span class="fc" id="L322">    KeyStore ks = null;</span>
<span class="fc" id="L323">    String defaultKeyStorePassword = System.getProperty(&quot;javax.net.ssl.keyStorePassword&quot;, &quot;&quot;);</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">    char[] passwd = defaultKeyStorePassword.isEmpty() ? null : defaultKeyStorePassword.toCharArray();</span>

    // Try to initialize key store.
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">    if (!defaultKeyStoreType.isEmpty()) {</span>
<span class="fc" id="L328">      logDebug(&quot;init keystore&quot;);</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">      if (defaultKeyStoreProvider.isEmpty()) {</span>
<span class="fc" id="L330">        ks = KeyStore.getInstance(defaultKeyStoreType);</span>
      } else {
<span class="nc" id="L332">        ks = KeyStore.getInstance(defaultKeyStoreType, defaultKeyStoreProvider);</span>
      }
<span class="pc bpc" id="L334" title="3 of 4 branches missed.">      if (!defaultKeyStore.isEmpty() &amp;&amp; !NONE.equals(defaultKeyStore)) {</span>
<span class="nc" id="L335">        try (FileInputStream fs = new FileInputStream(defaultKeyStore)) {</span>
<span class="nc" id="L336">          ks.load(fs, passwd);</span>
        }
      } else {
<span class="fc" id="L339">        ks.load(null, passwd);</span>
      }
    }

    // Try to initialize key manager.
<span class="fc" id="L344">    logDebug(&quot;init keymanager of type &quot; + KeyManagerFactory.getDefaultAlgorithm());</span>
<span class="fc" id="L345">    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span>

<span class="pc bpc" id="L347" title="1 of 2 branches missed.">    if (P11KEYSTORE.equals(defaultKeyStoreType)) {</span>
      // do not pass key passwd if using token
<span class="nc" id="L349">      kmf.init(ks, null);</span>
    } else {
<span class="fc" id="L351">      kmf.init(ks, passwd);</span>
    }

<span class="fc" id="L354">    return kmf.getKeyManagers();</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>