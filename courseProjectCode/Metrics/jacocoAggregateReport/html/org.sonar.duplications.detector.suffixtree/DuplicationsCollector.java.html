<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DuplicationsCollector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.duplications.detector.suffixtree</a> &gt; <span class="el_source">DuplicationsCollector.java</span></div><h1>DuplicationsCollector.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.duplications.detector.suffixtree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.sonar.duplications.block.Block;
import org.sonar.duplications.detector.ContainsInComparator;
import org.sonar.duplications.index.CloneGroup;
import org.sonar.duplications.index.ClonePart;
import org.sonar.duplications.utils.SortedListsUtils;

/**
 * Implementation of {@link Search.Collector}, which constructs {@link CloneGroup}s.
 */
public class DuplicationsCollector extends Search.Collector {

  private final TextSet text;
  private final String originResourceId;

<span class="fc" id="L39">  private final List&lt;CloneGroup&gt; filtered = new ArrayList&lt;&gt;();</span>

  private int length;
  private int count;
  private int[][] blockNumbers;

<span class="fc" id="L45">  public DuplicationsCollector(TextSet text) {</span>
<span class="fc" id="L46">    this.text = text;</span>
<span class="fc" id="L47">    this.originResourceId = text.getBlock(0).getResourceId();</span>
<span class="fc" id="L48">  }</span>

  /**
   * @return current result
   */
  public List&lt;CloneGroup&gt; getResult() {
<span class="fc" id="L54">    return filtered;</span>
  }

  @Override
  public void startOfGroup(int size, int length) {
<span class="fc" id="L59">    this.blockNumbers = new int[size][2];</span>
<span class="fc" id="L60">    this.length = length;</span>
<span class="fc" id="L61">  }</span>

  /**
   * Constructs ClonePart and saves it for future processing in {@link #endOfGroup()}.
   *
   * @param start number of first block from text for this part
   * @param end number of last block from text for this part
   */
  @Override
  public void part(int start, int end) {
<span class="fc" id="L71">    blockNumbers[count][0] = start;</span>
<span class="fc" id="L72">    blockNumbers[count][1] = end - 1;</span>
<span class="fc" id="L73">    count++;</span>
<span class="fc" id="L74">  }</span>

  /**
   * Constructs CloneGroup and saves it.
   */
  @Override
  public void endOfGroup() {
<span class="fc" id="L81">    ClonePart origin = null;</span>

<span class="fc" id="L83">    CloneGroup.Builder builder = CloneGroup.builder().setLength(length);</span>

<span class="fc" id="L85">    List&lt;ClonePart&gt; parts = new ArrayList&lt;&gt;(count);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">    for (int[] b : blockNumbers) {</span>
<span class="fc" id="L87">      Block firstBlock = text.getBlock(b[0]);</span>
<span class="fc" id="L88">      Block lastBlock = text.getBlock(b[1]);</span>
<span class="fc" id="L89">      ClonePart part = new ClonePart(</span>
<span class="fc" id="L90">        firstBlock.getResourceId(),</span>
<span class="fc" id="L91">        firstBlock.getIndexInFile(),</span>
<span class="fc" id="L92">        firstBlock.getStartLine(),</span>
<span class="fc" id="L93">        lastBlock.getEndLine());</span>

      // TODO Godin: maybe use FastStringComparator here ?
<span class="fc bfc" id="L96" title="All 2 branches covered.">      if (originResourceId.equals(part.getResourceId())) {</span>
        // part from origin
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (origin == null) {</span>
<span class="fc" id="L99">          origin = part;</span>
          // To calculate length important to use the origin, because otherwise block may come from DB without required data
<span class="fc" id="L101">          builder.setLengthInUnits(lastBlock.getEndUnit() - firstBlock.getStartUnit() + 1);</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        } else if (part.getUnitStart() &lt; origin.getUnitStart()) {</span>
<span class="fc" id="L103">          origin = part;</span>
        }
      }

<span class="fc" id="L107">      parts.add(part);</span>
    }

<span class="fc" id="L110">    Collections.sort(parts, ContainsInComparator.CLONEPART_COMPARATOR);</span>
<span class="fc" id="L111">    builder.setOrigin(origin).setParts(parts);</span>

<span class="fc" id="L113">    filter(builder.build());</span>

<span class="fc" id="L115">    reset();</span>
<span class="fc" id="L116">  }</span>

  /**
   * Prepare for processing of next duplication.
   */
  private void reset() {
<span class="fc" id="L122">    blockNumbers = null;</span>
<span class="fc" id="L123">    count = 0;</span>
<span class="fc" id="L124">  }</span>

  /**
   * Saves CloneGroup, if it is not included into previously saved.
   * &lt;p&gt;
   * Current CloneGroup can not include none of CloneGroup, which were constructed before.
   * Proof:
   * According to an order of visiting nodes in suffix tree - length of earlier &gt;= length of current.
   * If length of earlier &gt; length of current, then earlier not contained in current.
   * If length of earlier = length of current, then earlier can be contained in current only
   * when current has exactly the same and maybe some additional CloneParts as earlier,
   * what in his turn will mean that two inner-nodes on same depth will satisfy condition
   * current.startSize &lt;= earlier.startSize &lt;= earlier.endSize &lt;= current.endSize , which is not possible for different inner-nodes on same depth.
   * &lt;/p&gt;
   * Thus this method checks only that none of CloneGroup, which was constructed before, does not include current CloneGroup.
   */
  private void filter(CloneGroup current) {
<span class="fc bfc" id="L141" title="All 2 branches covered.">    for (CloneGroup earlier : filtered) {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">      if (containsIn(current, earlier)) {</span>
<span class="fc" id="L143">        return;</span>
      }
<span class="fc" id="L145">    }</span>
<span class="fc" id="L146">    filtered.add(current);</span>
<span class="fc" id="L147">  }</span>

  /**
   * Checks that second CloneGroup includes first one.
   * &lt;p&gt;
   * CloneGroup A is included in another CloneGroup B, if every part pA from A has part pB in B,
   * which satisfy the conditions:
   * &lt;pre&gt;
   * (pA.resourceId == pB.resourceId) and (pB.unitStart &lt;= pA.unitStart) and (pA.unitEnd &lt;= pB.unitEnd)
   * &lt;/pre&gt;
   * And all resourcesId from B exactly the same as all resourceId from A, which means that also every part pB from B has part pA in A,
   * which satisfy the condition:
   * &lt;pre&gt;
   * pB.resourceId == pA.resourceId
   * &lt;/pre&gt;
   * Inclusion is the partial order, thus this relation is:
   * &lt;ul&gt;
   * &lt;li&gt;reflexive - A in A&lt;/li&gt;
   * &lt;li&gt;transitive - (A in B) and (B in C) =&gt; (A in C)&lt;/li&gt;
   * &lt;li&gt;antisymmetric - (A in B) and (B in A) &lt;=&gt; (A = B)&lt;/li&gt;
   * &lt;/ul&gt;
   * &lt;/p&gt;
   * &lt;p&gt;
   * This method uses the fact that all parts already sorted by resourceId and unitStart (see {@link ContainsInComparator#CLONEPART_COMPARATOR}),
   * so running time - O(|A|+|B|).
   * &lt;/p&gt;
   */
  private static boolean containsIn(CloneGroup first, CloneGroup second) {
<span class="fc" id="L175">    List&lt;ClonePart&gt; firstParts = first.getCloneParts();</span>
<span class="fc" id="L176">    List&lt;ClonePart&gt; secondParts = second.getCloneParts();</span>
    // TODO Godin: according to tests seems that if first part of condition is true, then second part can not be false
    // if this can be proved, then second part can be removed
<span class="fc bfc" id="L179" title="All 2 branches covered.">    return SortedListsUtils.contains(secondParts, firstParts, new ContainsInComparator(second.getCloneUnitLength(), first.getCloneUnitLength()))</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">      &amp;&amp; SortedListsUtils.contains(firstParts, secondParts, ContainsInComparator.RESOURCE_ID_COMPARATOR);</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>