<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IssueIndex.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.issue.index</a> &gt; <span class="el_source">IssueIndex.java</span></div><h1>IssueIndex.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.issue.index;

import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.lucene.search.join.ScoreMode;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.NestedQueryBuilder;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.indices.TermsLookup;
import org.elasticsearch.search.aggregations.Aggregation;
import org.elasticsearch.search.aggregations.AggregationBuilder;
import org.elasticsearch.search.aggregations.AggregationBuilders;
import org.elasticsearch.search.aggregations.BucketOrder;
import org.elasticsearch.search.aggregations.HasAggregations;
import org.elasticsearch.search.aggregations.bucket.MultiBucketsAggregation;
import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;
import org.elasticsearch.search.aggregations.bucket.filter.FiltersAggregator;
import org.elasticsearch.search.aggregations.bucket.filter.ParsedFilter;
import org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramInterval;
import org.elasticsearch.search.aggregations.bucket.histogram.LongBounds;
import org.elasticsearch.search.aggregations.bucket.nested.ParsedNested;
import org.elasticsearch.search.aggregations.bucket.terms.IncludeExclude;
import org.elasticsearch.search.aggregations.bucket.terms.ParsedStringTerms;
import org.elasticsearch.search.aggregations.bucket.terms.Terms;
import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;
import org.elasticsearch.search.aggregations.metrics.Min;
import org.elasticsearch.search.aggregations.metrics.ParsedMax;
import org.elasticsearch.search.aggregations.metrics.ParsedValueCount;
import org.elasticsearch.search.aggregations.metrics.SumAggregationBuilder;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.sort.FieldSortBuilder;
import org.joda.time.Duration;
import org.sonar.api.config.Configuration;
import org.sonar.api.issue.Issue;
import org.sonar.api.issue.IssueStatus;
import org.sonar.api.issue.impact.SoftwareQuality;
import org.sonar.api.rule.Severity;
import org.sonar.api.rules.CleanCodeAttributeCategory;
import org.sonar.api.server.rule.RulesDefinition;
import org.sonar.api.server.rule.RulesDefinition.OwaspMobileTop10Version;
import org.sonar.api.server.rule.RulesDefinition.OwaspTop10Version;
import org.sonar.api.server.rule.RulesDefinition.PciDssVersion;
import org.sonar.api.utils.DateUtils;
import org.sonar.api.utils.System2;
import org.sonar.core.rule.RuleType;
import org.sonar.server.es.EsClient;
import org.sonar.server.es.EsUtils;
import org.sonar.server.es.SearchOptions;
import org.sonar.server.es.Sorting;
import org.sonar.server.es.searchrequest.RequestFiltersComputer;
import org.sonar.server.es.searchrequest.RequestFiltersComputer.AllFilters;
import org.sonar.server.es.searchrequest.SimpleFieldTopAggregationDefinition;
import org.sonar.server.es.searchrequest.SubAggregationHelper;
import org.sonar.server.es.searchrequest.TopAggregationDefinition;
import org.sonar.server.es.searchrequest.TopAggregationDefinition.FilterScope;
import org.sonar.server.es.searchrequest.TopAggregationDefinition.SimpleFieldFilterScope;
import org.sonar.server.es.searchrequest.TopAggregationHelper;
import org.sonar.server.issue.index.IssueQuery.PeriodStart;
import org.sonar.server.permission.index.AuthorizationDoc;
import org.sonar.server.permission.index.WebAuthorizationTypeSupport;
import org.sonar.server.security.SecurityStandards;
import org.sonar.server.security.SecurityStandards.PciDss;
import org.sonar.server.security.SecurityStandards.SQCategory;
import org.sonar.server.security.SecurityStandards.StigSupportedRequirement;
import org.sonar.server.user.UserSession;
import org.sonar.server.view.index.ViewIndexDefinition;
import org.springframework.util.CollectionUtils;

import static com.google.common.base.Preconditions.checkState;
import static java.lang.String.format;
import static java.util.Collections.singletonList;
import static java.util.stream.Collectors.toCollection;
import static org.elasticsearch.index.query.QueryBuilders.boolQuery;
import static org.elasticsearch.index.query.QueryBuilders.existsQuery;
import static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;
import static org.elasticsearch.index.query.QueryBuilders.nestedQuery;
import static org.elasticsearch.index.query.QueryBuilders.prefixQuery;
import static org.elasticsearch.index.query.QueryBuilders.rangeQuery;
import static org.elasticsearch.index.query.QueryBuilders.termQuery;
import static org.elasticsearch.index.query.QueryBuilders.termsQuery;
import static org.elasticsearch.search.aggregations.AggregationBuilders.filters;
import static org.elasticsearch.search.aggregations.AggregationBuilders.reverseNested;
import static org.sonar.core.config.MQRModeConstants.MULTI_QUALITY_MODE_DEFAULT_VALUE;
import static org.sonar.core.config.MQRModeConstants.MULTI_QUALITY_MODE_ENABLED;
import static org.sonar.core.rule.RuleType.SECURITY_HOTSPOT;
import static org.sonar.core.rule.RuleType.VULNERABILITY;
import static org.sonar.server.es.EsUtils.escapeSpecialRegexChars;
import static org.sonar.server.es.IndexType.FIELD_INDEX_TYPE;
import static org.sonar.server.es.searchrequest.TopAggregationDefinition.NON_STICKY;
import static org.sonar.server.es.searchrequest.TopAggregationDefinition.STICKY;
import static org.sonar.server.es.searchrequest.TopAggregationHelper.NO_EXTRA_FILTER;
import static org.sonar.server.es.searchrequest.TopAggregationHelper.NO_OTHER_SUBAGGREGATION;
import static org.sonar.server.issue.index.IssueIndex.Facet.ASSIGNED_TO_ME;
import static org.sonar.server.issue.index.IssueIndex.Facet.ASSIGNEES;
import static org.sonar.server.issue.index.IssueIndex.Facet.AUTHOR;
import static org.sonar.server.issue.index.IssueIndex.Facet.CASA;
import static org.sonar.server.issue.index.IssueIndex.Facet.CLEAN_CODE_ATTRIBUTE_CATEGORY;
import static org.sonar.server.issue.index.IssueIndex.Facet.CODE_VARIANTS;
import static org.sonar.server.issue.index.IssueIndex.Facet.CREATED_AT;
import static org.sonar.server.issue.index.IssueIndex.Facet.CWE;
import static org.sonar.server.issue.index.IssueIndex.Facet.DIRECTORIES;
import static org.sonar.server.issue.index.IssueIndex.Facet.FILES;
import static org.sonar.server.issue.index.IssueIndex.Facet.IMPACT_SEVERITY;
import static org.sonar.server.issue.index.IssueIndex.Facet.IMPACT_SOFTWARE_QUALITY;
import static org.sonar.server.issue.index.IssueIndex.Facet.ISSUE_STATUSES;
import static org.sonar.server.issue.index.IssueIndex.Facet.LANGUAGES;
import static org.sonar.server.issue.index.IssueIndex.Facet.OWASP_ASVS_40;
import static org.sonar.server.issue.index.IssueIndex.Facet.OWASP_MOBILE_TOP_10_2024;
import static org.sonar.server.issue.index.IssueIndex.Facet.OWASP_TOP_10;
import static org.sonar.server.issue.index.IssueIndex.Facet.OWASP_TOP_10_2021;
import static org.sonar.server.issue.index.IssueIndex.Facet.PCI_DSS_32;
import static org.sonar.server.issue.index.IssueIndex.Facet.PCI_DSS_40;
import static org.sonar.server.issue.index.IssueIndex.Facet.PRIORITIZED_RULE;
import static org.sonar.server.issue.index.IssueIndex.Facet.FROM_SONAR_QUBE_UPDATE;
import static org.sonar.server.issue.index.IssueIndex.Facet.PROJECT_UUIDS;
import static org.sonar.server.issue.index.IssueIndex.Facet.RESOLUTIONS;
import static org.sonar.server.issue.index.IssueIndex.Facet.RULES;
import static org.sonar.server.issue.index.IssueIndex.Facet.SANS_TOP_25;
import static org.sonar.server.issue.index.IssueIndex.Facet.SCOPES;
import static org.sonar.server.issue.index.IssueIndex.Facet.SEVERITIES;
import static org.sonar.server.issue.index.IssueIndex.Facet.SONARSOURCE_SECURITY;
import static org.sonar.server.issue.index.IssueIndex.Facet.STATUSES;
import static org.sonar.server.issue.index.IssueIndex.Facet.STIG_ASD_V5R3;
import static org.sonar.server.issue.index.IssueIndex.Facet.TAGS;
import static org.sonar.server.issue.index.IssueIndex.Facet.TYPES;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_ASSIGNEE_UUID;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_AUTHOR_LOGIN;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_BRANCH_UUID;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_CASA;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_CLEAN_CODE_ATTRIBUTE_CATEGORY;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_CODE_VARIANTS;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_COMPONENT_UUID;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_CWE;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_DIRECTORY_PATH;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_EFFORT;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_FILE_PATH;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_FUNC_CLOSED_AT;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_FUNC_CREATED_AT;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_FUNC_UPDATED_AT;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_IMPACTS;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_IMPACT_SEVERITY;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_IS_MAIN_BRANCH;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_KEY;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_LANGUAGE;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_LINE;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_NEW_CODE_REFERENCE;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_NEW_STATUS;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_OWASP_ASVS_40;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_OWASP_MOBILE_TOP_10_2024;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_OWASP_TOP_10;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_OWASP_TOP_10_2021;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_PCI_DSS_32;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_PCI_DSS_40;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_PROJECT_UUID;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_RESOLUTION;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_RULE_UUID;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_SANS_TOP_25;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_SCOPE;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_SEVERITY;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_SEVERITY_VALUE;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_SQ_SECURITY_CATEGORY;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_STATUS;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_STIG_ASD_V5R3;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_TAGS;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_TYPE;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_ISSUE_VULNERABILITY_PROBABILITY;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_PRIORITIZED_RULE;
import static org.sonar.server.issue.index.IssueIndexDefinition.FIELD_FROM_SONAR_QUBE_UPDATE;
import static org.sonar.server.issue.index.IssueIndexDefinition.TYPE_ISSUE;
import static org.sonar.server.security.SecurityReviewRating.computePercent;
import static org.sonar.server.security.SecurityReviewRating.computeRating;
import static org.sonar.server.security.SecurityStandards.CWES_BY_CWE_TOP_25;
import static org.sonar.server.security.SecurityStandards.OWASP_ASVS_40_REQUIREMENTS_BY_LEVEL;
import static org.sonar.server.view.index.ViewIndexDefinition.TYPE_VIEW;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.FACET_MODE_EFFORT;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_ASSIGNEES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_AUTHOR;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_CASA;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_CLEAN_CODE_ATTRIBUTE_CATEGORIES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_CODE_VARIANTS;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_CREATED_AT;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_CWE;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_DIRECTORIES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_FILES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_IMPACT_SEVERITIES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_IMPACT_SOFTWARE_QUALITIES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_ISSUE_STATUSES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_LANGUAGES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_OWASP_ASVS_40;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_OWASP_MOBILE_TOP_10_2024;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_OWASP_TOP_10;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_OWASP_TOP_10_2021;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_PCI_DSS_32;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_PCI_DSS_40;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_PRIORITIZED_RULE;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_FROM_SONAR_QUBE_UPDATE;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_RESOLUTIONS;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_RULES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_SANS_TOP_25;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_SCOPES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_SEVERITIES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_SONARSOURCE_SECURITY;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_STATUSES;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_STIG_ASD_V5R3;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_TAGS;
import static org.sonarqube.ws.client.issue.IssuesWsParameters.PARAM_TYPES;

/**
 * The unique entry-point to interact with Elasticsearch index &quot;issues&quot;.
 * All the requests are listed here.
 */
public class IssueIndex {

  public static final String FACET_PROJECTS = &quot;projects&quot;;
  public static final String FACET_ASSIGNED_TO_ME = &quot;assigned_to_me&quot;;

  private static final int DEFAULT_FACET_SIZE = 15;
  private static final int MAX_FACET_SIZE = 100;
  private static final String AGG_VULNERABILITIES = &quot;vulnerabilities&quot;;
  private static final String AGG_SEVERITIES = &quot;severities&quot;;
  private static final String ISSUES_WITH_SECURITY_IMPACT = &quot;issues_with_security_impact&quot;;
  private static final String AGG_IMPACT_SEVERITIES = &quot;impact_severities&quot;;
  private static final String AGG_TO_REVIEW_SECURITY_HOTSPOTS = &quot;toReviewSecurityHotspots&quot;;
  private static final String AGG_REVIEWED_SECURITY_HOTSPOTS = &quot;reviewedSecurityHotspots&quot;;
  private static final String AGG_DISTRIBUTION = &quot;distribution&quot;;
<span class="fc" id="L270">  private static final BoolQueryBuilder NON_RESOLVED_VULNERABILITIES_FILTER = boolQuery()</span>
<span class="fc" id="L271">    .filter(termQuery(FIELD_ISSUE_TYPE, VULNERABILITY.name()))</span>
<span class="fc" id="L272">    .mustNot(existsQuery(FIELD_ISSUE_RESOLUTION));</span>
<span class="fc" id="L273">  private static final BoolQueryBuilder NON_RESOLVED_SECURITY_IMPACT_FILTER = boolQuery()</span>
<span class="fc" id="L274">    .filter(nestedQuery(FIELD_ISSUE_IMPACTS, termsQuery(FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY, SoftwareQuality.SECURITY.name()),</span>
      ScoreMode.Avg))
<span class="fc" id="L276">    .mustNot(existsQuery(FIELD_ISSUE_RESOLUTION));</span>
<span class="fc" id="L277">  private static final BoolQueryBuilder TO_REVIEW_HOTSPOTS_FILTER = boolQuery()</span>
<span class="fc" id="L278">    .filter(termQuery(FIELD_ISSUE_TYPE, SECURITY_HOTSPOT.name()))</span>
<span class="fc" id="L279">    .filter(termQuery(FIELD_ISSUE_STATUS, Issue.STATUS_TO_REVIEW))</span>
<span class="fc" id="L280">    .mustNot(existsQuery(FIELD_ISSUE_RESOLUTION));</span>
<span class="fc" id="L281">  private static final BoolQueryBuilder REVIEWED_HOTSPOTS_FILTER = boolQuery()</span>
<span class="fc" id="L282">    .filter(termQuery(FIELD_ISSUE_TYPE, SECURITY_HOTSPOT.name()))</span>
<span class="fc" id="L283">    .filter(termQuery(FIELD_ISSUE_STATUS, Issue.STATUS_REVIEWED))</span>
<span class="fc" id="L284">    .filter(termQuery(FIELD_ISSUE_RESOLUTION, Issue.RESOLUTION_FIXED));</span>
<span class="fc" id="L285">  private static final NestedQueryBuilder SECURITY_IMPACT_FILTER = nestedQuery(FIELD_ISSUE_IMPACTS,</span>
<span class="fc" id="L286">    termsQuery(FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY, SoftwareQuality.SECURITY.name()), ScoreMode.Avg);</span>
  private static final BoolQueryBuilder SECURITY_IMPACT_AND_HOTSPOT_FILTER =
<span class="fc" id="L288">    boolQuery()</span>
<span class="fc" id="L289">      .should(SECURITY_IMPACT_FILTER)</span>
<span class="fc" id="L290">      .should(termsQuery(FIELD_ISSUE_TYPE, SECURITY_HOTSPOT.name()))</span>
<span class="fc" id="L291">      .minimumShouldMatch(1);</span>


<span class="fc" id="L294">  private static final Object[] NO_SELECTED_VALUES = {0};</span>
<span class="fc" id="L295">  private static final SimpleFieldTopAggregationDefinition EFFORT_TOP_AGGREGATION = new SimpleFieldTopAggregationDefinition(FIELD_ISSUE_EFFORT, NON_STICKY);</span>

<span class="fc" id="L297">  public enum Facet {</span>
<span class="fc" id="L298">    SEVERITIES(PARAM_SEVERITIES, FIELD_ISSUE_SEVERITY, STICKY, Severity.ALL.size()),</span>
<span class="fc" id="L299">    IMPACT_SOFTWARE_QUALITY(PARAM_IMPACT_SOFTWARE_QUALITIES, FIELD_ISSUE_IMPACTS, STICKY),</span>
<span class="fc" id="L300">    IMPACT_SEVERITY(PARAM_IMPACT_SEVERITIES, FIELD_ISSUE_IMPACTS, STICKY),</span>
<span class="fc" id="L301">    CLEAN_CODE_ATTRIBUTE_CATEGORY(PARAM_CLEAN_CODE_ATTRIBUTE_CATEGORIES, FIELD_ISSUE_CLEAN_CODE_ATTRIBUTE_CATEGORY, STICKY, CleanCodeAttributeCategory.values().length),</span>
<span class="fc" id="L302">    STATUSES(PARAM_STATUSES, FIELD_ISSUE_STATUS, STICKY, Issue.STATUSES.size()),</span>
    // Resolutions facet returns one more element than the number of resolutions to take into account unresolved issues
<span class="fc" id="L304">    RESOLUTIONS(PARAM_RESOLUTIONS, FIELD_ISSUE_RESOLUTION, STICKY, Issue.RESOLUTIONS.size() + 1),</span>
<span class="fc" id="L305">    ISSUE_STATUSES(PARAM_ISSUE_STATUSES, FIELD_ISSUE_NEW_STATUS, STICKY, IssueStatus.values().length),</span>
<span class="fc" id="L306">    TYPES(PARAM_TYPES, FIELD_ISSUE_TYPE, STICKY, RuleType.values().length),</span>
<span class="fc" id="L307">    SCOPES(PARAM_SCOPES, FIELD_ISSUE_SCOPE, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L308">    LANGUAGES(PARAM_LANGUAGES, FIELD_ISSUE_LANGUAGE, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L309">    RULES(PARAM_RULES, FIELD_ISSUE_RULE_UUID, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L310">    TAGS(PARAM_TAGS, FIELD_ISSUE_TAGS, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L311">    AUTHOR(PARAM_AUTHOR, FIELD_ISSUE_AUTHOR_LOGIN, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L312">    PROJECT_UUIDS(FACET_PROJECTS, FIELD_ISSUE_PROJECT_UUID, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L313">    FILES(PARAM_FILES, FIELD_ISSUE_FILE_PATH, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L314">    DIRECTORIES(PARAM_DIRECTORIES, FIELD_ISSUE_DIRECTORY_PATH, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L315">    ASSIGNEES(PARAM_ASSIGNEES, FIELD_ISSUE_ASSIGNEE_UUID, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L316">    ASSIGNED_TO_ME(FACET_ASSIGNED_TO_ME, FIELD_ISSUE_ASSIGNEE_UUID, STICKY, 1),</span>
<span class="fc" id="L317">    PCI_DSS_32(PARAM_PCI_DSS_32, FIELD_ISSUE_PCI_DSS_32, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L318">    PCI_DSS_40(PARAM_PCI_DSS_40, FIELD_ISSUE_PCI_DSS_40, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L319">    OWASP_ASVS_40(PARAM_OWASP_ASVS_40, FIELD_ISSUE_OWASP_ASVS_40, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L320">    OWASP_MOBILE_TOP_10_2024(PARAM_OWASP_MOBILE_TOP_10_2024, FIELD_ISSUE_OWASP_MOBILE_TOP_10_2024, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L321">    OWASP_TOP_10(PARAM_OWASP_TOP_10, FIELD_ISSUE_OWASP_TOP_10, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L322">    OWASP_TOP_10_2021(PARAM_OWASP_TOP_10_2021, FIELD_ISSUE_OWASP_TOP_10_2021, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L323">    STIG_ASD_V5R3(PARAM_STIG_ASD_V5R3, FIELD_ISSUE_STIG_ASD_V5R3, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L324">    CASA(PARAM_CASA, FIELD_ISSUE_CASA, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L325">    SANS_TOP_25(PARAM_SANS_TOP_25, FIELD_ISSUE_SANS_TOP_25, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L326">    CWE(PARAM_CWE, FIELD_ISSUE_CWE, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L327">    CREATED_AT(PARAM_CREATED_AT, FIELD_ISSUE_FUNC_CREATED_AT, NON_STICKY),</span>
<span class="fc" id="L328">    SONARSOURCE_SECURITY(PARAM_SONARSOURCE_SECURITY, FIELD_ISSUE_SQ_SECURITY_CATEGORY, STICKY, DEFAULT_FACET_SIZE),</span>
<span class="fc" id="L329">    CODE_VARIANTS(PARAM_CODE_VARIANTS, FIELD_ISSUE_CODE_VARIANTS, STICKY, MAX_FACET_SIZE),</span>
<span class="fc" id="L330">    PRIORITIZED_RULE(PARAM_PRIORITIZED_RULE, FIELD_PRIORITIZED_RULE, STICKY, 2),</span>
<span class="fc" id="L331">    FROM_SONAR_QUBE_UPDATE(PARAM_FROM_SONAR_QUBE_UPDATE, FIELD_FROM_SONAR_QUBE_UPDATE, STICKY, 2);</span>

    private final String name;
    private final TopAggregationDefinition&lt;FilterScope&gt; topAggregation;
    private final Integer numberOfTerms;

<span class="fc" id="L337">    Facet(String name, String fieldName, boolean sticky, int numberOfTerms) {</span>
<span class="fc" id="L338">      this.name = name;</span>
<span class="fc" id="L339">      this.topAggregation = new SimpleFieldTopAggregationDefinition(fieldName, sticky);</span>
<span class="fc" id="L340">      this.numberOfTerms = numberOfTerms;</span>
<span class="fc" id="L341">    }</span>

<span class="fc" id="L343">    Facet(String name, String fieldName, boolean sticky) {</span>
<span class="fc" id="L344">      this.name = name;</span>
<span class="fc" id="L345">      this.topAggregation = new SimpleFieldTopAggregationDefinition(fieldName, sticky);</span>
<span class="fc" id="L346">      this.numberOfTerms = null;</span>
<span class="fc" id="L347">    }</span>

    public String getName() {
<span class="fc" id="L350">      return name;</span>
    }

    public String getFieldName() {
<span class="fc" id="L354">      return topAggregation.getFilterScope().getFieldName();</span>
    }

    public FilterScope getFilterScope() {
<span class="fc" id="L358">      return topAggregation.getFilterScope();</span>
    }

    public TopAggregationDefinition&lt;FilterScope&gt; getTopAggregationDef() {
<span class="fc" id="L362">      return topAggregation;</span>
    }

    public int getNumberOfTerms() {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">      checkState(numberOfTerms != null, &quot;numberOfTerms should have been provided in constructor&quot;);</span>

<span class="fc" id="L368">      return numberOfTerms;</span>
    }
  }

<span class="fc" id="L372">  private static final Map&lt;String, Facet&gt; FACETS_BY_NAME = Arrays.stream(Facet.values())</span>
<span class="fc" id="L373">    .collect(Collectors.toMap(Facet::getName, Function.identity()));</span>

  private static final String SUBSTRING_MATCH_REGEXP = &quot;.*%s.*&quot;;
  // TODO to be documented
  // TODO move to Facets ?
  private static final String FACET_SUFFIX_MISSING = &quot;_missing&quot;;
  private static final String IS_ASSIGNED_FILTER = &quot;__isAssigned&quot;;
<span class="fc" id="L380">  private static final SumAggregationBuilder EFFORT_AGGREGATION = AggregationBuilders.sum(FACET_MODE_EFFORT).field(FIELD_ISSUE_EFFORT);</span>
<span class="fc" id="L381">  private static final BucketOrder EFFORT_AGGREGATION_ORDER = BucketOrder.aggregation(FACET_MODE_EFFORT, false);</span>
<span class="fc" id="L382">  private static final Duration TWENTY_DAYS = Duration.standardDays(20L);</span>
<span class="fc" id="L383">  private static final Duration TWENTY_WEEKS = Duration.standardDays(20L * 7L);</span>
<span class="fc" id="L384">  private static final Duration TWENTY_MONTHS = Duration.standardDays(20L * 30L);</span>
  private static final String AGG_COUNT = &quot;count&quot;;
  private final Sorting sorting;
  private final EsClient client;
  private final System2 system;
  private final UserSession userSession;
  private final WebAuthorizationTypeSupport authorizationTypeSupport;
  private final Configuration config;

  public IssueIndex(EsClient client, System2 system, UserSession userSession, WebAuthorizationTypeSupport authorizationTypeSupport,
<span class="fc" id="L394">    Configuration config) {</span>
<span class="fc" id="L395">    this.client = client;</span>
<span class="fc" id="L396">    this.system = system;</span>
<span class="fc" id="L397">    this.userSession = userSession;</span>
<span class="fc" id="L398">    this.authorizationTypeSupport = authorizationTypeSupport;</span>
<span class="fc" id="L399">    this.config = config;</span>

<span class="fc" id="L401">    this.sorting = new Sorting();</span>
<span class="fc" id="L402">    this.sorting.add(IssueQuery.SORT_BY_STATUS, FIELD_ISSUE_STATUS);</span>
<span class="fc" id="L403">    this.sorting.add(IssueQuery.SORT_BY_STATUS, FIELD_ISSUE_KEY);</span>
<span class="fc" id="L404">    this.sorting.add(IssueQuery.SORT_BY_SEVERITY, FIELD_ISSUE_SEVERITY_VALUE);</span>
<span class="fc" id="L405">    this.sorting.add(IssueQuery.SORT_BY_SEVERITY, FIELD_ISSUE_KEY);</span>
<span class="fc" id="L406">    this.sorting.add(IssueQuery.SORT_BY_CREATION_DATE, FIELD_ISSUE_FUNC_CREATED_AT);</span>
<span class="fc" id="L407">    this.sorting.add(IssueQuery.SORT_BY_CREATION_DATE, FIELD_ISSUE_KEY);</span>
<span class="fc" id="L408">    this.sorting.add(IssueQuery.SORT_BY_UPDATE_DATE, FIELD_ISSUE_FUNC_UPDATED_AT);</span>
<span class="fc" id="L409">    this.sorting.add(IssueQuery.SORT_BY_UPDATE_DATE, FIELD_ISSUE_KEY);</span>
<span class="fc" id="L410">    this.sorting.add(IssueQuery.SORT_BY_CLOSE_DATE, FIELD_ISSUE_FUNC_CLOSED_AT);</span>
<span class="fc" id="L411">    this.sorting.add(IssueQuery.SORT_BY_CLOSE_DATE, FIELD_ISSUE_KEY);</span>
<span class="fc" id="L412">    this.sorting.add(IssueQuery.SORT_BY_FILE_LINE, FIELD_ISSUE_PROJECT_UUID);</span>
<span class="fc" id="L413">    this.sorting.add(IssueQuery.SORT_BY_FILE_LINE, FIELD_ISSUE_FILE_PATH);</span>
<span class="fc" id="L414">    this.sorting.add(IssueQuery.SORT_BY_FILE_LINE, FIELD_ISSUE_LINE);</span>
<span class="fc" id="L415">    this.sorting.add(IssueQuery.SORT_BY_FILE_LINE, FIELD_ISSUE_SEVERITY_VALUE).reverse();</span>
<span class="fc" id="L416">    this.sorting.add(IssueQuery.SORT_BY_FILE_LINE, FIELD_ISSUE_KEY);</span>
<span class="fc" id="L417">    this.sorting.add(IssueQuery.SORT_HOTSPOTS, FIELD_ISSUE_VULNERABILITY_PROBABILITY).reverse();</span>
<span class="fc" id="L418">    this.sorting.add(IssueQuery.SORT_HOTSPOTS, FIELD_ISSUE_SQ_SECURITY_CATEGORY);</span>
<span class="fc" id="L419">    this.sorting.add(IssueQuery.SORT_HOTSPOTS, FIELD_ISSUE_RULE_UUID);</span>
<span class="fc" id="L420">    this.sorting.add(IssueQuery.SORT_HOTSPOTS, FIELD_ISSUE_PROJECT_UUID);</span>
<span class="fc" id="L421">    this.sorting.add(IssueQuery.SORT_HOTSPOTS, FIELD_ISSUE_FILE_PATH);</span>
<span class="fc" id="L422">    this.sorting.add(IssueQuery.SORT_HOTSPOTS, FIELD_ISSUE_LINE);</span>
<span class="fc" id="L423">    this.sorting.add(IssueQuery.SORT_HOTSPOTS, FIELD_ISSUE_KEY);</span>

    // by default order by created date, project, file, line and issue key (in order to be deterministic when same ms)
<span class="fc" id="L426">    this.sorting.addDefault(FIELD_ISSUE_FUNC_CREATED_AT).reverse();</span>
<span class="fc" id="L427">    this.sorting.addDefault(FIELD_ISSUE_PROJECT_UUID);</span>
<span class="fc" id="L428">    this.sorting.addDefault(FIELD_ISSUE_FILE_PATH);</span>
<span class="fc" id="L429">    this.sorting.addDefault(FIELD_ISSUE_LINE);</span>
<span class="fc" id="L430">    this.sorting.addDefault(FIELD_ISSUE_KEY);</span>
<span class="fc" id="L431">  }</span>

  public SearchResponse search(IssueQuery query, SearchOptions options) {
<span class="fc" id="L434">    SearchRequest requestBuilder = EsClient.prepareSearch(TYPE_ISSUE.getMainType());</span>
<span class="fc" id="L435">    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();</span>
<span class="fc" id="L436">    requestBuilder.source(sourceBuilder);</span>

<span class="fc" id="L438">    configureSorting(query, sourceBuilder);</span>
<span class="fc" id="L439">    configurePagination(options, sourceBuilder);</span>
<span class="fc" id="L440">    configureRouting(query, options, requestBuilder);</span>

<span class="fc" id="L442">    AllFilters allFilters = createAllFilters(query);</span>
<span class="fc" id="L443">    RequestFiltersComputer filterComputer = newFilterComputer(options, allFilters);</span>

<span class="fc" id="L445">    configureTopAggregations(query, options, sourceBuilder, allFilters, filterComputer);</span>
<span class="fc" id="L446">    configureQuery(sourceBuilder, filterComputer);</span>
<span class="fc" id="L447">    configureTopFilters(sourceBuilder, filterComputer);</span>

<span class="fc" id="L449">    sourceBuilder.fetchSource(false)</span>
<span class="fc" id="L450">      .trackTotalHits(true);</span>

<span class="fc" id="L452">    return client.search(requestBuilder);</span>
  }

  private void configureTopAggregations(IssueQuery query, SearchOptions options, SearchSourceBuilder esRequest, AllFilters allFilters,
    RequestFiltersComputer filterComputer) {
<span class="fc" id="L457">    TopAggregationHelper aggregationHelper = newAggregationHelper(filterComputer, query);</span>

<span class="fc" id="L459">    configureTopAggregations(aggregationHelper, query, options, allFilters, esRequest);</span>
<span class="fc" id="L460">  }</span>

  private static void configureQuery(SearchSourceBuilder esRequest, RequestFiltersComputer filterComputer) {
<span class="fc" id="L463">    QueryBuilder esQuery = filterComputer.getQueryFilters()</span>
<span class="fc" id="L464">      .map(t -&gt; (QueryBuilder) boolQuery().must(matchAllQuery()).filter(t))</span>
<span class="fc" id="L465">      .orElse(matchAllQuery());</span>
<span class="fc" id="L466">    esRequest.query(esQuery);</span>
<span class="fc" id="L467">  }</span>

  private static void configureTopFilters(SearchSourceBuilder esRequest, RequestFiltersComputer filterComputer) {
<span class="fc" id="L470">    filterComputer.getPostFilters().ifPresent(esRequest::postFilter);</span>
<span class="fc" id="L471">  }</span>

  /**
   * Optimization - do not send ES request to all shards when scope is restricted
   * to a set of projects. Because project UUID is used for routing, the request
   * can be sent to only the shards containing the specified projects.
   * Note that sticky facets may involve all projects, so this optimization must be
   * disabled when facets are enabled.
   */
  private static void configureRouting(IssueQuery query, SearchOptions options, SearchRequest searchRequest) {
<span class="fc" id="L481">    Collection&lt;String&gt; uuids = query.projectUuids();</span>
<span class="fc bfc" id="L482" title="All 4 branches covered.">    if (!uuids.isEmpty() &amp;&amp; options.getFacets().isEmpty()) {</span>
<span class="fc" id="L483">      searchRequest.routing(uuids.stream().map(AuthorizationDoc::idOf).toArray(String[]::new));</span>
    }
<span class="fc" id="L485">  }</span>

  private static void configurePagination(SearchOptions options, SearchSourceBuilder esSearch) {
<span class="fc" id="L488">    esSearch.from(options.getOffset()).size(options.getLimit());</span>
<span class="fc" id="L489">  }</span>

  private AllFilters createAllFilters(IssueQuery query) {
<span class="fc" id="L492">    AllFilters filters = RequestFiltersComputer.newAllFilters();</span>
<span class="fc" id="L493">    filters.addFilter(&quot;__indexType&quot;, new SimpleFieldFilterScope(FIELD_INDEX_TYPE), termQuery(FIELD_INDEX_TYPE, TYPE_ISSUE.getName()));</span>
<span class="fc" id="L494">    filters.addFilter(&quot;__authorization&quot;, new SimpleFieldFilterScope(&quot;parent&quot;), createAuthorizationFilter());</span>

    // Issue is assigned Filter
<span class="fc bfc" id="L497" title="All 2 branches covered.">    if (Boolean.TRUE.equals(query.assigned())) {</span>
<span class="fc" id="L498">      filters.addFilter(IS_ASSIGNED_FILTER, Facet.ASSIGNEES.getFilterScope(), existsQuery(FIELD_ISSUE_ASSIGNEE_UUID));</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">    } else if (Boolean.FALSE.equals(query.assigned())) {</span>
<span class="fc" id="L500">      filters.addFilter(IS_ASSIGNED_FILTER, ASSIGNEES.getFilterScope(), boolQuery().mustNot(existsQuery(FIELD_ISSUE_ASSIGNEE_UUID)));</span>
    }

    // Issue is Resolved Filter
<span class="fc bfc" id="L504" title="All 2 branches covered.">    if (Boolean.TRUE.equals(query.resolved())) {</span>
<span class="fc" id="L505">      filters.addFilter(&quot;__isResolved&quot;, Facet.RESOLUTIONS.getFilterScope(), existsQuery(FIELD_ISSUE_RESOLUTION));</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">    } else if (Boolean.FALSE.equals(query.resolved())) {</span>
<span class="fc" id="L507">      filters.addFilter(&quot;__isResolved&quot;, Facet.RESOLUTIONS.getFilterScope(), boolQuery().mustNot(existsQuery(FIELD_ISSUE_RESOLUTION)));</span>
    }

    // Field Filters
<span class="fc" id="L511">    filters.addFilter(FIELD_ISSUE_KEY, new SimpleFieldFilterScope(FIELD_ISSUE_KEY), createTermsFilterForNullableCollection(FIELD_ISSUE_KEY, query.issueKeys()));</span>
<span class="fc" id="L512">    filters.addFilter(FIELD_ISSUE_ASSIGNEE_UUID, ASSIGNEES.getFilterScope(), createTermsFilter(FIELD_ISSUE_ASSIGNEE_UUID, query.assignees()));</span>
<span class="fc" id="L513">    filters.addFilter(FIELD_ISSUE_SCOPE, SCOPES.getFilterScope(), createTermsFilter(FIELD_ISSUE_SCOPE, query.scopes()));</span>
<span class="fc" id="L514">    filters.addFilter(FIELD_ISSUE_LANGUAGE, LANGUAGES.getFilterScope(), createTermsFilter(FIELD_ISSUE_LANGUAGE, query.languages()));</span>
<span class="fc" id="L515">    filters.addFilter(FIELD_ISSUE_TAGS, TAGS.getFilterScope(), createTermsFilter(FIELD_ISSUE_TAGS, query.tags()));</span>
<span class="fc" id="L516">    filters.addFilter(FIELD_ISSUE_TYPE, TYPES.getFilterScope(), createTermsFilter(FIELD_ISSUE_TYPE, query.types()));</span>
<span class="fc" id="L517">    filters.addFilter(</span>
      FIELD_ISSUE_CLEAN_CODE_ATTRIBUTE_CATEGORY,
<span class="fc" id="L519">      CLEAN_CODE_ATTRIBUTE_CATEGORY.getFilterScope(),</span>
<span class="fc" id="L520">      createTermsFilter(FIELD_ISSUE_CLEAN_CODE_ATTRIBUTE_CATEGORY, query.cleanCodeAttributesCategories()));</span>
<span class="fc" id="L521">    filters.addFilter(</span>
<span class="fc" id="L522">      FIELD_ISSUE_RESOLUTION, RESOLUTIONS.getFilterScope(),</span>
<span class="fc" id="L523">      createTermsFilter(FIELD_ISSUE_RESOLUTION, query.resolutions()));</span>
<span class="fc" id="L524">    filters.addFilter(</span>
<span class="fc" id="L525">      FIELD_ISSUE_AUTHOR_LOGIN, AUTHOR.getFilterScope(),</span>
<span class="fc" id="L526">      createTermsFilter(FIELD_ISSUE_AUTHOR_LOGIN, query.authors()));</span>
<span class="fc" id="L527">    filters.addFilter(</span>
<span class="fc" id="L528">      FIELD_ISSUE_RULE_UUID, RULES.getFilterScope(), createTermsFilter(</span>
        FIELD_ISSUE_RULE_UUID,
<span class="fc" id="L530">        query.ruleUuids()));</span>
<span class="fc" id="L531">    filters.addFilter(FIELD_ISSUE_STATUS, STATUSES.getFilterScope(), createTermsFilter(FIELD_ISSUE_STATUS, query.statuses()));</span>
<span class="fc" id="L532">    filters.addFilter(FIELD_ISSUE_NEW_STATUS, ISSUE_STATUSES.getFilterScope(), createTermsFilter(FIELD_ISSUE_NEW_STATUS, query.issueStatuses()));</span>
<span class="fc" id="L533">    filters.addFilter(FIELD_ISSUE_CODE_VARIANTS, CODE_VARIANTS.getFilterScope(), createTermsFilter(FIELD_ISSUE_CODE_VARIANTS, query.codeVariants()));</span>
<span class="fc" id="L534">    filters.addFilter(FIELD_PRIORITIZED_RULE, PRIORITIZED_RULE.getFilterScope(), createTermFilter(FIELD_PRIORITIZED_RULE, query.prioritizedRule()));</span>
<span class="fc" id="L535">    filters.addFilter(FIELD_FROM_SONAR_QUBE_UPDATE, FROM_SONAR_QUBE_UPDATE.getFilterScope(), createTermFilter(FIELD_FROM_SONAR_QUBE_UPDATE, query.fromSonarQubeUpdate()));</span>

    // security category
<span class="fc" id="L538">    addSecurityCategoryPrefixFilter(FIELD_ISSUE_PCI_DSS_32, PCI_DSS_32, query.pciDss32(), filters);</span>
<span class="fc" id="L539">    addSecurityCategoryPrefixFilter(FIELD_ISSUE_PCI_DSS_40, PCI_DSS_40, query.pciDss40(), filters);</span>
<span class="fc" id="L540">    addOwaspAsvsFilter(FIELD_ISSUE_OWASP_ASVS_40, OWASP_ASVS_40, query, filters);</span>
<span class="fc" id="L541">    addSecurityCategoryFilter(FIELD_ISSUE_OWASP_MOBILE_TOP_10_2024, OWASP_MOBILE_TOP_10_2024, query.owaspMobileTop10For2024(), filters);</span>
<span class="fc" id="L542">    addSecurityCategoryFilter(FIELD_ISSUE_OWASP_TOP_10, OWASP_TOP_10, query.owaspTop10(), filters);</span>
<span class="fc" id="L543">    addSecurityCategoryFilter(FIELD_ISSUE_OWASP_TOP_10_2021, OWASP_TOP_10_2021, query.owaspTop10For2021(), filters);</span>
<span class="fc" id="L544">    addSecurityCategoryFilter(FIELD_ISSUE_STIG_ASD_V5R3, STIG_ASD_V5R3, query.stigAsdV5R3(), filters);</span>
<span class="fc" id="L545">    addSecurityCategoryPrefixFilter(FIELD_ISSUE_CASA, CASA, query.casa(), filters);</span>
<span class="fc" id="L546">    addSecurityCategoryFilter(FIELD_ISSUE_SANS_TOP_25, SANS_TOP_25, query.sansTop25(), filters);</span>
<span class="fc" id="L547">    addSecurityCategoryFilter(FIELD_ISSUE_CWE, CWE, query.cwe(), filters);</span>
<span class="fc" id="L548">    addSecurityCategoryFilter(FIELD_ISSUE_SQ_SECURITY_CATEGORY, SONARSOURCE_SECURITY, query.sonarsourceSecurity(), filters);</span>

<span class="fc" id="L550">    addSeverityFilter(query, filters);</span>
<span class="fc" id="L551">    addImpactFilters(query, filters);</span>
<span class="fc" id="L552">    addComponentRelatedFilters(query, filters);</span>
<span class="fc" id="L553">    addDatesFilter(filters, query);</span>
<span class="fc" id="L554">    addNewCodeByProjectsFilter(filters, query);</span>
<span class="fc" id="L555">    addNewCodeReferenceFilter(filters, query);</span>
<span class="fc" id="L556">    return filters;</span>
  }

  private void addOwaspAsvsFilter(String fieldName, Facet facet, IssueQuery query, AllFilters allFilters) {
<span class="fc bfc" id="L560" title="All 2 branches covered.">    if (!CollectionUtils.isEmpty(query.owaspAsvs40())) {</span>
<span class="fc" id="L561">      Set&lt;String&gt; requirements = calculateRequirementsForOwaspAsvs40Params(query);</span>
<span class="fc" id="L562">      QueryBuilder securityCategoryFilter = termsQuery(fieldName, requirements);</span>
<span class="fc" id="L563">      allFilters.addFilter(</span>
        fieldName,
<span class="fc" id="L565">        facet.getFilterScope(),</span>
<span class="fc" id="L566">        boolQuery()</span>
<span class="fc" id="L567">          .must(securityCategoryFilter)</span>
<span class="fc" id="L568">          .must(getQueryBuilderForSecurityCategory()));</span>
    }
<span class="fc" id="L570">  }</span>

  private QueryBuilder getQueryBuilderForSecurityCategory() {
<span class="fc bfc" id="L573" title="All 2 branches covered.">    return isMQRMode() ? SECURITY_IMPACT_AND_HOTSPOT_FILTER : termsQuery(FIELD_ISSUE_TYPE, VULNERABILITY.name(), SECURITY_HOTSPOT.name());</span>
  }

  private static Set&lt;String&gt; calculateRequirementsForOwaspAsvs40Params(IssueQuery query) {
<span class="fc" id="L577">    int level = query.getOwaspAsvsLevel().orElse(3);</span>
<span class="fc" id="L578">    List&lt;String&gt; levelRequirements = OWASP_ASVS_40_REQUIREMENTS_BY_LEVEL.get(level);</span>
<span class="fc" id="L579">    return query.owaspAsvs40().stream()</span>
<span class="fc" id="L580">      .flatMap(value -&gt; {</span>
        // it's a specific category required
<span class="fc bfc" id="L582" title="All 2 branches covered.">        if (value.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L583">          return Stream.of(value).filter(levelRequirements::contains);</span>
        } else {
<span class="fc" id="L585">          return SecurityStandards.getRequirementsForCategoryAndLevel(value, level).stream();</span>
        }
<span class="fc" id="L587">      }).collect(Collectors.toSet());</span>
  }

  private void addSecurityCategoryFilter(String fieldName, Facet facet, Collection&lt;String&gt; values, AllFilters allFilters) {
<span class="fc" id="L591">    QueryBuilder securityCategoryFilter = createTermsFilter(fieldName, values);</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">    if (securityCategoryFilter != null) {</span>
<span class="fc" id="L593">      allFilters.addFilter(</span>
        fieldName,
<span class="fc" id="L595">        facet.getFilterScope(),</span>
<span class="fc" id="L596">        boolQuery()</span>
<span class="fc" id="L597">          .must(securityCategoryFilter)</span>
<span class="fc" id="L598">          .must(getQueryBuilderForSecurityCategory()));</span>
    }
<span class="fc" id="L600">  }</span>

  /**
   * &lt;p&gt;Builds the Elasticsearch boolean query to filter the PCI DSS and CASA.&lt;/p&gt;
   *
   * &lt;p&gt;The PCI DSS security report handles all the subcategories as one level. This means that subcategory 1.1 doesn't include the issues from 1.1.1.
   * Taking this into account, the search filter follows the same logic and uses prefix matching for top-level categories and exact matching for subcategories&lt;/p&gt;
   *
   * &lt;p&gt;Example&lt;/p&gt;
   * &lt;p&gt;List of PCI DSS categories in issues: {1.5.8, 1.5.9, 1.6.7}
   *   &lt;ul&gt;
   *     &lt;li&gt;Search: {1}, returns {1.5.8, 1.5.9, 1.6.7}&lt;/li&gt;
   *     &lt;li&gt;Search: {1.5.8}, returns {1.5.8}&lt;/li&gt;
   *     &lt;li&gt;Search: {1.5}, returns {}&lt;/li&gt;
   *   &lt;/ul&gt;
   * &lt;/p&gt;
   *
   * @param fieldName  The PCI DSS version, e.g. pciDss-3.2
   * @param facet      The facet used for the filter
   * @param values     The PCI DSS categories to search for
   * @param allFilters Object that holds all the filters for the Elastic search call
   */
  private void addSecurityCategoryPrefixFilter(String fieldName, Facet facet, Collection&lt;String&gt; values, AllFilters allFilters) {
<span class="fc bfc" id="L623" title="All 2 branches covered.">    if (values.isEmpty()) {</span>
<span class="fc" id="L624">      return;</span>
    }

<span class="fc" id="L627">    BoolQueryBuilder boolQueryBuilder = boolQuery()</span>
      // ensures that at least one &quot;should&quot; query is matched. Without it, &quot;should&quot; queries are optional, when a &quot;must&quot; is also present.
<span class="fc" id="L629">      .minimumShouldMatch(1)</span>
<span class="fc" id="L630">      .must(getQueryBuilderForSecurityCategory());</span>
    // for top level categories a prefix query is added, while for subcategories a term query is used for exact matching
<span class="fc" id="L632">    values.stream().map(v -&gt; choosePrefixQuery(fieldName, v)).forEach(boolQueryBuilder::should);</span>

<span class="fc" id="L634">    allFilters.addFilter(</span>
      fieldName,
<span class="fc" id="L636">      facet.getFilterScope(),</span>
      boolQueryBuilder);
<span class="fc" id="L638">  }</span>

  private static QueryBuilder choosePrefixQuery(String fieldName, String value) {
<span class="fc bfc" id="L641" title="All 2 branches covered.">    return value.contains(&quot;.&quot;) ? createTermFilter(fieldName, value) : createPrefixFilter(fieldName, value + &quot;.&quot;);</span>
  }

  private static void addSeverityFilter(IssueQuery query, AllFilters allFilters) {
<span class="fc" id="L645">    QueryBuilder severityFieldFilter = createTermsFilter(FIELD_ISSUE_SEVERITY, query.severities());</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">    if (severityFieldFilter != null) {</span>
<span class="fc" id="L647">      allFilters.addFilter(</span>
        FIELD_ISSUE_SEVERITY,
<span class="fc" id="L649">        SEVERITIES.getFilterScope(),</span>
<span class="fc" id="L650">        boolQuery()</span>
<span class="fc" id="L651">          .must(severityFieldFilter)</span>
          // Ignore severity of Security HotSpots
<span class="fc" id="L653">          .mustNot(termQuery(FIELD_ISSUE_TYPE, SECURITY_HOTSPOT.name())));</span>
    }
<span class="fc" id="L655">  }</span>

  private static void addImpactFilters(IssueQuery query, AllFilters allFilters) {
<span class="fc bfc" id="L658" title="All 4 branches covered.">    if (query.impactSoftwareQualities().isEmpty() &amp;&amp; query.impactSeverities().isEmpty()) {</span>
<span class="fc" id="L659">      return;</span>
    }

<span class="fc bfc" id="L662" title="All 4 branches covered.">    if (!query.impactSoftwareQualities().isEmpty() &amp;&amp; query.impactSeverities().isEmpty()) {</span>
<span class="fc" id="L663">      allFilters.addFilter(</span>
        FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY,
<span class="fc" id="L665">        IMPACT_SOFTWARE_QUALITY.getFilterScope(),</span>
<span class="fc" id="L666">        nestedQuery(</span>
          FIELD_ISSUE_IMPACTS,
<span class="fc" id="L668">          termsQuery(FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY, query.impactSoftwareQualities()),</span>
          ScoreMode.Avg));
<span class="fc" id="L670">      return;</span>
    }

<span class="pc bpc" id="L673" title="1 of 4 branches missed.">    if (!query.impactSeverities().isEmpty() &amp;&amp; query.impactSoftwareQualities().isEmpty()) {</span>
<span class="fc" id="L674">      allFilters.addFilter(</span>
        FIELD_ISSUE_IMPACT_SEVERITY,
<span class="fc" id="L676">        IMPACT_SEVERITY.getFilterScope(),</span>
<span class="fc" id="L677">        nestedQuery(</span>
          FIELD_ISSUE_IMPACTS,
<span class="fc" id="L679">          termsQuery(FIELD_ISSUE_IMPACT_SEVERITY, query.impactSeverities()),</span>
          ScoreMode.Avg));
<span class="fc" id="L681">      return;</span>
    }

<span class="fc" id="L684">    BoolQueryBuilder impactsFilter = boolQuery()</span>
<span class="fc" id="L685">      .filter(termsQuery(FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY, query.impactSoftwareQualities()))</span>
<span class="fc" id="L686">      .filter(termsQuery(FIELD_ISSUE_IMPACT_SEVERITY, query.impactSeverities()));</span>

<span class="fc" id="L688">    allFilters.addFilter(FIELD_ISSUE_IMPACTS, new SimpleFieldFilterScope(FIELD_ISSUE_IMPACTS),</span>
<span class="fc" id="L689">      nestedQuery(FIELD_ISSUE_IMPACTS, impactsFilter, ScoreMode.Avg));</span>
<span class="fc" id="L690">  }</span>

  private static void addComponentRelatedFilters(IssueQuery query, AllFilters filters) {
<span class="fc" id="L693">    addCommonComponentRelatedFilters(query, filters);</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">    if (query.viewUuids().isEmpty()) {</span>
<span class="fc" id="L695">      addBranchComponentRelatedFilters(query, filters);</span>
    } else {
<span class="fc" id="L697">      addViewRelatedFilters(query, filters);</span>
    }
<span class="fc" id="L699">  }</span>

  private static void addCommonComponentRelatedFilters(IssueQuery query, AllFilters filters) {
<span class="fc" id="L702">    filters.addFilter(FIELD_ISSUE_COMPONENT_UUID, new SimpleFieldFilterScope(FIELD_ISSUE_COMPONENT_UUID),</span>
<span class="fc" id="L703">      createTermsFilter(FIELD_ISSUE_COMPONENT_UUID, query.componentUuids()));</span>

<span class="fc bfc" id="L705" title="All 2 branches covered.">    if (!Boolean.TRUE.equals(query.onComponentOnly())) {</span>
<span class="fc" id="L706">      filters.addFilter(</span>
        FIELD_ISSUE_PROJECT_UUID, new SimpleFieldFilterScope(FIELD_ISSUE_PROJECT_UUID),
<span class="fc" id="L708">        createTermsFilter(FIELD_ISSUE_PROJECT_UUID, query.projectUuids()));</span>

<span class="fc" id="L710">      BoolQueryBuilder directoryFilter = boolQuery();</span>
<span class="fc" id="L711">      query.directories().forEach(directory -&gt; directoryFilter.should(createPrefixFilter(FIELD_ISSUE_DIRECTORY_PATH, directory)));</span>
<span class="fc" id="L712">      filters.addFilter(FIELD_ISSUE_DIRECTORY_PATH, new SimpleFieldFilterScope(FIELD_ISSUE_DIRECTORY_PATH), directoryFilter);</span>

<span class="fc" id="L714">      filters.addFilter(</span>
        FIELD_ISSUE_FILE_PATH, new SimpleFieldFilterScope(FIELD_ISSUE_FILE_PATH),
<span class="fc" id="L716">        createTermsFilter(FIELD_ISSUE_FILE_PATH, query.files()));</span>
    }
<span class="fc" id="L718">  }</span>

  private static void addBranchComponentRelatedFilters(IssueQuery query, AllFilters allFilters) {
<span class="fc bfc" id="L721" title="All 2 branches covered.">    if (Boolean.TRUE.equals(query.onComponentOnly())) {</span>
<span class="fc" id="L722">      return;</span>
    }
<span class="fc bfc" id="L724" title="All 2 branches covered.">    if (query.isMainBranch() != null) {</span>
<span class="fc" id="L725">      allFilters.addFilter(</span>
        &quot;__is_main_branch&quot;, new SimpleFieldFilterScope(FIELD_ISSUE_IS_MAIN_BRANCH),
<span class="fc" id="L727">        createTermFilter(FIELD_ISSUE_IS_MAIN_BRANCH, query.isMainBranch().toString()));</span>
    }
<span class="fc" id="L729">    allFilters.addFilter(</span>
      FIELD_ISSUE_BRANCH_UUID, new SimpleFieldFilterScope(FIELD_ISSUE_BRANCH_UUID),
<span class="fc" id="L731">      createTermFilter(FIELD_ISSUE_BRANCH_UUID, query.branchUuid()));</span>
<span class="fc" id="L732">  }</span>

  private static void addViewRelatedFilters(IssueQuery query, AllFilters allFilters) {
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">    if (Boolean.TRUE.equals(query.onComponentOnly())) {</span>
<span class="nc" id="L736">      return;</span>
    }
<span class="fc" id="L738">    Collection&lt;String&gt; viewUuids = query.viewUuids();</span>
<span class="fc" id="L739">    String branchUuid = query.branchUuid();</span>
<span class="pc bpc" id="L740" title="1 of 4 branches missed.">    boolean onApplicationBranch = branchUuid != null &amp;&amp; !viewUuids.isEmpty();</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">    if (onApplicationBranch) {</span>
<span class="fc" id="L742">      allFilters.addFilter(&quot;__view&quot;, new SimpleFieldFilterScope(&quot;view&quot;), createViewFilter(singletonList(query.branchUuid())));</span>
    } else {
<span class="fc" id="L744">      allFilters.addFilter(&quot;__view&quot;, new SimpleFieldFilterScope(&quot;view&quot;), createViewFilter(viewUuids));</span>
    }
<span class="fc" id="L746">  }</span>

  @CheckForNull
  private static QueryBuilder createViewFilter(Collection&lt;String&gt; viewUuids) {
<span class="pc bpc" id="L750" title="1 of 2 branches missed.">    if (viewUuids.isEmpty()) {</span>
<span class="nc" id="L751">      return null;</span>
    }

<span class="fc" id="L754">    BoolQueryBuilder viewsFilter = boolQuery();</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">    for (String viewUuid : viewUuids) {</span>
<span class="fc" id="L756">      viewsFilter.should(QueryBuilders.termsLookupQuery(FIELD_ISSUE_BRANCH_UUID,</span>
        new TermsLookup(
<span class="fc" id="L758">          TYPE_VIEW.getIndex().getName(),</span>
          viewUuid,
          ViewIndexDefinition.FIELD_PROJECTS)));
<span class="fc" id="L761">    }</span>
<span class="fc" id="L762">    return viewsFilter;</span>
  }

  private static RequestFiltersComputer newFilterComputer(SearchOptions options, AllFilters allFilters) {
<span class="fc" id="L766">    Collection&lt;String&gt; facetNames = options.getFacets();</span>
<span class="fc" id="L767">    Set&lt;TopAggregationDefinition&lt;?&gt;&gt; facets = Stream.concat(</span>
<span class="fc" id="L768">      Stream.of(EFFORT_TOP_AGGREGATION),</span>
<span class="fc" id="L769">      facetNames.stream()</span>
<span class="fc" id="L770">        .map(FACETS_BY_NAME::get)</span>
<span class="fc" id="L771">        .filter(Objects::nonNull)</span>
<span class="fc" id="L772">        .map(Facet::getTopAggregationDef))</span>
<span class="fc" id="L773">      .collect(Collectors.toSet());</span>

<span class="fc" id="L775">    return new RequestFiltersComputer(allFilters, facets);</span>
  }

  private static TopAggregationHelper newAggregationHelper(RequestFiltersComputer filterComputer, IssueQuery query) {
<span class="fc bfc" id="L779" title="All 2 branches covered.">    if (hasQueryEffortFacet(query)) {</span>
<span class="fc" id="L780">      return new TopAggregationHelper(filterComputer, new SubAggregationHelper(EFFORT_AGGREGATION, EFFORT_AGGREGATION_ORDER));</span>
    }
<span class="fc" id="L782">    return new TopAggregationHelper(filterComputer, new SubAggregationHelper());</span>
  }

  private static AggregationBuilder addEffortAggregationIfNeeded(IssueQuery query, AggregationBuilder aggregation) {
<span class="fc bfc" id="L786" title="All 2 branches covered.">    if (hasQueryEffortFacet(query)) {</span>
<span class="fc" id="L787">      aggregation.subAggregation(EFFORT_AGGREGATION);</span>
    }
<span class="fc" id="L789">    return aggregation;</span>
  }

  private static boolean hasQueryEffortFacet(IssueQuery query) {
<span class="fc" id="L793">    return FACET_MODE_EFFORT.equals(query.facetMode());</span>
  }

  /**
   * This method is for creating a filter that passes null to the elasticsearch query whenever empty or null collection is passed.
   * This means that filter will not filter anything, all the documents (issues) will be returned in this case.
   */
  @CheckForNull
  private static QueryBuilder createTermsFilter(String field, Collection&lt;?&gt; values) {
<span class="fc bfc" id="L802" title="All 2 branches covered.">    return values.isEmpty() ? null : termsQuery(field, values);</span>
  }

  /**
   * This method is for creating a filter that passes null to the elasticsearch query only when null collection is passed.
   * This ensures that whenever we pass empty collection to the filter, it will filter out all the documents (issues).
   */
  @CheckForNull
  private static QueryBuilder createTermsFilterForNullableCollection(String field, @Nullable Collection&lt;?&gt; values) {
<span class="fc bfc" id="L811" title="All 2 branches covered.">    return values != null ? termsQuery(field, values) : null;</span>
  }

  @CheckForNull
  private static QueryBuilder createTermFilter(String field, @Nullable String value) {
<span class="fc bfc" id="L816" title="All 2 branches covered.">    return value == null ? null : termQuery(field, value);</span>
  }

  @CheckForNull
  private static QueryBuilder createTermFilter(String field, @Nullable Boolean value) {
<span class="fc bfc" id="L821" title="All 2 branches covered.">    return value == null ? null : termQuery(field, value);</span>
  }

  private static QueryBuilder createPrefixFilter(String field, String value) {
<span class="fc" id="L825">    return prefixQuery(field, value);</span>
  }

  private void configureSorting(IssueQuery query, SearchSourceBuilder esRequest) {
<span class="fc" id="L829">    createSortBuilders(query).forEach(esRequest::sort);</span>
<span class="fc" id="L830">  }</span>

  private List&lt;FieldSortBuilder&gt; createSortBuilders(IssueQuery query) {
<span class="fc" id="L833">    String sortField = query.sort();</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">    if (sortField != null) {</span>
<span class="fc" id="L835">      boolean asc = Boolean.TRUE.equals(query.asc());</span>
<span class="fc" id="L836">      return sorting.fill(sortField, asc);</span>
    }
<span class="fc" id="L838">    return sorting.fillDefault();</span>
  }

  private QueryBuilder createAuthorizationFilter() {
<span class="fc" id="L842">    return authorizationTypeSupport.createQueryFilter();</span>
  }

  private void addDatesFilter(AllFilters filters, IssueQuery query) {
<span class="fc" id="L846">    PeriodStart createdAfter = query.createdAfter();</span>
<span class="fc" id="L847">    Date createdBefore = query.createdBefore();</span>

<span class="fc bfc" id="L849" title="All 2 branches covered.">    validateCreationDateBounds(createdBefore, createdAfter != null ? createdAfter.date() : null);</span>

<span class="fc bfc" id="L851" title="All 2 branches covered.">    if (createdAfter != null) {</span>
<span class="fc" id="L852">      filters.addFilter(</span>
<span class="fc" id="L853">        &quot;__createdAfter&quot;, CREATED_AT.getFilterScope(),</span>
        QueryBuilders
<span class="fc" id="L855">          .rangeQuery(FIELD_ISSUE_FUNC_CREATED_AT)</span>
<span class="fc" id="L856">          .from(createdAfter.date().getTime(), createdAfter.inclusive()));</span>
    }
<span class="fc bfc" id="L858" title="All 2 branches covered.">    if (createdBefore != null) {</span>
<span class="fc" id="L859">      filters.addFilter(</span>
<span class="fc" id="L860">        &quot;__createdBefore&quot;, CREATED_AT.getFilterScope(),</span>
        QueryBuilders
<span class="fc" id="L862">          .rangeQuery(FIELD_ISSUE_FUNC_CREATED_AT)</span>
<span class="fc" id="L863">          .lt(createdBefore.getTime()));</span>
    }
<span class="fc" id="L865">    Date createdAt = query.createdAt();</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">    if (createdAt != null) {</span>
<span class="fc" id="L867">      filters.addFilter(</span>
<span class="fc" id="L868">        &quot;__createdAt&quot;, CREATED_AT.getFilterScope(),</span>
<span class="fc" id="L869">        termQuery(FIELD_ISSUE_FUNC_CREATED_AT, createdAt.getTime()));</span>
    }
<span class="fc" id="L871">  }</span>

  private static void addNewCodeReferenceFilter(AllFilters filters, IssueQuery query) {
<span class="fc" id="L874">    Boolean newCodeOnReference = query.newCodeOnReference();</span>

<span class="fc bfc" id="L876" title="All 2 branches covered.">    if (newCodeOnReference != null) {</span>
<span class="fc" id="L877">      filters.addFilter(</span>
        FIELD_ISSUE_NEW_CODE_REFERENCE, new SimpleFieldFilterScope(FIELD_ISSUE_NEW_CODE_REFERENCE),
<span class="fc" id="L879">        termQuery(FIELD_ISSUE_NEW_CODE_REFERENCE, newCodeOnReference));</span>
    }
<span class="fc" id="L881">  }</span>

  private static void addNewCodeByProjectsFilter(AllFilters allFilters, IssueQuery query) {
<span class="fc" id="L884">    Map&lt;String, PeriodStart&gt; createdAfterByProjectUuids = query.createdAfterByProjectUuids();</span>
<span class="fc" id="L885">    BoolQueryBuilder boolQueryBuilder = boolQuery();</span>
<span class="fc" id="L886">    createdAfterByProjectUuids.forEach((projectOrProjectBranchUuid, createdAfterDate) -&gt; boolQueryBuilder.should(boolQuery()</span>
<span class="fc" id="L887">      .filter(termQuery(FIELD_ISSUE_BRANCH_UUID, projectOrProjectBranchUuid))</span>
<span class="fc" id="L888">      .filter(rangeQuery(FIELD_ISSUE_FUNC_CREATED_AT).from(createdAfterDate.date().getTime(), createdAfterDate.inclusive()))));</span>

<span class="fc" id="L890">    Collection&lt;String&gt; newCodeOnReferenceByProjectUuids = query.newCodeOnReferenceByProjectUuids();</span>
<span class="fc" id="L891">    newCodeOnReferenceByProjectUuids.forEach(projectOrProjectBranchUuid -&gt; boolQueryBuilder.should(boolQuery()</span>
<span class="fc" id="L892">      .filter(termQuery(FIELD_ISSUE_BRANCH_UUID, projectOrProjectBranchUuid))</span>
<span class="fc" id="L893">      .filter(termQuery(FIELD_ISSUE_NEW_CODE_REFERENCE, true))));</span>

<span class="fc" id="L895">    allFilters.addFilter(&quot;__new_code_by_project_uuids&quot;, new SimpleFieldFilterScope(&quot;newCodeByProjectUuids&quot;), boolQueryBuilder);</span>
<span class="fc" id="L896">  }</span>

  private void validateCreationDateBounds(@Nullable Date createdBefore, @Nullable Date createdAfter) {
<span class="fc bfc" id="L899" title="All 4 branches covered.">    Preconditions.checkArgument(createdAfter == null || createdAfter.compareTo(new Date(system.now())) &lt;= 0,</span>
      &quot;Start bound cannot be in the future&quot;);
<span class="fc bfc" id="L901" title="All 6 branches covered.">    Preconditions.checkArgument(createdAfter == null || createdBefore == null || createdAfter.before(createdBefore),</span>
      &quot;Start bound cannot be larger or equal to end bound&quot;);
<span class="fc" id="L903">  }</span>

  private void configureTopAggregations(TopAggregationHelper aggregationHelper, IssueQuery query, SearchOptions options,
    AllFilters queryFilters, SearchSourceBuilder esRequest) {
<span class="fc" id="L907">    addFacetIfNeeded(options, aggregationHelper, esRequest, STATUSES, NO_SELECTED_VALUES);</span>
<span class="fc" id="L908">    addFacetIfNeeded(options, aggregationHelper, esRequest, ISSUE_STATUSES, query.issueStatuses().toArray());</span>
<span class="fc" id="L909">    addFacetIfNeeded(options, aggregationHelper, esRequest, PROJECT_UUIDS, query.projectUuids().toArray());</span>
<span class="fc" id="L910">    addFacetIfNeeded(options, aggregationHelper, esRequest, DIRECTORIES, query.directories().toArray());</span>
<span class="fc" id="L911">    addFacetIfNeeded(options, aggregationHelper, esRequest, FILES, query.files().toArray());</span>
<span class="fc" id="L912">    addFacetIfNeeded(options, aggregationHelper, esRequest, SCOPES, query.scopes().toArray());</span>
<span class="fc" id="L913">    addFacetIfNeeded(options, aggregationHelper, esRequest, LANGUAGES, query.languages().toArray());</span>
<span class="fc" id="L914">    addFacetIfNeeded(options, aggregationHelper, esRequest, RULES, query.ruleUuids().toArray());</span>
<span class="fc" id="L915">    addFacetIfNeeded(options, aggregationHelper, esRequest, AUTHOR, query.authors().toArray());</span>
<span class="fc" id="L916">    addFacetIfNeeded(options, aggregationHelper, esRequest, TAGS, query.tags().toArray());</span>
<span class="fc" id="L917">    addFacetIfNeeded(options, aggregationHelper, esRequest, TYPES, query.types().toArray());</span>
<span class="fc" id="L918">    addFacetIfNeeded(options, aggregationHelper, esRequest, CODE_VARIANTS, query.codeVariants().toArray());</span>
<span class="fc" id="L919">    addFacetIfNeeded(options, aggregationHelper, esRequest, CLEAN_CODE_ATTRIBUTE_CATEGORY, query.cleanCodeAttributesCategories().toArray());</span>
<span class="fc" id="L920">    addFacetIfNeeded(options, aggregationHelper, esRequest, PRIORITIZED_RULE, ArrayUtils.EMPTY_OBJECT_ARRAY);</span>
<span class="fc" id="L921">    addFacetIfNeeded(options, aggregationHelper, esRequest, FROM_SONAR_QUBE_UPDATE, ArrayUtils.EMPTY_OBJECT_ARRAY);</span>

<span class="fc" id="L923">    addSecurityCategoryFacetIfNeeded(PARAM_PCI_DSS_32, PCI_DSS_32, options, aggregationHelper, esRequest, query.pciDss32().toArray());</span>
<span class="fc" id="L924">    addSecurityCategoryFacetIfNeeded(PARAM_PCI_DSS_40, PCI_DSS_40, options, aggregationHelper, esRequest, query.pciDss40().toArray());</span>
<span class="fc" id="L925">    addSecurityCategoryFacetIfNeeded(PARAM_OWASP_ASVS_40, OWASP_ASVS_40, options, aggregationHelper, esRequest, query.owaspAsvs40().toArray());</span>
<span class="fc" id="L926">    addSecurityCategoryFacetIfNeeded(PARAM_OWASP_MOBILE_TOP_10_2024, OWASP_MOBILE_TOP_10_2024, options, aggregationHelper, esRequest, query.owaspMobileTop10For2024().toArray());</span>
<span class="fc" id="L927">    addSecurityCategoryFacetIfNeeded(PARAM_OWASP_TOP_10, OWASP_TOP_10, options, aggregationHelper, esRequest, query.owaspTop10().toArray());</span>
<span class="fc" id="L928">    addSecurityCategoryFacetIfNeeded(PARAM_OWASP_TOP_10_2021, OWASP_TOP_10_2021, options, aggregationHelper, esRequest, query.owaspTop10For2021().toArray());</span>
<span class="fc" id="L929">    addSecurityCategoryFacetIfNeeded(PARAM_STIG_ASD_V5R3, STIG_ASD_V5R3, options, aggregationHelper, esRequest, query.stigAsdV5R3().toArray());</span>
<span class="fc" id="L930">    addSecurityCategoryFacetIfNeeded(PARAM_CASA, CASA, options, aggregationHelper, esRequest, query.casa().toArray());</span>
<span class="fc" id="L931">    addSecurityCategoryFacetIfNeeded(PARAM_SANS_TOP_25, SANS_TOP_25, options, aggregationHelper, esRequest, query.sansTop25().toArray());</span>
<span class="fc" id="L932">    addSecurityCategoryFacetIfNeeded(PARAM_CWE, CWE, options, aggregationHelper, esRequest, query.cwe().toArray());</span>
<span class="fc" id="L933">    addSecurityCategoryFacetIfNeeded(PARAM_SONARSOURCE_SECURITY, SONARSOURCE_SECURITY, options, aggregationHelper, esRequest, query.sonarsourceSecurity().toArray());</span>

<span class="fc" id="L935">    addSeverityFacetIfNeeded(options, aggregationHelper, esRequest);</span>
<span class="fc" id="L936">    addImpactSoftwareQualityFacetIfNeeded(options, query, aggregationHelper, esRequest);</span>
<span class="fc" id="L937">    addImpactSeverityFacetIfNeeded(options, query, aggregationHelper, esRequest);</span>
<span class="fc" id="L938">    addResolutionFacetIfNeeded(options, query, aggregationHelper, esRequest);</span>
<span class="fc" id="L939">    addAssigneesFacetIfNeeded(options, query, aggregationHelper, esRequest);</span>
<span class="fc" id="L940">    addCreatedAtFacetIfNeeded(options, query, aggregationHelper, queryFilters, esRequest);</span>
<span class="fc" id="L941">    addAssignedToMeFacetIfNeeded(options, aggregationHelper, esRequest);</span>
<span class="fc" id="L942">    addEffortTopAggregation(aggregationHelper, esRequest);</span>
<span class="fc" id="L943">  }</span>

  private static void addFacetIfNeeded(SearchOptions options, TopAggregationHelper aggregationHelper,
    SearchSourceBuilder esRequest, Facet facet, Object[] selectedValues) {
<span class="fc bfc" id="L947" title="All 2 branches covered.">    if (!options.getFacets().contains(facet.getName())) {</span>
<span class="fc" id="L948">      return;</span>
    }

<span class="fc" id="L951">    FilterAggregationBuilder topAggregation = aggregationHelper.buildTermTopAggregation(</span>
<span class="fc" id="L952">      facet.getName(), facet.getTopAggregationDef(), facet.getNumberOfTerms(),</span>
      NO_EXTRA_FILTER,
<span class="fc" id="L954">      t -&gt; aggregationHelper.getSubAggregationHelper().buildSelectedItemsAggregation(facet.getName(), facet.getTopAggregationDef(), selectedValues)</span>
<span class="fc" id="L955">        .ifPresent(t::subAggregation));</span>
<span class="fc" id="L956">    esRequest.aggregation(topAggregation);</span>
<span class="fc" id="L957">  }</span>

  private void addSecurityCategoryFacetIfNeeded(String param, Facet facet, SearchOptions options, TopAggregationHelper aggregationHelper,
    SearchSourceBuilder esRequest,
    Object[] selectedValues) {
<span class="fc bfc" id="L962" title="All 2 branches covered.">    if (!options.getFacets().contains(param)) {</span>
<span class="fc" id="L963">      return;</span>
    }

<span class="fc" id="L966">    AggregationBuilder aggregation = aggregationHelper.buildTermTopAggregation(</span>
<span class="fc" id="L967">      facet.getName(), facet.getTopAggregationDef(), facet.getNumberOfTerms(),</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">      filter -&gt; filter.must(isMQRMode() ? SECURITY_IMPACT_FILTER : termQuery(FIELD_ISSUE_TYPE, VULNERABILITY.name())),</span>
<span class="fc" id="L969">      t -&gt; aggregationHelper.getSubAggregationHelper().buildSelectedItemsAggregation(facet.getName(), facet.getTopAggregationDef(), selectedValues)</span>
<span class="fc" id="L970">        .ifPresent(t::subAggregation));</span>
<span class="fc" id="L971">    esRequest.aggregation(aggregation);</span>
<span class="fc" id="L972">  }</span>

  private static void addSeverityFacetIfNeeded(SearchOptions options, TopAggregationHelper aggregationHelper, SearchSourceBuilder esRequest) {
<span class="fc bfc" id="L975" title="All 2 branches covered.">    if (!options.getFacets().contains(PARAM_SEVERITIES)) {</span>
<span class="fc" id="L976">      return;</span>
    }

<span class="fc" id="L979">    AggregationBuilder aggregation = aggregationHelper.buildTermTopAggregation(</span>
<span class="fc" id="L980">      SEVERITIES.getName(), SEVERITIES.getTopAggregationDef(), SEVERITIES.getNumberOfTerms(),</span>
      // Ignore severity of Security HotSpots
<span class="fc" id="L982">      filter -&gt; filter.mustNot(termQuery(FIELD_ISSUE_TYPE, SECURITY_HOTSPOT.name())),</span>
      NO_OTHER_SUBAGGREGATION);
<span class="fc" id="L984">    esRequest.aggregation(aggregation);</span>
<span class="fc" id="L985">  }</span>

  private static void addImpactSoftwareQualityFacetIfNeeded(SearchOptions options, IssueQuery query, TopAggregationHelper aggregationHelper,
    SearchSourceBuilder esRequest) {
<span class="fc bfc" id="L989" title="All 2 branches covered.">    if (!options.getFacets().contains(PARAM_IMPACT_SOFTWARE_QUALITIES)) {</span>
<span class="fc" id="L990">      return;</span>
    }

<span class="fc" id="L993">    Function&lt;SoftwareQuality, BoolQueryBuilder&gt; mainQuery = softwareQuality -&gt; boolQuery()</span>
<span class="fc" id="L994">      .filter(termQuery(FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY, softwareQuality.name()));</span>

<span class="fc" id="L996">    FiltersAggregator.KeyedFilter[] keyedFilters = Arrays.stream(SoftwareQuality.values())</span>
<span class="fc" id="L997">      .map(softwareQuality -&gt; new FiltersAggregator.KeyedFilter(softwareQuality.name(),</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">        query.impactSeverities().isEmpty() ? mainQuery.apply(softwareQuality)</span>
<span class="fc" id="L999">          : mainQuery.apply(softwareQuality)</span>
<span class="fc" id="L1000">            .filter(termsQuery(FIELD_ISSUE_IMPACT_SEVERITY, query.impactSeverities()))))</span>
<span class="fc" id="L1001">      .toArray(FiltersAggregator.KeyedFilter[]::new);</span>

<span class="fc" id="L1003">    AggregationBuilder aggregation = aggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L1004">      IMPACT_SOFTWARE_QUALITY.getName(), IMPACT_SOFTWARE_QUALITY.getTopAggregationDef(),</span>
      NO_EXTRA_FILTER,
<span class="fc" id="L1006">      t -&gt; t.subAggregation(AggregationBuilders.nested(&quot;nested_&quot; + IMPACT_SOFTWARE_QUALITY.getName(), FIELD_ISSUE_IMPACTS)</span>
<span class="fc" id="L1007">        .subAggregation(filters(IMPACT_SOFTWARE_QUALITY.getName(), keyedFilters))));</span>

<span class="fc" id="L1009">    esRequest.aggregation(aggregation);</span>
<span class="fc" id="L1010">  }</span>

  private static void addImpactSeverityFacetIfNeeded(SearchOptions options, IssueQuery query, TopAggregationHelper aggregationHelper, SearchSourceBuilder esRequest) {
<span class="fc bfc" id="L1013" title="All 2 branches covered.">    if (!options.getFacets().contains(PARAM_IMPACT_SEVERITIES)) {</span>
<span class="fc" id="L1014">      return;</span>
    }

<span class="fc" id="L1017">    Function&lt;org.sonar.api.issue.impact.Severity, BoolQueryBuilder&gt; mainQuery = softwareQuality -&gt; boolQuery()</span>
<span class="fc" id="L1018">      .filter(termQuery(FIELD_ISSUE_IMPACT_SEVERITY, softwareQuality.name()));</span>

<span class="fc" id="L1020">    FiltersAggregator.KeyedFilter[] keyedFilters = Arrays.stream(org.sonar.api.issue.impact.Severity.values())</span>
<span class="fc" id="L1021">      .map(severity -&gt; new FiltersAggregator.KeyedFilter(severity.name(),</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">        query.impactSoftwareQualities().isEmpty() ? mainQuery.apply(severity)</span>
<span class="fc" id="L1023">          : mainQuery.apply(severity)</span>
<span class="fc" id="L1024">            .filter(termsQuery(FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY, query.impactSoftwareQualities()))))</span>
<span class="fc" id="L1025">      .toArray(FiltersAggregator.KeyedFilter[]::new);</span>

<span class="fc" id="L1027">    AggregationBuilder aggregation = aggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L1028">      IMPACT_SEVERITY.getName(), IMPACT_SEVERITY.getTopAggregationDef(),</span>
      NO_EXTRA_FILTER,
<span class="fc" id="L1030">      t -&gt; t.subAggregation(AggregationBuilders.nested(&quot;nested_&quot; + IMPACT_SEVERITY.getName(), FIELD_ISSUE_IMPACTS)</span>
<span class="fc" id="L1031">        .subAggregation(filters(IMPACT_SEVERITY.getName(), keyedFilters)</span>
          // we want to count the number of issues for each severity, so we need to reverse the nested aggregation
<span class="fc" id="L1033">          .subAggregation(reverseNested(&quot;reverse_nested_&quot; + IMPACT_SOFTWARE_QUALITY.getName())))));</span>
<span class="fc" id="L1034">    esRequest.aggregation(aggregation);</span>
<span class="fc" id="L1035">  }</span>

  private static void addResolutionFacetIfNeeded(SearchOptions options, IssueQuery query, TopAggregationHelper aggregationHelper, SearchSourceBuilder esRequest) {
<span class="fc bfc" id="L1038" title="All 2 branches covered.">    if (!options.getFacets().contains(PARAM_RESOLUTIONS)) {</span>
<span class="fc" id="L1039">      return;</span>
    }

<span class="fc" id="L1042">    AggregationBuilder aggregation = aggregationHelper.buildTermTopAggregation(</span>
<span class="fc" id="L1043">      RESOLUTIONS.getName(), RESOLUTIONS.getTopAggregationDef(), RESOLUTIONS.getNumberOfTerms(),</span>
      NO_EXTRA_FILTER,
      t -&gt;
      // add aggregation of type &quot;missing&quot; to return count of unresolved issues in the facet
<span class="fc" id="L1047">      t.subAggregation(</span>
<span class="fc" id="L1048">        addEffortAggregationIfNeeded(query, AggregationBuilders</span>
<span class="fc" id="L1049">          .missing(RESOLUTIONS.getName() + FACET_SUFFIX_MISSING)</span>
<span class="fc" id="L1050">          .field(RESOLUTIONS.getFieldName()))));</span>
<span class="fc" id="L1051">    esRequest.aggregation(aggregation);</span>
<span class="fc" id="L1052">  }</span>

  private static void addAssigneesFacetIfNeeded(SearchOptions options, IssueQuery query, TopAggregationHelper aggregationHelper, SearchSourceBuilder esRequest) {
<span class="fc bfc" id="L1055" title="All 2 branches covered.">    if (!options.getFacets().contains(PARAM_ASSIGNEES)) {</span>
<span class="fc" id="L1056">      return;</span>
    }

<span class="fc" id="L1059">    Consumer&lt;FilterAggregationBuilder&gt; assigneeAggregations = t -&gt; {</span>
      // optional second aggregation to return the issue count for selected assignees (if any)
<span class="fc" id="L1061">      Object[] assignees = query.assignees().toArray();</span>
<span class="fc" id="L1062">      aggregationHelper.getSubAggregationHelper().buildSelectedItemsAggregation(ASSIGNEES.getName(), ASSIGNEES.getTopAggregationDef(), assignees)</span>
<span class="fc" id="L1063">        .ifPresent(t::subAggregation);</span>

      // third aggregation to always return the count of unassigned in the assignee facet
<span class="fc" id="L1066">      t.subAggregation(addEffortAggregationIfNeeded(query, AggregationBuilders</span>
<span class="fc" id="L1067">        .missing(ASSIGNEES.getName() + FACET_SUFFIX_MISSING)</span>
<span class="fc" id="L1068">        .field(ASSIGNEES.getFieldName())));</span>
<span class="fc" id="L1069">    };</span>

<span class="fc" id="L1071">    AggregationBuilder aggregation = aggregationHelper.buildTermTopAggregation(</span>
<span class="fc" id="L1072">      ASSIGNEES.getName(), ASSIGNEES.getTopAggregationDef(), ASSIGNEES.getNumberOfTerms(),</span>
      NO_EXTRA_FILTER, assigneeAggregations);
<span class="fc" id="L1074">    esRequest.aggregation(aggregation);</span>
<span class="fc" id="L1075">  }</span>

  private void addCreatedAtFacetIfNeeded(SearchOptions options, IssueQuery query, TopAggregationHelper aggregationHelper, AllFilters allFilters,
    SearchSourceBuilder esRequest) {
<span class="fc bfc" id="L1079" title="All 2 branches covered.">    if (options.getFacets().contains(PARAM_CREATED_AT)) {</span>
<span class="fc" id="L1080">      getCreatedAtFacet(query, aggregationHelper, allFilters).ifPresent(esRequest::aggregation);</span>
    }
<span class="fc" id="L1082">  }</span>

  private Optional&lt;AggregationBuilder&gt; getCreatedAtFacet(IssueQuery query, TopAggregationHelper aggregationHelper, AllFilters allFilters) {
    long startTime;
    boolean startInclusive;
<span class="fc" id="L1087">    PeriodStart createdAfter = query.createdAfter();</span>
<span class="fc bfc" id="L1088" title="All 2 branches covered.">    if (createdAfter == null) {</span>
<span class="fc" id="L1089">      OptionalLong minDate = getMinCreatedAt(allFilters);</span>
<span class="fc bfc" id="L1090" title="All 2 branches covered.">      if (!minDate.isPresent()) {</span>
<span class="fc" id="L1091">        return Optional.empty();</span>
      }
<span class="fc" id="L1093">      startTime = minDate.getAsLong();</span>
<span class="fc" id="L1094">      startInclusive = true;</span>
<span class="fc" id="L1095">    } else {</span>
<span class="fc" id="L1096">      startTime = createdAfter.date().getTime();</span>
<span class="fc" id="L1097">      startInclusive = createdAfter.inclusive();</span>
    }
<span class="fc" id="L1099">    Date createdBefore = query.createdBefore();</span>
<span class="pc bpc" id="L1100" title="1 of 2 branches missed.">    long endTime = createdBefore == null ? system.now() : createdBefore.getTime();</span>

<span class="fc" id="L1102">    Duration timeSpan = new Duration(startTime, endTime);</span>
<span class="fc" id="L1103">    DateHistogramInterval bucketSize = computeDateHistogramBucketSize(timeSpan);</span>

<span class="fc" id="L1105">    FilterAggregationBuilder topAggregation = aggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L1106">      CREATED_AT.getName(),</span>
<span class="fc" id="L1107">      CREATED_AT.getTopAggregationDef(),</span>
      NO_EXTRA_FILTER,
      t -&gt; {
<span class="fc" id="L1110">        AggregationBuilder dateHistogram = AggregationBuilders.dateHistogram(CREATED_AT.getName())</span>
<span class="fc" id="L1111">          .field(CREATED_AT.getFieldName())</span>
<span class="fc" id="L1112">          .calendarInterval(bucketSize)</span>
<span class="fc" id="L1113">          .minDocCount(0L)</span>
<span class="fc" id="L1114">          .format(DateUtils.DATETIME_FORMAT)</span>
<span class="fc" id="L1115">          .timeZone(Optional.ofNullable(query.timeZone()).orElse(system.getDefaultTimeZone().toZoneId()))</span>
          // ES dateHistogram bounds are inclusive while createdBefore parameter is exclusive
<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">          .extendedBounds(new LongBounds(startInclusive ? startTime : (startTime + 1), endTime - 1L));</span>
<span class="fc" id="L1118">        addEffortAggregationIfNeeded(query, dateHistogram);</span>
<span class="fc" id="L1119">        t.subAggregation(dateHistogram);</span>
<span class="fc" id="L1120">      });</span>

<span class="fc" id="L1122">    return Optional.of(topAggregation);</span>
  }

  private static DateHistogramInterval computeDateHistogramBucketSize(Duration timeSpan) {
<span class="fc bfc" id="L1126" title="All 2 branches covered.">    if (timeSpan.isShorterThan(TWENTY_DAYS)) {</span>
<span class="fc" id="L1127">      return DateHistogramInterval.DAY;</span>
    }
<span class="fc bfc" id="L1129" title="All 2 branches covered.">    if (timeSpan.isShorterThan(TWENTY_WEEKS)) {</span>
<span class="fc" id="L1130">      return DateHistogramInterval.WEEK;</span>
    }
<span class="fc bfc" id="L1132" title="All 2 branches covered.">    if (timeSpan.isShorterThan(TWENTY_MONTHS)) {</span>
<span class="fc" id="L1133">      return DateHistogramInterval.MONTH;</span>
    }
<span class="fc" id="L1135">    return DateHistogramInterval.YEAR;</span>
  }

  private OptionalLong getMinCreatedAt(AllFilters filters) {
<span class="fc" id="L1139">    String facetNameAndField = CREATED_AT.getFieldName();</span>

<span class="fc" id="L1141">    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()</span>
<span class="fc" id="L1142">      .size(0);</span>
<span class="fc" id="L1143">    BoolQueryBuilder esFilter = boolQuery();</span>
<span class="fc" id="L1144">    filters.stream().filter(Objects::nonNull).forEach(esFilter::must);</span>
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">    if (esFilter.hasClauses()) {</span>
<span class="fc" id="L1146">      sourceBuilder.query(QueryBuilders.boolQuery().filter(esFilter));</span>
    }
<span class="fc" id="L1148">    sourceBuilder.aggregation(AggregationBuilders.min(facetNameAndField).field(facetNameAndField));</span>

<span class="fc" id="L1150">    SearchRequest request = EsClient.prepareSearch(TYPE_ISSUE.getMainType())</span>
<span class="fc" id="L1151">      .source(sourceBuilder);</span>

<span class="fc" id="L1153">    Min minValue = client.search(request).getAggregations().get(facetNameAndField);</span>
<span class="fc" id="L1154">    double actualValue = minValue.getValue();</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">    if (Double.isInfinite(actualValue)) {</span>
<span class="fc" id="L1156">      return OptionalLong.empty();</span>
    }
<span class="fc" id="L1158">    return OptionalLong.of((long) actualValue);</span>
  }

  private void addAssignedToMeFacetIfNeeded(SearchOptions options, TopAggregationHelper aggregationHelper, SearchSourceBuilder esRequest) {
<span class="fc" id="L1162">    String uuid = userSession.getUuid();</span>
<span class="pc bpc" id="L1163" title="1 of 4 branches missed.">    if (options.getFacets().contains(ASSIGNED_TO_ME.getName()) &amp;&amp; !StringUtils.isEmpty(uuid)) {</span>
<span class="fc" id="L1164">      AggregationBuilder aggregation = aggregationHelper.buildTopAggregation(</span>
<span class="fc" id="L1165">        ASSIGNED_TO_ME.getName(),</span>
<span class="fc" id="L1166">        ASSIGNED_TO_ME.getTopAggregationDef(),</span>
        NO_EXTRA_FILTER,
        t -&gt;
        // add sub-aggregation to return issue count for current user
<span class="fc" id="L1170">        aggregationHelper.getSubAggregationHelper()</span>
<span class="fc" id="L1171">          .buildSelectedItemsAggregation(ASSIGNED_TO_ME.getName(), ASSIGNED_TO_ME.getTopAggregationDef(), new String[] {uuid})</span>
<span class="fc" id="L1172">          .ifPresent(t::subAggregation));</span>
<span class="fc" id="L1173">      esRequest.aggregation(aggregation);</span>
    }
<span class="fc" id="L1175">  }</span>

  private static void addEffortTopAggregation(TopAggregationHelper aggregationHelper, SearchSourceBuilder esRequest) {
<span class="fc" id="L1178">    AggregationBuilder topAggregation = aggregationHelper.buildTopAggregation(</span>
      FACET_MODE_EFFORT,
      EFFORT_TOP_AGGREGATION,
      NO_EXTRA_FILTER,
<span class="fc" id="L1182">      t -&gt; t.subAggregation(EFFORT_AGGREGATION));</span>
<span class="fc" id="L1183">    esRequest.aggregation(topAggregation);</span>
<span class="fc" id="L1184">  }</span>

  public List&lt;String&gt; searchTags(IssueQuery query, @Nullable String textQuery, int size) {
<span class="fc" id="L1187">    Terms terms = listTermsMatching(FIELD_ISSUE_TAGS, query, textQuery, BucketOrder.key(true), size);</span>
<span class="fc" id="L1188">    return EsUtils.termsKeys(terms);</span>
  }

  public Map&lt;String, Long&gt; countTags(IssueQuery query, int maxNumberOfTags) {
<span class="fc" id="L1192">    Terms terms = listTermsMatching(FIELD_ISSUE_TAGS, query, null, BucketOrder.count(false), maxNumberOfTags);</span>
<span class="fc" id="L1193">    return EsUtils.termsToMap(terms);</span>
  }

  public List&lt;String&gt; searchAuthors(IssueQuery query, @Nullable String textQuery, int maxNumberOfAuthors) {
<span class="fc" id="L1197">    Terms terms = listTermsMatching(FIELD_ISSUE_AUTHOR_LOGIN, query, textQuery, BucketOrder.key(true), maxNumberOfAuthors);</span>
<span class="fc" id="L1198">    return EsUtils.termsKeys(terms);</span>
  }

  private Terms listTermsMatching(String fieldName, IssueQuery query, @Nullable String textQuery, BucketOrder termsOrder, int size) {
<span class="fc" id="L1202">    SearchRequest requestBuilder = EsClient.prepareSearch(TYPE_ISSUE.getMainType());</span>

<span class="fc" id="L1204">    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()</span>
      // Avoids returning search hits
<span class="fc" id="L1206">      .size(0);</span>
<span class="fc" id="L1207">    requestBuilder.source(sourceBuilder);</span>

<span class="fc" id="L1209">    sourceBuilder.query(boolQuery().must(QueryBuilders.matchAllQuery()).filter(createBoolFilter(query)));</span>

<span class="fc" id="L1211">    TermsAggregationBuilder aggreg = AggregationBuilders.terms(&quot;_ref&quot;)</span>
<span class="fc" id="L1212">      .field(fieldName)</span>
<span class="fc" id="L1213">      .size(size)</span>
<span class="fc" id="L1214">      .order(termsOrder)</span>
<span class="fc" id="L1215">      .minDocCount(1L);</span>
<span class="fc bfc" id="L1216" title="All 2 branches covered.">    if (textQuery != null) {</span>
<span class="fc" id="L1217">      aggreg.includeExclude(new IncludeExclude(format(SUBSTRING_MATCH_REGEXP, escapeSpecialRegexChars(textQuery)), null));</span>
    }

<span class="fc" id="L1220">    sourceBuilder.aggregation(aggreg);</span>

<span class="fc" id="L1222">    SearchResponse searchResponse = client.search(requestBuilder);</span>
<span class="fc" id="L1223">    return searchResponse.getAggregations().get(&quot;_ref&quot;);</span>
  }

  private BoolQueryBuilder createBoolFilter(IssueQuery query) {
<span class="fc" id="L1227">    BoolQueryBuilder boolQuery = boolQuery();</span>
<span class="fc" id="L1228">    createAllFilters(query).stream()</span>
<span class="fc" id="L1229">      .filter(Objects::nonNull)</span>
<span class="fc" id="L1230">      .forEach(boolQuery::must);</span>
<span class="fc" id="L1231">    return boolQuery;</span>
  }

  public List&lt;ProjectStatistics&gt; searchProjectStatistics(List&lt;String&gt; projectUuids, List&lt;Long&gt; froms, @Nullable String assigneeUuid) {
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">    checkState(projectUuids.size() == froms.size(),</span>
<span class="fc" id="L1236">      &quot;Expected same size for projectUuids (had size %s) and froms (had size %s)&quot;, projectUuids.size(), froms.size());</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">    if (projectUuids.isEmpty()) {</span>
<span class="fc" id="L1238">      return Collections.emptyList();</span>
    }
<span class="fc" id="L1240">    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder()</span>
<span class="fc" id="L1241">      .query(</span>
<span class="fc" id="L1242">        boolQuery()</span>
<span class="fc" id="L1243">          .mustNot(existsQuery(FIELD_ISSUE_RESOLUTION))</span>
<span class="fc" id="L1244">          .filter(termQuery(FIELD_ISSUE_ASSIGNEE_UUID, assigneeUuid))</span>
<span class="fc" id="L1245">          .mustNot(termQuery(FIELD_ISSUE_TYPE, SECURITY_HOTSPOT.name())))</span>
<span class="fc" id="L1246">      .size(0);</span>

<span class="fc" id="L1248">    IntStream.range(0, projectUuids.size()).forEach(i -&gt; {</span>
<span class="fc" id="L1249">      String projectUuid = projectUuids.get(i);</span>
<span class="fc" id="L1250">      long from = froms.get(i);</span>
<span class="fc" id="L1251">      sourceBuilder</span>
<span class="fc" id="L1252">        .aggregation(AggregationBuilders</span>
<span class="fc" id="L1253">          .filter(projectUuid, boolQuery()</span>
<span class="fc" id="L1254">            .filter(termQuery(FIELD_ISSUE_PROJECT_UUID, projectUuid))</span>
<span class="fc" id="L1255">            .filter(rangeQuery(FIELD_ISSUE_FUNC_CREATED_AT).gte(from)))</span>
<span class="fc" id="L1256">          .subAggregation(</span>
<span class="fc" id="L1257">            AggregationBuilders.terms(&quot;branchUuid&quot;).field(FIELD_ISSUE_BRANCH_UUID)</span>
<span class="fc" id="L1258">              .subAggregation(</span>
<span class="fc" id="L1259">                AggregationBuilders.count(AGG_COUNT).field(FIELD_ISSUE_KEY))</span>
<span class="fc" id="L1260">              .subAggregation(</span>
<span class="fc" id="L1261">                AggregationBuilders.max(&quot;maxFuncCreatedAt&quot;).field(FIELD_ISSUE_FUNC_CREATED_AT))));</span>
<span class="fc" id="L1262">    });</span>

<span class="fc" id="L1264">    SearchRequest requestBuilder = EsClient.prepareSearch(TYPE_ISSUE.getMainType());</span>

<span class="fc" id="L1266">    requestBuilder.source(sourceBuilder);</span>
<span class="fc" id="L1267">    SearchResponse response = client.search(requestBuilder);</span>
<span class="fc" id="L1268">    return response.getAggregations().asList().stream()</span>
<span class="fc" id="L1269">      .map(ParsedFilter.class::cast)</span>
<span class="fc" id="L1270">      .flatMap(projectBucket -&gt; ((ParsedStringTerms) projectBucket.getAggregations().get(&quot;branchUuid&quot;)).getBuckets().stream()</span>
<span class="fc" id="L1271">        .flatMap(branchBucket -&gt; {</span>
<span class="fc" id="L1272">          long count = ((ParsedValueCount) branchBucket.getAggregations().get(AGG_COUNT)).getValue();</span>
<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">          if (count &lt; 1L) {</span>
<span class="nc" id="L1274">            return Stream.empty();</span>
          }
<span class="fc" id="L1276">          long lastIssueDate = (long) ((ParsedMax) branchBucket.getAggregations().get(&quot;maxFuncCreatedAt&quot;)).getValue();</span>
<span class="fc" id="L1277">          return Stream.of(new ProjectStatistics(branchBucket.getKeyAsString(), count, lastIssueDate));</span>
        }))
<span class="fc" id="L1279">      .toList();</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getCweTop25Reports(String projectUuid, boolean isViewOrApp) {
<span class="fc" id="L1283">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="fc" id="L1284">    CWES_BY_CWE_TOP_25.keySet()</span>
<span class="fc" id="L1285">      .forEach(cweYear -&gt; request.aggregation(</span>
<span class="fc" id="L1286">        newSecurityReportSubAggregations(</span>
<span class="fc" id="L1287">          AggregationBuilders.filter(cweYear, boolQuery().filter(existsQuery(FIELD_ISSUE_CWE))),</span>
          true,
<span class="fc" id="L1289">          CWES_BY_CWE_TOP_25.get(cweYear))));</span>
<span class="fc" id="L1290">    List&lt;SecurityStandardCategoryStatistics&gt; result = search(request, true, null);</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">    for (SecurityStandardCategoryStatistics cweReport : result) {</span>
<span class="fc" id="L1292">      Set&lt;String&gt; foundRules = cweReport.getChildren().stream()</span>
<span class="fc" id="L1293">        .map(SecurityStandardCategoryStatistics::getCategory)</span>
<span class="fc" id="L1294">        .collect(Collectors.toSet());</span>
<span class="fc" id="L1295">      CWES_BY_CWE_TOP_25.get(cweReport.getCategory()).stream()</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">        .filter(rule -&gt; !foundRules.contains(rule))</span>
<span class="fc" id="L1297">        .forEach(rule -&gt; cweReport.getChildren().add(emptyCweStatistics(rule)));</span>
<span class="fc" id="L1298">    }</span>
<span class="fc" id="L1299">    return result;</span>
  }

  private static SecurityStandardCategoryStatistics emptyCweStatistics(String rule) {
<span class="fc" id="L1303">    return new SecurityStandardCategoryStatistics(rule, 0, OptionalInt.of(1), 0, 0, 1, null, null, Map.of());</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getSonarSourceReport(String projectUuid, boolean isViewOrApp, boolean includeCwe) {
<span class="nc" id="L1307">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="nc" id="L1308">    Arrays.stream(SQCategory.values())</span>
<span class="nc" id="L1309">      .forEach(sonarsourceCategory -&gt; request.aggregation(</span>
<span class="nc" id="L1310">        newSecurityReportSubAggregations(</span>
<span class="nc" id="L1311">          AggregationBuilders.filter(sonarsourceCategory.getKey(), boolQuery().filter(termQuery(FIELD_ISSUE_SQ_SECURITY_CATEGORY, sonarsourceCategory.getKey()))),</span>
          includeCwe,
<span class="nc" id="L1313">          SecurityStandards.CWES_BY_SQ_CATEGORY.get(sonarsourceCategory))));</span>
<span class="nc" id="L1314">    return search(request, includeCwe, null);</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getPciDssReport(String projectUuid, boolean isViewOrApp, PciDssVersion version) {
<span class="fc" id="L1318">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="fc" id="L1319">    Arrays.stream(PciDss.values())</span>
<span class="fc" id="L1320">      .forEach(pciDss -&gt; request.aggregation(</span>
<span class="fc" id="L1321">        newSecurityReportSubAggregations(</span>
<span class="fc" id="L1322">          AggregationBuilders.filter(pciDss.category(), boolQuery().filter(prefixQuery(version.prefix(), pciDss.category() + &quot;.&quot;))), version.prefix())));</span>
<span class="fc" id="L1323">    return searchWithDistribution(request, version.label(), null);</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getOwaspAsvsReport(String projectUuid, boolean isViewOrApp, RulesDefinition.OwaspAsvsVersion version, Integer level) {
<span class="fc" id="L1327">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="fc" id="L1328">    Arrays.stream(SecurityStandards.OwaspAsvs.values())</span>
<span class="fc" id="L1329">      .forEach(owaspAsvs -&gt; request.aggregation(</span>
<span class="fc" id="L1330">        newSecurityReportSubAggregations(</span>
<span class="fc" id="L1331">          AggregationBuilders.filter(</span>
<span class="fc" id="L1332">            owaspAsvs.category(),</span>
<span class="fc" id="L1333">            boolQuery().filter(termsQuery(version.prefix(), SecurityStandards.getRequirementsForCategoryAndLevel(owaspAsvs, level)))),</span>
<span class="fc" id="L1334">          version.prefix())));</span>
<span class="fc" id="L1335">    return searchWithDistribution(request, version.label(), level);</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getOwaspAsvsReportGroupedByLevel(String projectUuid, boolean isViewOrApp, RulesDefinition.OwaspAsvsVersion version, int level) {
<span class="fc" id="L1339">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="fc" id="L1340">    request.aggregation(</span>
<span class="fc" id="L1341">      newSecurityReportSubAggregations(</span>
<span class="fc" id="L1342">        AggregationBuilders.filter(</span>
          &quot;l&quot; + level,
<span class="fc" id="L1344">          boolQuery().filter(termsQuery(version.prefix(), SecurityStandards.OWASP_ASVS_REQUIREMENTS_BY_LEVEL.get(version).get(level)))),</span>
<span class="fc" id="L1345">        version.prefix()));</span>
<span class="fc" id="L1346">    return searchWithLevelDistribution(request, version.label(), Integer.toString(level));</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getOwaspMobileTop10Report(String projectUuid, boolean isViewOrApp, boolean includeCwe, OwaspMobileTop10Version version) {
<span class="fc" id="L1350">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="fc" id="L1351">    IntStream.rangeClosed(1, 10).mapToObj(i -&gt; &quot;m&quot; + i)</span>
<span class="fc" id="L1352">      .forEach(owaspMobileCategory -&gt; request.aggregation(</span>
<span class="fc" id="L1353">        newSecurityReportSubAggregations(</span>
<span class="fc" id="L1354">          AggregationBuilders.filter(owaspMobileCategory, boolQuery().filter(termQuery(version.prefix(), owaspMobileCategory))),</span>
          includeCwe,
          null)));
<span class="fc" id="L1357">    return search(request, includeCwe, version.label());</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getOwaspTop10Report(String projectUuid, boolean isViewOrApp, boolean includeCwe, OwaspTop10Version version) {
<span class="fc" id="L1361">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="fc" id="L1362">    IntStream.rangeClosed(1, 10).mapToObj(i -&gt; &quot;a&quot; + i)</span>
<span class="fc" id="L1363">      .forEach(owaspCategory -&gt; request.aggregation(</span>
<span class="fc" id="L1364">        newSecurityReportSubAggregations(</span>
<span class="fc" id="L1365">          AggregationBuilders.filter(owaspCategory, boolQuery().filter(termQuery(version.prefix(), owaspCategory))),</span>
          includeCwe,
          null)));
<span class="fc" id="L1368">    return search(request, includeCwe, version.label());</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getStigReport(String projectUuid, boolean isViewOrApp, RulesDefinition.StigVersion stigVersion) {
<span class="fc" id="L1372">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="fc" id="L1373">    Arrays.stream(StigSupportedRequirement.values())</span>
<span class="fc" id="L1374">      .forEach(stigSupportedRequirement -&gt; request.aggregation(</span>
<span class="fc" id="L1375">        newSecurityReportSubAggregations(</span>
<span class="fc" id="L1376">          AggregationBuilders.filter(stigSupportedRequirement.getRequirement(), boolQuery().filter(termQuery(stigVersion.prefix(), stigSupportedRequirement.getRequirement()))),</span>
          false, null)));
<span class="fc" id="L1378">    return search(request, false, stigVersion.label());</span>
  }

  public List&lt;SecurityStandardCategoryStatistics&gt; getCasaReport(String projectUuid, boolean isViewOrApp) {
<span class="fc" id="L1382">    SearchSourceBuilder request = prepareNonClosedVulnerabilitiesAndHotspotSearch(projectUuid, isViewOrApp);</span>
<span class="fc" id="L1383">    IntStream.range(1, 15)</span>
<span class="fc" id="L1384">      .forEach(casaTopCategory -&gt; request.aggregation(</span>
<span class="fc" id="L1385">        newSecurityReportSubAggregations(</span>
<span class="fc" id="L1386">          AggregationBuilders.filter(String.valueOf(casaTopCategory), boolQuery().filter(prefixQuery(FIELD_ISSUE_CASA, casaTopCategory + &quot;.&quot;))), FIELD_ISSUE_CASA)));</span>
<span class="fc" id="L1387">    return searchWithDistribution(request, null, null);</span>
  }

  private List&lt;SecurityStandardCategoryStatistics&gt; searchWithLevelDistribution(SearchSourceBuilder sourceBuilder, String version, @Nullable String level) {
<span class="fc" id="L1391">    return getSearchResponse(sourceBuilder)</span>
<span class="fc" id="L1392">      .getAggregations().asList().stream()</span>
<span class="fc" id="L1393">      .map(c -&gt; processSecurityReportIssueSearchResultsWithLevelDistribution((ParsedFilter) c, version, level))</span>
<span class="fc" id="L1394">      .toList();</span>
  }

  private List&lt;SecurityStandardCategoryStatistics&gt; searchWithDistribution(SearchSourceBuilder sourceBuilder, @Nullable String version, @Nullable Integer level) {
<span class="fc" id="L1398">    return getSearchResponse(sourceBuilder)</span>
<span class="fc" id="L1399">      .getAggregations().asList().stream()</span>
<span class="fc" id="L1400">      .map(c -&gt; processSecurityReportIssueSearchResultsWithDistribution((ParsedFilter) c, version, level))</span>
<span class="fc" id="L1401">      .toList();</span>
  }

  private List&lt;SecurityStandardCategoryStatistics&gt; search(SearchSourceBuilder sourceBuilder, boolean includeDistribution, @Nullable String version) {
<span class="fc" id="L1405">    return getSearchResponse(sourceBuilder)</span>
<span class="fc" id="L1406">      .getAggregations().asList().stream()</span>
<span class="fc" id="L1407">      .map(c -&gt; processSecurityReportIssueSearchResults((ParsedFilter) c, includeDistribution, version))</span>
<span class="fc" id="L1408">      .toList();</span>
  }

  private SearchResponse getSearchResponse(SearchSourceBuilder sourceBuilder) {
<span class="fc" id="L1412">    SearchRequest request = EsClient.prepareSearch(TYPE_ISSUE.getMainType())</span>
<span class="fc" id="L1413">      .source(sourceBuilder);</span>
<span class="fc" id="L1414">    return client.search(request);</span>
  }

  private SecurityStandardCategoryStatistics processSecurityReportIssueSearchResultsWithDistribution(ParsedFilter categoryFilter,
    @Nullable String version,
    @Nullable Integer level) {
<span class="fc" id="L1420">    var list = ((ParsedStringTerms) categoryFilter.getAggregations().get(AGG_DISTRIBUTION)).getBuckets();</span>
<span class="fc" id="L1421">    List&lt;SecurityStandardCategoryStatistics&gt; children = list.stream()</span>
<span class="fc" id="L1422">      .filter(categoryBucket -&gt; StringUtils.startsWith(categoryBucket.getKeyAsString(), categoryFilter.getName() + &quot;.&quot;))</span>
<span class="pc bpc" id="L1423" title="1 of 4 branches missed.">      .filter(categoryBucket -&gt; level == null || OWASP_ASVS_40_REQUIREMENTS_BY_LEVEL.get(level).contains(categoryBucket.getKeyAsString()))</span>
<span class="fc" id="L1424">      .map(categoryBucket -&gt; processSecurityReportCategorySearchResults(categoryBucket, categoryBucket.getKeyAsString(), null, null))</span>
<span class="fc" id="L1425">      .toList();</span>

<span class="fc" id="L1427">    return processSecurityReportCategorySearchResults(categoryFilter, categoryFilter.getName(), children, version);</span>
  }

  private SecurityStandardCategoryStatistics processSecurityReportIssueSearchResultsWithLevelDistribution(ParsedFilter categoryFilter,
    String version, String level) {
<span class="fc" id="L1432">    var list = ((ParsedStringTerms) categoryFilter.getAggregations().get(AGG_DISTRIBUTION)).getBuckets();</span>
<span class="fc" id="L1433">    List&lt;SecurityStandardCategoryStatistics&gt; children = list.stream()</span>
<span class="fc" id="L1434">      .filter(categoryBucket -&gt; OWASP_ASVS_40_REQUIREMENTS_BY_LEVEL.get(Integer.parseInt(level)).contains(categoryBucket.getKeyAsString()))</span>
<span class="fc" id="L1435">      .map(categoryBucket -&gt; processSecurityReportCategorySearchResults(categoryBucket, categoryBucket.getKeyAsString(), null, null))</span>
<span class="fc" id="L1436">      .toList();</span>

<span class="fc" id="L1438">    return processSecurityReportCategorySearchResults(categoryFilter, categoryFilter.getName(), children, version);</span>
  }

  private SecurityStandardCategoryStatistics processSecurityReportIssueSearchResults(ParsedFilter categoryBucket,
    boolean includeDistribution, String version) {
<span class="fc" id="L1443">    List&lt;SecurityStandardCategoryStatistics&gt; children = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">    if (includeDistribution) {</span>
<span class="fc" id="L1445">      Stream&lt;? extends Terms.Bucket&gt; stream = ((ParsedStringTerms) categoryBucket.getAggregations().get(AGG_DISTRIBUTION)).getBuckets().stream();</span>
<span class="fc" id="L1446">      children = stream.map(cweBucket -&gt; processSecurityReportCategorySearchResults(cweBucket, cweBucket.getKeyAsString(), null, null))</span>
<span class="fc" id="L1447">        .collect(toCollection(ArrayList&lt;SecurityStandardCategoryStatistics&gt;::new));</span>
    }

<span class="fc" id="L1450">    return processSecurityReportCategorySearchResults(categoryBucket, categoryBucket.getName(), children, version);</span>
  }

  private SecurityStandardCategoryStatistics processSecurityReportCategorySearchResults(HasAggregations categoryBucket, String categoryName,
    @Nullable List&lt;SecurityStandardCategoryStatistics&gt; children, @Nullable String version) {

<span class="fc" id="L1456">    Aggregation severitiesAggregations =</span>
<span class="fc" id="L1457">      ((ParsedFilter) categoryBucket.getAggregations().get(AGG_VULNERABILITIES)).getAggregations().get(AGG_SEVERITIES);</span>

<span class="fc" id="L1459">    SeverityAggregationDetails severityAggregationDetails = getSeverityDetails(severitiesAggregations);</span>
<span class="fc" id="L1460">    long vulnerabilities = severityAggregationDetails.getCount();</span>
    // Worst severity having at least one issue
<span class="fc" id="L1462">    OptionalInt severityRating = severityAggregationDetails.getRating();</span>
<span class="fc" id="L1463">    Map&lt;String, Long&gt; severityDistribution = severityAggregationDetails.getDistribution();</span>

<span class="fc" id="L1465">    long toReviewSecurityHotspots = ((ParsedValueCount) ((ParsedFilter) categoryBucket.getAggregations().get(AGG_TO_REVIEW_SECURITY_HOTSPOTS)).getAggregations().get(AGG_COUNT))</span>
<span class="fc" id="L1466">      .getValue();</span>
<span class="fc" id="L1467">    long reviewedSecurityHotspots = ((ParsedValueCount) ((ParsedFilter) categoryBucket.getAggregations().get(AGG_REVIEWED_SECURITY_HOTSPOTS)).getAggregations().get(AGG_COUNT))</span>
<span class="fc" id="L1468">      .getValue();</span>

<span class="fc" id="L1470">    Optional&lt;Double&gt; percent = computePercent(toReviewSecurityHotspots, reviewedSecurityHotspots);</span>
<span class="fc" id="L1471">    Integer securityReviewRating = computeRating(percent.orElse(null)).getIndex();</span>

<span class="fc" id="L1473">    return new SecurityStandardCategoryStatistics(categoryName, vulnerabilities, severityRating, toReviewSecurityHotspots,</span>
      reviewedSecurityHotspots, securityReviewRating, children, version, severityDistribution);
  }

  private SeverityAggregationDetails getSeverityDetails(Aggregation severitiesAggregations) {
    List&lt;? extends Terms.Bucket&gt; severityBuckets;
    long vulnerabilities;
    OptionalInt severityRating;
<span class="fc bfc" id="L1481" title="All 2 branches covered.">    if (isMQRMode()) {</span>
<span class="fc" id="L1482">      severityBuckets =</span>
<span class="fc" id="L1483">        ((ParsedStringTerms) ((ParsedFilter) ((ParsedNested) severitiesAggregations).getAggregations().get(ISSUES_WITH_SECURITY_IMPACT)).getAggregations().get(AGG_IMPACT_SEVERITIES)).getBuckets();</span>
<span class="fc" id="L1484">      vulnerabilities =</span>
<span class="fc" id="L1485">        severityBuckets.stream().mapToLong(b -&gt; ((ParsedValueCount) b.getAggregations().get(AGG_COUNT)).getValue()).sum();</span>
      // Worst severity having at least one issue
<span class="fc" id="L1487">      severityRating = severityBuckets.stream()</span>
<span class="pc bpc" id="L1488" title="1 of 2 branches missed.">        .filter(b -&gt; ((ParsedValueCount) b.getAggregations().get(AGG_COUNT)).getValue() != 0)</span>
<span class="fc" id="L1489">        .mapToInt(b -&gt; org.sonar.api.issue.impact.Severity.valueOf(b.getKeyAsString()).ordinal() + 1)</span>
<span class="fc" id="L1490">        .max();</span>
    } else {
<span class="fc" id="L1492">      severityBuckets = ((ParsedStringTerms) severitiesAggregations).getBuckets();</span>
<span class="fc" id="L1493">      vulnerabilities =</span>
<span class="fc" id="L1494">        severityBuckets.stream().mapToLong(b -&gt; ((ParsedValueCount) b.getAggregations().get(AGG_COUNT)).getValue()).sum();</span>
      // Worst severity having at least one issue
<span class="fc" id="L1496">      severityRating = severityBuckets.stream()</span>
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">        .filter(b -&gt; ((ParsedValueCount) b.getAggregations().get(AGG_COUNT)).getValue() != 0)</span>
<span class="fc" id="L1498">        .mapToInt(b -&gt; Severity.ALL.indexOf(b.getKeyAsString()) + 1)</span>
<span class="fc" id="L1499">        .max();</span>
    }
<span class="fc" id="L1501">    Map&lt;String, Long&gt; severityDistribution = severityBuckets.stream()</span>
<span class="fc" id="L1502">      .collect(Collectors.toMap(</span>
<span class="fc" id="L1503">        e -&gt; e.getKeyAsString().toLowerCase(Locale.US),</span>
        MultiBucketsAggregation.Bucket::getDocCount
      ));
<span class="fc" id="L1506">    return new SeverityAggregationDetails(vulnerabilities, severityRating, severityDistribution);</span>
  }
  
  private AggregationBuilder newSecurityReportSubAggregations(AggregationBuilder categoriesAggs, String securityStandardVersionPrefix) {
<span class="fc" id="L1510">    AggregationBuilder aggregationBuilder = addSecurityReportIssueCountAggregations(categoriesAggs);</span>
<span class="fc" id="L1511">    final TermsAggregationBuilder distributionAggregation = AggregationBuilders.terms(AGG_DISTRIBUTION)</span>
<span class="fc" id="L1512">      .field(securityStandardVersionPrefix)</span>
      // 100 should be enough to display all the requirements per category. If not, the UI will be broken anyway
<span class="fc" id="L1514">      .size(MAX_FACET_SIZE);</span>
<span class="fc" id="L1515">    categoriesAggs.subAggregation(addSecurityReportIssueCountAggregations(distributionAggregation));</span>

<span class="fc" id="L1517">    return aggregationBuilder;</span>
  }

  private AggregationBuilder newSecurityReportSubAggregations(AggregationBuilder categoriesAggs, boolean includeCwe,
    @Nullable Collection&lt;String&gt; cwesInCategory) {
<span class="fc" id="L1522">    AggregationBuilder aggregationBuilder = addSecurityReportIssueCountAggregations(categoriesAggs);</span>
<span class="fc bfc" id="L1523" title="All 2 branches covered.">    if (includeCwe) {</span>
<span class="fc" id="L1524">      final TermsAggregationBuilder cwesAgg = AggregationBuilders.terms(AGG_DISTRIBUTION)</span>
<span class="fc" id="L1525">        .field(FIELD_ISSUE_CWE)</span>
        // 100 should be enough to display all CWEs. If not, the UI will be broken anyway
<span class="fc" id="L1527">        .size(MAX_FACET_SIZE);</span>
<span class="fc bfc" id="L1528" title="All 2 branches covered.">      if (cwesInCategory != null) {</span>
<span class="fc" id="L1529">        cwesAgg.includeExclude(new IncludeExclude(cwesInCategory.toArray(new String[0]), new String[0]));</span>
      }
<span class="fc" id="L1531">      categoriesAggs.subAggregation(addSecurityReportIssueCountAggregations(cwesAgg));</span>
    }
<span class="fc" id="L1533">    return aggregationBuilder;</span>
  }

  private AggregationBuilder addSecurityReportIssueCountAggregations(AggregationBuilder categoryAggs) {
<span class="fc" id="L1537">    return categoryAggs</span>
<span class="fc" id="L1538">      .subAggregation(</span>
<span class="fc" id="L1539">        AggregationBuilders.filter(AGG_VULNERABILITIES, getNonResolvedIssuesOrNonResolvedSecurityImpactQueryBuilderBasedOnMode())</span>
<span class="fc" id="L1540">          .subAggregation(getAggregationBuilderBasedOnMode()))</span>
<span class="fc" id="L1541">      .subAggregation(AggregationBuilders.filter(AGG_TO_REVIEW_SECURITY_HOTSPOTS, TO_REVIEW_HOTSPOTS_FILTER)</span>
<span class="fc" id="L1542">        .subAggregation(</span>
<span class="fc" id="L1543">          AggregationBuilders.count(AGG_COUNT).field(FIELD_ISSUE_KEY)))</span>
<span class="fc" id="L1544">      .subAggregation(AggregationBuilders.filter(AGG_REVIEWED_SECURITY_HOTSPOTS, REVIEWED_HOTSPOTS_FILTER)</span>
<span class="fc" id="L1545">        .subAggregation(</span>
<span class="fc" id="L1546">          AggregationBuilders.count(AGG_COUNT).field(FIELD_ISSUE_KEY)));</span>
  }

  private AggregationBuilder getAggregationBuilderBasedOnMode() {
<span class="fc bfc" id="L1550" title="All 2 branches covered.">    if (isMQRMode()) {</span>
<span class="fc" id="L1551">      return AggregationBuilders.nested(AGG_SEVERITIES, FIELD_ISSUE_IMPACTS)</span>
<span class="fc" id="L1552">        .subAggregation(AggregationBuilders.filter(ISSUES_WITH_SECURITY_IMPACT,</span>
<span class="fc" id="L1553">            boolQuery().filter(termsQuery(FIELD_ISSUE_IMPACT_SOFTWARE_QUALITY, SoftwareQuality.SECURITY.name())))</span>
<span class="fc" id="L1554">        .subAggregation(AggregationBuilders.terms(AGG_IMPACT_SEVERITIES).field(FIELD_ISSUE_IMPACT_SEVERITY)</span>
<span class="fc" id="L1555">          .subAggregation(</span>
<span class="fc" id="L1556">            AggregationBuilders.count(AGG_COUNT).field(FIELD_ISSUE_IMPACT_SEVERITY))));</span>

    } else {
<span class="fc" id="L1559">      return AggregationBuilders.terms(AGG_SEVERITIES).field(FIELD_ISSUE_SEVERITY)</span>
<span class="fc" id="L1560">        .subAggregation(</span>
<span class="fc" id="L1561">          AggregationBuilders.count(AGG_COUNT).field(FIELD_ISSUE_KEY));</span>

    }
  }
  private QueryBuilder getNonResolvedIssuesOrNonResolvedSecurityImpactQueryBuilderBasedOnMode() {
<span class="fc bfc" id="L1566" title="All 2 branches covered.">    return isMQRMode() ? NON_RESOLVED_SECURITY_IMPACT_FILTER : NON_RESOLVED_VULNERABILITIES_FILTER;</span>
  }

  private SearchSourceBuilder prepareNonClosedVulnerabilitiesAndHotspotSearch(String projectUuid, boolean isViewOrApp) {
<span class="fc" id="L1570">    BoolQueryBuilder componentFilter = boolQuery();</span>
<span class="fc bfc" id="L1571" title="All 2 branches covered.">    if (isViewOrApp) {</span>
<span class="fc" id="L1572">      componentFilter.filter(QueryBuilders.termsLookupQuery(FIELD_ISSUE_BRANCH_UUID,</span>
        new TermsLookup(
<span class="fc" id="L1574">          TYPE_VIEW.getIndex().getName(),</span>
          projectUuid,
          ViewIndexDefinition.FIELD_PROJECTS)));
    } else {
<span class="fc" id="L1578">      componentFilter.filter(termQuery(FIELD_ISSUE_BRANCH_UUID, projectUuid));</span>
    }

<span class="fc" id="L1581">    SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();</span>
<span class="fc" id="L1582">    return sourceBuilder</span>
<span class="fc" id="L1583">      .query(</span>
        componentFilter
<span class="fc" id="L1585">          .should(getNonResolvedIssuesOrNonResolvedSecurityImpactQueryBuilderBasedOnMode())</span>
<span class="fc" id="L1586">          .should(TO_REVIEW_HOTSPOTS_FILTER)</span>
<span class="fc" id="L1587">          .should(REVIEWED_HOTSPOTS_FILTER)</span>
<span class="fc" id="L1588">          .minimumShouldMatch(1))</span>
<span class="fc" id="L1589">      .size(0);</span>
  }

  private boolean isMQRMode() {
<span class="fc" id="L1593">    return config.getBoolean(MULTI_QUALITY_MODE_ENABLED).orElse(MULTI_QUALITY_MODE_DEFAULT_VALUE);</span>
  }


  private static class SeverityAggregationDetails {
    private long count;
    private OptionalInt rating;
    private Map&lt;String, Long&gt; distribution;

<span class="fc" id="L1602">    public SeverityAggregationDetails(long count, OptionalInt rating, Map&lt;String, Long&gt; distribution) {</span>
<span class="fc" id="L1603">      this.count = count;</span>
<span class="fc" id="L1604">      this.rating = rating;</span>
<span class="fc" id="L1605">      this.distribution = distribution;</span>
<span class="fc" id="L1606">    }</span>

    public long getCount() {
<span class="fc" id="L1609">      return count;</span>
    }

    public OptionalInt getRating() {
<span class="fc" id="L1613">      return rating;</span>
    }

    public Map&lt;String, Long&gt; getDistribution() {
<span class="fc" id="L1617">      return distribution;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>