<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IssueCounter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.ce.task.projectanalysis.issue</a> &gt; <span class="el_source">IssueCounter.java</span></div><h1>IssueCounter.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.ce.task.projectanalysis.issue;

import com.google.common.collect.EnumMultiset;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Multiset;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
import org.sonar.api.issue.IssueStatus;
import org.sonar.api.issue.impact.Severity;
import org.sonar.api.issue.impact.SoftwareQuality;
import org.sonar.core.rule.RuleType;
import org.sonar.ce.task.projectanalysis.component.Component;
import org.sonar.ce.task.projectanalysis.measure.Measure;
import org.sonar.ce.task.projectanalysis.measure.MeasureRepository;
import org.sonar.ce.task.projectanalysis.metric.Metric;
import org.sonar.ce.task.projectanalysis.metric.MetricRepository;
import org.sonar.core.issue.DefaultIssue;
import org.sonar.core.metric.SoftwareQualitiesMetrics;
import org.sonar.server.measure.ImpactMeasureBuilder;

import static org.sonar.api.issue.Issue.STATUS_CONFIRMED;
import static org.sonar.api.issue.Issue.STATUS_OPEN;
import static org.sonar.api.issue.Issue.STATUS_REOPENED;
import static org.sonar.api.measures.CoreMetrics.ACCEPTED_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.BLOCKER_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.BUGS_KEY;
import static org.sonar.api.measures.CoreMetrics.CODE_SMELLS_KEY;
import static org.sonar.api.measures.CoreMetrics.CONFIRMED_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.CRITICAL_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.FALSE_POSITIVE_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.HIGH_IMPACT_ACCEPTED_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.INFO_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.MAINTAINABILITY_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.MAJOR_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.MINOR_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_ACCEPTED_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_BLOCKER_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_BUGS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_CODE_SMELLS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_CRITICAL_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_INFO_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_MAINTAINABILITY_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_MAJOR_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_MINOR_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_RELIABILITY_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_SECURITY_HOTSPOTS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_SECURITY_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.NEW_VULNERABILITIES_KEY;
import static org.sonar.api.measures.CoreMetrics.OPEN_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.RELIABILITY_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.REOPENED_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.SECURITY_HOTSPOTS_KEY;
import static org.sonar.api.measures.CoreMetrics.SECURITY_ISSUES_KEY;
import static org.sonar.api.measures.CoreMetrics.VIOLATIONS_KEY;
import static org.sonar.api.measures.CoreMetrics.VULNERABILITIES_KEY;
import static org.sonar.api.rule.Severity.BLOCKER;
import static org.sonar.api.rule.Severity.CRITICAL;
import static org.sonar.api.rule.Severity.INFO;
import static org.sonar.api.rule.Severity.MAJOR;
import static org.sonar.api.rule.Severity.MINOR;
import static org.sonar.core.rule.RuleType.BUG;
import static org.sonar.core.rule.RuleType.CODE_SMELL;
import static org.sonar.core.rule.RuleType.SECURITY_HOTSPOT;
import static org.sonar.core.rule.RuleType.VULNERABILITY;

/**
 * For each component, computes the measures related to number of issues:
 * &lt;ul&gt;
 * &lt;li&gt;issues per status (open, reopen, confirmed)&lt;/li&gt;
 * &lt;li&gt;issues per resolution (unresolved, false-positives, won't fix)&lt;/li&gt;
 * &lt;li&gt;issues per severity (from info to blocker)&lt;/li&gt;
 * &lt;li&gt;issues per impact severity (from info to blocker)&lt;/li&gt;
 * &lt;li&gt;issues per type (code smell, bug, vulnerability, security hotspots)&lt;/li&gt;
 * &lt;li&gt;issues per impact&lt;/li&gt;
 * &lt;/ul&gt;
 * For each value, the variation on configured periods is also computed.
 */
public class IssueCounter extends IssueVisitor {

<span class="fc" id="L102">  private static final Map&lt;String, String&gt; SEVERITY_TO_METRIC_KEY = ImmutableMap.of(</span>
    BLOCKER, BLOCKER_VIOLATIONS_KEY,
    CRITICAL, CRITICAL_VIOLATIONS_KEY,
    MAJOR, MAJOR_VIOLATIONS_KEY,
    MINOR, MINOR_VIOLATIONS_KEY,
    INFO, INFO_VIOLATIONS_KEY);

<span class="fc" id="L109">  private static final Map&lt;String, String&gt; SEVERITY_TO_NEW_METRIC_KEY = ImmutableMap.of(</span>
    BLOCKER, NEW_BLOCKER_VIOLATIONS_KEY,
    CRITICAL, NEW_CRITICAL_VIOLATIONS_KEY,
    MAJOR, NEW_MAJOR_VIOLATIONS_KEY,
    MINOR, NEW_MINOR_VIOLATIONS_KEY,
    INFO, NEW_INFO_VIOLATIONS_KEY);

<span class="fc" id="L116">  private static final Map&lt;Severity, String&gt; IMPACT_SEVERITY_TO_METRIC_KEY = ImmutableMap.of(</span>
    Severity.BLOCKER, SoftwareQualitiesMetrics.SOFTWARE_QUALITY_BLOCKER_ISSUES_KEY,
    Severity.HIGH, SoftwareQualitiesMetrics.SOFTWARE_QUALITY_HIGH_ISSUES_KEY,
    Severity.MEDIUM, SoftwareQualitiesMetrics.SOFTWARE_QUALITY_MEDIUM_ISSUES_KEY,
    Severity.LOW, SoftwareQualitiesMetrics.SOFTWARE_QUALITY_LOW_ISSUES_KEY,
    Severity.INFO, SoftwareQualitiesMetrics.SOFTWARE_QUALITY_INFO_ISSUES_KEY);

<span class="fc" id="L123">  private static final Map&lt;Severity, String&gt; IMPACT_SEVERITY_TO_NEW_METRIC_KEY = ImmutableMap.of(</span>
    Severity.BLOCKER, SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_BLOCKER_ISSUES_KEY,
    Severity.HIGH, SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_HIGH_ISSUES_KEY,
    Severity.MEDIUM, SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_MEDIUM_ISSUES_KEY,
    Severity.LOW, SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_LOW_ISSUES_KEY,
    Severity.INFO, SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_INFO_ISSUES_KEY);

<span class="fc" id="L130">  static final Map&lt;String, String&gt; IMPACT_TO_JSON_METRIC_KEY = Map.of(</span>
<span class="fc" id="L131">    SoftwareQuality.SECURITY.name(), SECURITY_ISSUES_KEY,</span>
<span class="fc" id="L132">    SoftwareQuality.RELIABILITY.name(), RELIABILITY_ISSUES_KEY,</span>
<span class="fc" id="L133">    SoftwareQuality.MAINTAINABILITY.name(), MAINTAINABILITY_ISSUES_KEY);</span>

<span class="fc" id="L135">  static final Map&lt;String, String&gt; IMPACT_TO_NEW_JSON_METRIC_KEY = Map.of(</span>
<span class="fc" id="L136">    SoftwareQuality.SECURITY.name(), NEW_SECURITY_ISSUES_KEY,</span>
<span class="fc" id="L137">    SoftwareQuality.RELIABILITY.name(), NEW_RELIABILITY_ISSUES_KEY,</span>
<span class="fc" id="L138">    SoftwareQuality.MAINTAINABILITY.name(), NEW_MAINTAINABILITY_ISSUES_KEY);</span>

<span class="fc" id="L140">  static final Map&lt;String, String&gt; IMPACT_TO_METRIC_KEY = Map.of(</span>
<span class="fc" id="L141">    SoftwareQuality.SECURITY.name(), SoftwareQualitiesMetrics.SOFTWARE_QUALITY_SECURITY_ISSUES_KEY,</span>
<span class="fc" id="L142">    SoftwareQuality.RELIABILITY.name(), SoftwareQualitiesMetrics.SOFTWARE_QUALITY_RELIABILITY_ISSUES_KEY,</span>
<span class="fc" id="L143">    SoftwareQuality.MAINTAINABILITY.name(), SoftwareQualitiesMetrics.SOFTWARE_QUALITY_MAINTAINABILITY_ISSUES_KEY);</span>

<span class="fc" id="L145">  static final Map&lt;String, String&gt; IMPACT_TO_NEW_METRIC_KEY = Map.of(</span>
<span class="fc" id="L146">    SoftwareQuality.SECURITY.name(), SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_SECURITY_ISSUES_KEY,</span>
<span class="fc" id="L147">    SoftwareQuality.RELIABILITY.name(), SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_RELIABILITY_ISSUES_KEY,</span>
<span class="fc" id="L148">    SoftwareQuality.MAINTAINABILITY.name(), SoftwareQualitiesMetrics.NEW_SOFTWARE_QUALITY_MAINTAINABILITY_ISSUES_KEY);</span>

<span class="fc" id="L150">  private static final Map&lt;RuleType, String&gt; TYPE_TO_METRIC_KEY = ImmutableMap.&lt;RuleType, String&gt;builder()</span>
<span class="fc" id="L151">    .put(CODE_SMELL, CODE_SMELLS_KEY)</span>
<span class="fc" id="L152">    .put(BUG, BUGS_KEY)</span>
<span class="fc" id="L153">    .put(VULNERABILITY, VULNERABILITIES_KEY)</span>
<span class="fc" id="L154">    .put(SECURITY_HOTSPOT, SECURITY_HOTSPOTS_KEY)</span>
<span class="fc" id="L155">    .build();</span>
<span class="fc" id="L156">  private static final Map&lt;RuleType, String&gt; TYPE_TO_NEW_METRIC_KEY = ImmutableMap.&lt;RuleType, String&gt;builder()</span>
<span class="fc" id="L157">    .put(CODE_SMELL, NEW_CODE_SMELLS_KEY)</span>
<span class="fc" id="L158">    .put(BUG, NEW_BUGS_KEY)</span>
<span class="fc" id="L159">    .put(VULNERABILITY, NEW_VULNERABILITIES_KEY)</span>
<span class="fc" id="L160">    .put(SECURITY_HOTSPOT, NEW_SECURITY_HOTSPOTS_KEY)</span>
<span class="fc" id="L161">    .build();</span>

  private final MetricRepository metricRepository;
  private final MeasureRepository measureRepository;
  private final NewIssueClassifier newIssueClassifier;
<span class="fc" id="L166">  private final Map&lt;String, Counters&gt; countersByComponentUuid = new HashMap&lt;&gt;();</span>

  private Counters currentCounters;

<span class="fc" id="L170">  public IssueCounter(MetricRepository metricRepository, MeasureRepository measureRepository, NewIssueClassifier newIssueClassifier) {</span>
<span class="fc" id="L171">    this.metricRepository = metricRepository;</span>
<span class="fc" id="L172">    this.measureRepository = measureRepository;</span>
<span class="fc" id="L173">    this.newIssueClassifier = newIssueClassifier;</span>
<span class="fc" id="L174">  }</span>

  @Override
  public void beforeComponent(Component component) {
<span class="fc" id="L178">    currentCounters = new Counters();</span>
<span class="fc" id="L179">    countersByComponentUuid.put(component.getUuid(), currentCounters);</span>

    // aggregate children counters
<span class="fc bfc" id="L182" title="All 2 branches covered.">    for (Component child : component.getChildren()) {</span>
<span class="fc" id="L183">      Counters childCounters = countersByComponentUuid.remove(child.getUuid());</span>
<span class="fc" id="L184">      currentCounters.add(childCounters);</span>
<span class="fc" id="L185">    }</span>
<span class="fc" id="L186">  }</span>

  @Override
  public void onIssue(Component component, DefaultIssue issue) {
<span class="fc" id="L190">    currentCounters.add(issue);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">    if (newIssueClassifier.isNew(component, issue)) {</span>
<span class="fc" id="L192">      currentCounters.addOnPeriod(issue);</span>
    }
<span class="fc" id="L194">  }</span>

  @Override
  public void afterComponent(Component component) {
<span class="fc" id="L198">    addMeasuresBySeverity(component);</span>
<span class="fc" id="L199">    addMeasuresByImpactSeverity(component);</span>
<span class="fc" id="L200">    addMeasuresByStatus(component);</span>
<span class="fc" id="L201">    addMeasuresByType(component);</span>
<span class="fc" id="L202">    addMeasuresByImpact(component);</span>
<span class="fc" id="L203">    addNewMeasures(component);</span>
<span class="fc" id="L204">    currentCounters = null;</span>
<span class="fc" id="L205">  }</span>

  private void addMeasuresBySeverity(Component component) {
<span class="fc" id="L208">    addMeasures(component, SEVERITY_TO_METRIC_KEY, currentCounters.counter().severityBag);</span>
<span class="fc" id="L209">  }</span>

  private void addMeasuresByImpactSeverity(Component component) {
<span class="fc" id="L212">    addMeasures(component, IMPACT_SEVERITY_TO_METRIC_KEY, currentCounters.counter().impactSeverityBag);</span>
<span class="fc" id="L213">  }</span>

  private void addMeasuresByStatus(Component component) {
<span class="fc" id="L216">    addMeasure(component, VIOLATIONS_KEY, currentCounters.counter().unresolved);</span>
<span class="fc" id="L217">    addMeasure(component, OPEN_ISSUES_KEY, currentCounters.counter().open);</span>
<span class="fc" id="L218">    addMeasure(component, REOPENED_ISSUES_KEY, currentCounters.counter().reopened);</span>
<span class="fc" id="L219">    addMeasure(component, CONFIRMED_ISSUES_KEY, currentCounters.counter().confirmed);</span>
<span class="fc" id="L220">    addMeasure(component, FALSE_POSITIVE_ISSUES_KEY, currentCounters.counter().falsePositives);</span>
<span class="fc" id="L221">    addMeasure(component, ACCEPTED_ISSUES_KEY, currentCounters.counter().accepted);</span>
<span class="fc" id="L222">    addMeasure(component, HIGH_IMPACT_ACCEPTED_ISSUES_KEY, currentCounters.counter().highImpactAccepted);</span>
<span class="fc" id="L223">  }</span>

  private void addMeasuresByImpact(Component component) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">    for (Map.Entry&lt;String, Map&lt;String, Long&gt;&gt; impactEntry : currentCounters.counter().impactsBag.entrySet()) {</span>
<span class="fc" id="L227">      String json = ImpactMeasureBuilder.fromMap(impactEntry.getValue()).buildAsString();</span>
<span class="fc" id="L228">      addMeasure(component, IMPACT_TO_JSON_METRIC_KEY.get(impactEntry.getKey()), json);</span>
<span class="fc" id="L229">      addMeasure(component, IMPACT_TO_METRIC_KEY.get(impactEntry.getKey()),</span>
<span class="fc" id="L230">        impactEntry.getValue().get(ImpactMeasureBuilder.TOTAL_KEY).intValue());</span>
<span class="fc" id="L231">    }</span>
<span class="fc" id="L232">  }</span>

  private void addMeasuresByType(Component component) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">    for (Map.Entry&lt;RuleType, String&gt; entry : TYPE_TO_METRIC_KEY.entrySet()) {</span>
<span class="fc" id="L236">      addMeasure(component, entry.getValue(), currentCounters.counter().typeBag.count(entry.getKey()));</span>
<span class="fc" id="L237">    }</span>
<span class="fc" id="L238">  }</span>

  private void addMeasure(Component component, String metricKey, int value) {
<span class="fc" id="L241">    Metric metric = metricRepository.getByKey(metricKey);</span>
<span class="fc" id="L242">    measureRepository.add(component, metric, Measure.newMeasureBuilder().create(value));</span>
<span class="fc" id="L243">  }</span>

  private void addMeasure(Component component, String metricKey, String data) {
<span class="fc" id="L246">    Metric metric = metricRepository.getByKey(metricKey);</span>
<span class="fc" id="L247">    measureRepository.add(component, metric, Measure.newMeasureBuilder().create(data));</span>
<span class="fc" id="L248">  }</span>

  private &lt;M&gt; void addMeasures(Component component, Map&lt;M, String&gt; metrics, Multiset&lt;M&gt; countPerMetric) {
<span class="fc bfc" id="L251" title="All 2 branches covered.">    for (Map.Entry&lt;M, String&gt; entry : metrics.entrySet()) {</span>
<span class="fc" id="L252">      M entryKey = entry.getKey();</span>
<span class="fc" id="L253">      String metricKey = entry.getValue();</span>
<span class="fc" id="L254">      addMeasure(component, metricKey, countPerMetric.count(entryKey));</span>
<span class="fc" id="L255">    }</span>
<span class="fc" id="L256">  }</span>


  private void addNewMeasures(Component component) {
<span class="fc bfc" id="L260" title="All 2 branches covered.">    if (!newIssueClassifier.isEnabled()) {</span>
<span class="fc" id="L261">      return;</span>
    }
<span class="fc" id="L263">    int unresolved = currentCounters.counterForPeriod().unresolved;</span>
<span class="fc" id="L264">    measureRepository.add(component, metricRepository.getByKey(NEW_VIOLATIONS_KEY), Measure.newMeasureBuilder()</span>
<span class="fc" id="L265">      .create(unresolved));</span>

<span class="fc" id="L267">    addMeasures(component, SEVERITY_TO_NEW_METRIC_KEY, currentCounters.counterForPeriod().severityBag);</span>

<span class="fc" id="L269">    addMeasures(component, IMPACT_SEVERITY_TO_NEW_METRIC_KEY, currentCounters.counterForPeriod().impactSeverityBag);</span>

<span class="fc" id="L271">    addMeasures(component, TYPE_TO_NEW_METRIC_KEY, currentCounters.counterForPeriod().typeBag);</span>

<span class="fc bfc" id="L273" title="All 2 branches covered.">    for (Map.Entry&lt;String, Map&lt;String, Long&gt;&gt; impactEntry : currentCounters.counterForPeriod().impactsBag.entrySet()) {</span>
<span class="fc" id="L274">      String json = ImpactMeasureBuilder.fromMap(impactEntry.getValue()).buildAsString();</span>
<span class="fc" id="L275">      addMeasure(component, IMPACT_TO_NEW_JSON_METRIC_KEY.get(impactEntry.getKey()), json);</span>
<span class="fc" id="L276">      addMeasure(component, IMPACT_TO_NEW_METRIC_KEY.get(impactEntry.getKey()),</span>
<span class="fc" id="L277">        impactEntry.getValue().get(ImpactMeasureBuilder.TOTAL_KEY).intValue());</span>
<span class="fc" id="L278">    }</span>

<span class="fc" id="L280">    addMeasure(component, NEW_ACCEPTED_ISSUES_KEY, currentCounters.counterForPeriod().accepted);</span>
<span class="fc" id="L281">  }</span>

  /**
   * Count issues by status, resolutions, rules, impacts and severities
   */
  private static class Counter {
<span class="fc" id="L287">    private int unresolved = 0;</span>
<span class="fc" id="L288">    private int open = 0;</span>
<span class="fc" id="L289">    private int reopened = 0;</span>
<span class="fc" id="L290">    private int confirmed = 0;</span>
<span class="fc" id="L291">    private int falsePositives = 0;</span>
<span class="fc" id="L292">    private int accepted = 0;</span>
<span class="fc" id="L293">    private int highImpactAccepted = 0;</span>
<span class="fc" id="L294">    private final Multiset&lt;String&gt; severityBag = HashMultiset.create();</span>
<span class="fc" id="L295">    private final Multiset&lt;Severity&gt; impactSeverityBag = HashMultiset.create();</span>
    /**
     * This map contains the number of issues per software quality along with their distribution based on (new) severity.
     */
<span class="fc" id="L299">    private final Map&lt;String, Map&lt;String, Long&gt;&gt; impactsBag = new HashMap&lt;&gt;();</span>
<span class="fc" id="L300">    private final EnumMultiset&lt;RuleType&gt; typeBag = EnumMultiset.create(RuleType.class);</span>

<span class="fc" id="L302">    public Counter() {</span>
<span class="fc" id="L303">      initImpactsBag();</span>
<span class="fc" id="L304">    }</span>

    private void initImpactsBag() {
<span class="fc bfc" id="L307" title="All 2 branches covered.">      for (SoftwareQuality quality : SoftwareQuality.values()) {</span>
<span class="fc" id="L308">        impactsBag.put(quality.name(), ImpactMeasureBuilder.createEmpty().buildAsMap());</span>
      }
<span class="fc" id="L310">    }</span>

    void add(Counter counter) {
<span class="fc" id="L313">      unresolved += counter.unresolved;</span>
<span class="fc" id="L314">      open += counter.open;</span>
<span class="fc" id="L315">      reopened += counter.reopened;</span>
<span class="fc" id="L316">      confirmed += counter.confirmed;</span>
<span class="fc" id="L317">      falsePositives += counter.falsePositives;</span>
<span class="fc" id="L318">      accepted += counter.accepted;</span>
<span class="fc" id="L319">      highImpactAccepted += counter.highImpactAccepted;</span>
<span class="fc" id="L320">      severityBag.addAll(counter.severityBag);</span>
<span class="fc" id="L321">      impactSeverityBag.addAll(counter.impactSeverityBag);</span>
<span class="fc" id="L322">      typeBag.addAll(counter.typeBag);</span>

      // Add impacts
<span class="fc bfc" id="L325" title="All 2 branches covered.">      for (Map.Entry&lt;String, Map&lt;String, Long&gt;&gt; impactEntry : counter.impactsBag.entrySet()) {</span>
<span class="fc" id="L326">        Map&lt;String, Long&gt; severityMap = impactsBag.get(impactEntry.getKey());</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (Map.Entry&lt;String, Long&gt; severityEntry : impactEntry.getValue().entrySet()) {</span>
<span class="fc" id="L328">          severityMap.compute(severityEntry.getKey(), (key, value) -&gt; value + severityEntry.getValue());</span>
<span class="fc" id="L329">        }</span>
<span class="fc" id="L330">      }</span>
<span class="fc" id="L331">    }</span>

    void add(DefaultIssue issue) {
<span class="fc bfc" id="L334" title="All 2 branches covered.">      if (issue.type() == SECURITY_HOTSPOT) {</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (issue.resolution() == null) {</span>
<span class="fc" id="L336">          typeBag.add(SECURITY_HOTSPOT);</span>
        }
<span class="fc" id="L338">        return;</span>
      }
<span class="fc bfc" id="L340" title="All 2 branches covered.">      if (issue.resolution() == null) {</span>
<span class="fc" id="L341">        unresolved++;</span>
<span class="fc" id="L342">        typeBag.add(issue.type());</span>
<span class="fc" id="L343">        severityBag.add(issue.severity());</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">      } else if (IssueStatus.FALSE_POSITIVE.equals(issue.issueStatus())) {</span>
<span class="fc" id="L345">        falsePositives++;</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">      } else if (IssueStatus.ACCEPTED.equals(issue.issueStatus())) {</span>
<span class="fc" id="L347">        accepted++;</span>
<span class="fc bfc" id="L348" title="All 6 branches covered.">        if (issue.impacts().values().stream().anyMatch(severity -&gt; severity == Severity.HIGH || severity == Severity.BLOCKER)) {</span>
<span class="fc" id="L349">          highImpactAccepted++;</span>
        }
      }
<span class="pc bpc" id="L352" title="1 of 4 branches missed.">      switch (issue.status()) {</span>
        case STATUS_OPEN:
<span class="fc" id="L354">          open++;</span>
<span class="fc" id="L355">          break;</span>
        case STATUS_REOPENED:
<span class="nc" id="L357">          reopened++;</span>
<span class="nc" id="L358">          break;</span>
        case STATUS_CONFIRMED:
<span class="fc" id="L360">          confirmed++;</span>
<span class="fc" id="L361">          break;</span>
        default:
          // Other statuses are ignored
      }
<span class="fc" id="L365">      countIssueImpacts(issue);</span>
<span class="fc" id="L366">    }</span>

    private void countIssueImpacts(DefaultIssue issue) {
<span class="fc bfc" id="L369" title="All 4 branches covered.">      if (IssueStatus.OPEN == issue.issueStatus() || IssueStatus.CONFIRMED == issue.issueStatus()) {</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        for (Map.Entry&lt;SoftwareQuality, Severity&gt; impact : issue.impacts().entrySet()) {</span>
<span class="fc" id="L371">          impactsBag.compute(impact.getKey().name(), (key, value) -&gt; {</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">            value.compute(impact.getValue().name(), (severity, count) -&gt; count == null ? 1 : count + 1);</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            value.compute(ImpactMeasureBuilder.TOTAL_KEY, (total, count) -&gt; count == null ? 1 : count + 1);</span>
<span class="fc" id="L374">            return value;</span>
          });
<span class="fc" id="L376">        }</span>
<span class="fc" id="L377">        issue.impacts().values().stream().distinct().forEach(impactSeverityBag::add);</span>
      }
<span class="fc" id="L379">    }</span>
  }

  /**
   * List of {@link Counter} for regular value and period.
   */
<span class="fc" id="L385">  private static class Counters {</span>
<span class="fc" id="L386">    private final Counter counter = new Counter();</span>
<span class="fc" id="L387">    private final Counter counterForPeriod = new Counter();</span>

    void add(@Nullable Counters other) {
<span class="fc bfc" id="L390" title="All 2 branches covered.">      if (other != null) {</span>
<span class="fc" id="L391">        counter.add(other.counter);</span>
<span class="fc" id="L392">        counterForPeriod.add(other.counterForPeriod);</span>
      }
<span class="fc" id="L394">    }</span>

    void addOnPeriod(DefaultIssue issue) {
<span class="fc" id="L397">      counterForPeriod.add(issue);</span>
<span class="fc" id="L398">    }</span>

    void add(DefaultIssue issue) {
<span class="fc" id="L401">      counter.add(issue);</span>
<span class="fc" id="L402">    }</span>

    Counter counter() {
<span class="fc" id="L405">      return counter;</span>
    }

    Counter counterForPeriod() {
<span class="fc" id="L409">      return counterForPeriod;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>