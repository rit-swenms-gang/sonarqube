<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RuleActivationContext.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.qualityprofile.builtin</a> &gt; <span class="el_source">RuleActivationContext.java</span></div><h1>RuleActivationContext.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.qualityprofile.builtin;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.annotation.CheckForNull;
import org.sonar.api.rule.RuleKey;
import org.sonar.db.qualityprofile.ActiveRuleDto;
import org.sonar.db.qualityprofile.ActiveRuleKey;
import org.sonar.db.qualityprofile.ActiveRuleParamDto;
import org.sonar.db.qualityprofile.QProfileDto;
import org.sonar.db.qualityprofile.RulesProfileDto;
import org.sonar.db.rule.RuleDto;
import org.sonar.db.rule.RuleParamDto;
import org.sonar.server.qualityprofile.RuleActivation;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static java.util.Collections.emptySet;
import static java.util.Objects.requireNonNull;
import static org.sonar.core.util.stream.MoreCollectors.index;
import static org.sonar.server.exceptions.BadRequestException.checkRequest;

/**
 * Cache of the data required to activate/deactivate
 * multiple rules on a Quality profile, including
 * the rule definitions, the rule parameters, the tree
 * of profiles hierarchy and its related active rules.
 */
public class RuleActivationContext {

  private final long date;

  private Set&lt;String&gt; previousBuiltinActiveRuleUuids;

  // The profile that is initially targeted by the operation
  private final RulesProfileDto baseRulesProfile;

<span class="fc" id="L64">  private final Map&lt;String, QProfileDto&gt; profilesByUuid = new HashMap&lt;&gt;();</span>
<span class="fc" id="L65">  private final ListMultimap&lt;String, QProfileDto&gt; profilesByParentUuid = ArrayListMultimap.create();</span>

  // The rules/active rules involved in the group of activations/de-activations
<span class="fc" id="L68">  private final Map&lt;String, RuleWrapper&gt; rulesByUuid = new HashMap&lt;&gt;();</span>
<span class="fc" id="L69">  private final Map&lt;ActiveRuleKey, ActiveRuleWrapper&gt; activeRulesByKey = new HashMap&lt;&gt;();</span>

  // Cursors used to move in the rules and in the tree of profiles.

  private RulesProfileDto currentRulesProfile;
  // Cardinality is zero-to-many when cursor is on a built-in rules profile,
  // otherwise it's always one, and only one (cursor on descendants or on non-built-in base profile).
  private Collection&lt;QProfileDto&gt; currentProfiles;
  private RuleWrapper currentRule;
  private ActiveRuleWrapper currentActiveRule;
  private ActiveRuleWrapper currentParentActiveRule;

<span class="fc" id="L81">  private boolean descendantsLoaded = false;</span>
  private final DescendantProfilesSupplier descendantProfilesSupplier;

<span class="fc" id="L84">  private RuleActivationContext(Builder builder) {</span>
<span class="fc" id="L85">    this.date = builder.date;</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">    this.previousBuiltinActiveRuleUuids = builder.previousBuiltinActiveRuleUuids == null ? emptySet() :</span>
<span class="fc" id="L87">      builder.previousBuiltinActiveRuleUuids;</span>
<span class="fc" id="L88">    this.descendantProfilesSupplier = builder.descendantProfilesSupplier;</span>

<span class="fc" id="L90">    ListMultimap&lt;String, RuleParamDto&gt; paramsByRuleId = builder.ruleParams.stream().collect(index(RuleParamDto::getRuleUuid));</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">    for (RuleDto rule : builder.rules) {</span>
<span class="fc" id="L92">      RuleWrapper wrapper = new RuleWrapper(rule, paramsByRuleId.get(rule.getUuid()));</span>
<span class="fc" id="L93">      rulesByUuid.put(rule.getUuid(), wrapper);</span>
<span class="fc" id="L94">    }</span>

<span class="fc" id="L96">    this.baseRulesProfile = builder.baseRulesProfile;</span>
<span class="fc" id="L97">    register(builder.profiles);</span>
<span class="fc" id="L98">    register(builder.activeRules, builder.activeRuleParams);</span>
<span class="fc" id="L99">  }</span>

  private void register(Collection&lt;QProfileDto&gt; profiles) {
<span class="fc bfc" id="L102" title="All 2 branches covered.">    for (QProfileDto profile : profiles) {</span>
<span class="fc" id="L103">      profilesByUuid.put(profile.getKee(), profile);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">      if (profile.getParentKee() != null) {</span>
<span class="fc" id="L105">        profilesByParentUuid.put(profile.getParentKee(), profile);</span>
      }
<span class="fc" id="L107">    }</span>
<span class="fc" id="L108">  }</span>

  private void register(Collection&lt;ActiveRuleDto&gt; activeRules, Collection&lt;ActiveRuleParamDto&gt; activeRuleParams) {
<span class="fc" id="L111">    ListMultimap&lt;String, ActiveRuleParamDto&gt; paramsByActiveRuleUuid = activeRuleParams.stream().collect(index(ActiveRuleParamDto::getActiveRuleUuid));</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">    for (ActiveRuleDto activeRule : activeRules) {</span>
<span class="fc" id="L113">      register(activeRule, paramsByActiveRuleUuid.get(activeRule.getUuid()));</span>
<span class="fc" id="L114">    }</span>
<span class="fc" id="L115">  }</span>

  void register(ActiveRuleDto activeRule, Collection&lt;ActiveRuleParamDto&gt; activeRuleParams) {
<span class="fc" id="L118">    ActiveRuleWrapper wrapper = new ActiveRuleWrapper(activeRule, activeRuleParams);</span>
<span class="fc" id="L119">    this.activeRulesByKey.put(activeRule.getKey(), wrapper);</span>
<span class="fc" id="L120">  }</span>

  long getDate() {
<span class="fc" id="L123">    return date;</span>
  }

  /**
   * The rule currently selected.
   */
  public RuleWrapper getRule() {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">    checkState(currentRule != null, &quot;Rule has not been set yet&quot;);</span>
<span class="fc" id="L131">    return currentRule;</span>
  }

  @CheckForNull
  String getRequestedParamValue(RuleActivation request, String key) {
<span class="fc bfc" id="L136" title="All 2 branches covered.">    if (currentRule.rule.isCustomRule()) {</span>
<span class="fc" id="L137">      return null;</span>
    }
<span class="fc" id="L139">    return request.getParameter(key);</span>
  }

  boolean hasRequestedParamValue(RuleActivation request, String key) {
<span class="fc" id="L143">    return request.hasParameter(key);</span>
  }

  /**
   * The rules profile being selected.
   */
  RulesProfileDto getRulesProfile() {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">    checkState(currentRulesProfile != null, &quot;Rule profile has not been set yet&quot;);</span>
<span class="fc" id="L151">    return currentRulesProfile;</span>
  }

  /**
   * The active rule related to the selected profile and rule.
   * @return null if the selected rule is not activated on the selected profile.
   * @see #getRulesProfile()
   * @see #getRule()
   */
  @CheckForNull
  ActiveRuleWrapper getActiveRule() {
<span class="fc" id="L162">    return currentActiveRule;</span>
  }

  /**
   * The active rule related to the rule and the parent of the selected profile.
   * @return null if the selected rule is not activated on the parent profile.
   * @see #getRule()
   */
  @CheckForNull
  ActiveRuleWrapper getParentActiveRule() {
<span class="fc" id="L172">    return currentParentActiveRule;</span>
  }

  /**
   * Whether the profile cursor is on the base profile or not.
   */
  boolean isCascading() {
<span class="pc bpc" id="L179" title="1 of 4 branches missed.">    return currentRulesProfile != null &amp;&amp; !currentRulesProfile.getUuid().equals(baseRulesProfile.getUuid());</span>
  }

  /**
   * The profiles being selected. Can be zero or many if {@link #getRulesProfile()} is built-in.
   * Else the collection always contains a single profile.
   */
  Collection&lt;QProfileDto&gt; getProfiles() {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">    checkState(currentProfiles != null, &quot;Profiles have not been set yet&quot;);</span>
<span class="fc" id="L188">    return currentProfiles;</span>
  }

  /**
   * The children of {@link #getProfiles()}
   */
  Collection&lt;QProfileDto&gt; getChildProfiles() {
<span class="fc" id="L195">    loadDescendants();</span>
<span class="fc" id="L196">    return getProfiles().stream()</span>
<span class="fc" id="L197">      .flatMap(p -&gt; profilesByParentUuid.get(p.getKee()).stream())</span>
<span class="fc" id="L198">      .toList();</span>
  }

  private void loadDescendants() {
<span class="fc bfc" id="L202" title="All 2 branches covered.">    if (descendantsLoaded) {</span>
<span class="fc" id="L203">      return;</span>
    }
<span class="fc" id="L205">    Collection&lt;QProfileDto&gt; baseProfiles = profilesByUuid.values().stream()</span>
<span class="fc" id="L206">      .filter(p -&gt; p.getRulesProfileUuid().equals(baseRulesProfile.getUuid()))</span>
<span class="fc" id="L207">      .toList();</span>
<span class="fc" id="L208">    DescendantProfilesSupplier.Result result = descendantProfilesSupplier.get(baseProfiles, rulesByUuid.keySet());</span>
<span class="fc" id="L209">    register(result.profiles());</span>
<span class="fc" id="L210">    register(result.activeRules(), result.activeRuleParams());</span>
<span class="fc" id="L211">    descendantsLoaded = true;</span>
<span class="fc" id="L212">  }</span>

  /**
   * Move the cursor to the given rule and back to the base profile.
   */
  public void reset(String ruleUuid) {
<span class="fc" id="L218">    doSwitch(this.baseRulesProfile, ruleUuid);</span>
<span class="fc" id="L219">  }</span>

  /**
   * Moves cursor to a child profile
   */
  void selectChild(QProfileDto to) {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">    checkState(!to.isBuiltIn());</span>
<span class="pc" id="L226">    QProfileDto qp = requireNonNull(this.profilesByUuid.get(to.getKee()), () -&gt; &quot;No profile with uuid &quot; + to.getKee());</span>

<span class="fc" id="L228">    RulesProfileDto ruleProfile = RulesProfileDto.from(qp);</span>
<span class="fc" id="L229">    doSwitch(ruleProfile, getRule().get().getUuid());</span>
<span class="fc" id="L230">  }</span>

  private void doSwitch(RulesProfileDto ruleProfile, String ruleUuid) {
<span class="fc" id="L233">    this.currentRule = rulesByUuid.get(ruleUuid);</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">    checkRequest(this.currentRule != null, &quot;Rule with UUID %s not found&quot;, ruleUuid);</span>
<span class="fc" id="L235">    RuleKey ruleKey = currentRule.get().getKey();</span>

<span class="fc" id="L237">    this.currentRulesProfile = ruleProfile;</span>
<span class="fc" id="L238">    this.currentProfiles = profilesByUuid.values().stream()</span>
<span class="fc" id="L239">      .filter(p -&gt; p.getRulesProfileUuid().equals(ruleProfile.getUuid()))</span>
<span class="fc" id="L240">      .toList();</span>
<span class="fc" id="L241">    this.currentActiveRule = this.activeRulesByKey.get(ActiveRuleKey.of(ruleProfile, ruleKey));</span>
<span class="fc" id="L242">    this.currentParentActiveRule = this.currentProfiles.stream()</span>
<span class="fc" id="L243">      .map(QProfileDto::getParentKee)</span>
<span class="fc" id="L244">      .filter(Objects::nonNull)</span>
<span class="fc" id="L245">      .map(profilesByUuid::get)</span>
<span class="fc" id="L246">      .filter(Objects::nonNull)</span>
<span class="fc" id="L247">      .findFirst()</span>
<span class="fc" id="L248">      .map(profile -&gt; activeRulesByKey.get(ActiveRuleKey.of(profile, ruleKey)))</span>
<span class="fc" id="L249">      .orElse(null);</span>
<span class="fc" id="L250">  }</span>

  public Set&lt;String&gt; getPreviousBuiltinActiveRuleUuids() {
<span class="fc" id="L253">    return previousBuiltinActiveRuleUuids;</span>
  }

<span class="fc" id="L256">  static final class Builder {</span>
<span class="fc" id="L257">    private long date = System.currentTimeMillis();</span>
    private Set&lt;String&gt; previousBuiltinActiveRuleUuids;
    private RulesProfileDto baseRulesProfile;
    private Collection&lt;RuleDto&gt; rules;
    private Collection&lt;RuleParamDto&gt; ruleParams;
    private Collection&lt;QProfileDto&gt; profiles;
    private Collection&lt;ActiveRuleDto&gt; activeRules;
    private Collection&lt;ActiveRuleParamDto&gt; activeRuleParams;
    private DescendantProfilesSupplier descendantProfilesSupplier;

    Builder setDate(long l) {
<span class="fc" id="L268">      this.date = l;</span>
<span class="fc" id="L269">      return this;</span>
    }

    Builder setPreviousBuiltinActiveRuleUuids(Set&lt;String&gt; previousBuiltinActiveRuleUuids) {
<span class="fc" id="L273">      this.previousBuiltinActiveRuleUuids = previousBuiltinActiveRuleUuids;</span>
<span class="fc" id="L274">      return this;</span>
    }

    Builder setBaseProfile(RulesProfileDto p) {
<span class="fc" id="L278">      this.baseRulesProfile = p;</span>
<span class="fc" id="L279">      return this;</span>
    }

    Builder setRules(Collection&lt;RuleDto&gt; rules) {
<span class="fc" id="L283">      this.rules = rules;</span>
<span class="fc" id="L284">      return this;</span>
    }

    Builder setRuleParams(Collection&lt;RuleParamDto&gt; ruleParams) {
<span class="fc" id="L288">      this.ruleParams = ruleParams;</span>
<span class="fc" id="L289">      return this;</span>
    }

    /**
     * All the profiles involved in the activation workflow, including the
     * parent profile, even if it's not updated.
     */
    Builder setProfiles(Collection&lt;QProfileDto&gt; profiles) {
<span class="fc" id="L297">      this.profiles = profiles;</span>
<span class="fc" id="L298">      return this;</span>
    }

    Builder setActiveRules(Collection&lt;ActiveRuleDto&gt; activeRules) {
<span class="fc" id="L302">      this.activeRules = activeRules;</span>
<span class="fc" id="L303">      return this;</span>
    }

    Builder setActiveRuleParams(Collection&lt;ActiveRuleParamDto&gt; activeRuleParams) {
<span class="fc" id="L307">      this.activeRuleParams = activeRuleParams;</span>
<span class="fc" id="L308">      return this;</span>
    }

    Builder setDescendantProfilesSupplier(DescendantProfilesSupplier d) {
<span class="fc" id="L312">      this.descendantProfilesSupplier = d;</span>
<span class="fc" id="L313">      return this;</span>
    }

    RuleActivationContext build() {
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">      checkArgument(date &gt; 0, &quot;date is not set&quot;);</span>
<span class="fc" id="L318">      requireNonNull(baseRulesProfile, &quot;baseRulesProfile is null&quot;);</span>
<span class="fc" id="L319">      requireNonNull(rules, &quot;rules is null&quot;);</span>
<span class="fc" id="L320">      requireNonNull(ruleParams, &quot;ruleParams is null&quot;);</span>
<span class="fc" id="L321">      requireNonNull(profiles, &quot;profiles is null&quot;);</span>
<span class="fc" id="L322">      requireNonNull(activeRules, &quot;activeRules is null&quot;);</span>
<span class="fc" id="L323">      requireNonNull(activeRuleParams, &quot;activeRuleParams is null&quot;);</span>
<span class="fc" id="L324">      requireNonNull(descendantProfilesSupplier, &quot;descendantProfilesSupplier is null&quot;);</span>
<span class="fc" id="L325">      return new RuleActivationContext(this);</span>
    }
  }

  public static final class RuleWrapper {
    private final RuleDto rule;
    private final Map&lt;String, RuleParamDto&gt; paramsByKey;

<span class="fc" id="L333">    private RuleWrapper(RuleDto rule, Collection&lt;RuleParamDto&gt; params) {</span>
<span class="fc" id="L334">      this.rule = rule;</span>
<span class="fc" id="L335">      this.paramsByKey = params.stream().collect(Collectors.toMap(RuleParamDto::getName, Function.identity()));</span>
<span class="fc" id="L336">    }</span>

    public RuleDto get() {
<span class="fc" id="L339">      return rule;</span>
    }

    Collection&lt;RuleParamDto&gt; getParams() {
<span class="fc" id="L343">      return paramsByKey.values();</span>
    }

    @CheckForNull
    RuleParamDto getParam(String key) {
<span class="fc" id="L348">      return paramsByKey.get(key);</span>
    }

    @CheckForNull
    String getParamDefaultValue(String key) {
<span class="fc" id="L353">      RuleParamDto param = getParam(key);</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">      return param != null ? param.getDefaultValue() : null;</span>
    }
  }

  static final class ActiveRuleWrapper {
    private final ActiveRuleDto activeRule;
    private final Map&lt;String, ActiveRuleParamDto&gt; paramsByKey;

<span class="fc" id="L362">    private ActiveRuleWrapper(ActiveRuleDto activeRule, Collection&lt;ActiveRuleParamDto&gt; params) {</span>
<span class="fc" id="L363">      this.activeRule = activeRule;</span>
<span class="fc" id="L364">      this.paramsByKey = params.stream().collect(Collectors.toMap(ActiveRuleParamDto::getKey, Function.identity()));</span>
<span class="fc" id="L365">    }</span>

    ActiveRuleDto get() {
<span class="fc" id="L368">      return activeRule;</span>
    }

    Collection&lt;ActiveRuleParamDto&gt; getParams() {
<span class="fc" id="L372">      return paramsByKey.values();</span>
    }

    @CheckForNull
    ActiveRuleParamDto getParam(String key) {
<span class="fc" id="L377">      return paramsByKey.get(key);</span>
    }

    @CheckForNull
    String getParamValue(String key) {
<span class="fc" id="L382">      ActiveRuleParamDto param = paramsByKey.get(key);</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">      return param != null ? param.getValue() : null;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>