<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StickyFacetBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.server.es</a> &gt; <span class="el_source">StickyFacetBuilder.java</span></div><h1>StickyFacetBuilder.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.server.es;

import java.util.Arrays;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import org.apache.commons.lang3.ArrayUtils;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.QueryBuilder;
import org.elasticsearch.search.aggregations.AbstractAggregationBuilder;
import org.elasticsearch.search.aggregations.AggregationBuilder;
import org.elasticsearch.search.aggregations.AggregationBuilders;
import org.elasticsearch.search.aggregations.BucketOrder;
import org.elasticsearch.search.aggregations.bucket.filter.FilterAggregationBuilder;
import org.elasticsearch.search.aggregations.bucket.terms.IncludeExclude;
import org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder;

import static java.lang.Math.max;
import static org.elasticsearch.index.query.QueryBuilders.boolQuery;

public class StickyFacetBuilder {

  private static final int FACET_DEFAULT_MIN_DOC_COUNT = 1;
  public static final int FACET_DEFAULT_SIZE = 10;
<span class="fc" id="L47">  private static final BucketOrder FACET_DEFAULT_ORDER = BucketOrder.count(false);</span>
  /** In some cases the user selects &gt;15 items for one facet. In that case, we want to calculate the doc count for all of them (not just the first 15 items, which would be the
   * default for the TermsAggregation). */
  private static final int MAXIMUM_NUMBER_OF_SELECTED_ITEMS_WHOSE_DOC_COUNT_WILL_BE_CALCULATED = 50;
<span class="fc" id="L51">  private static final Collector&lt;CharSequence, ?, String&gt; PIPE_JOINER = Collectors.joining(&quot;|&quot;);</span>

  private final QueryBuilder query;
  private final Map&lt;String, QueryBuilder&gt; filters;
  private final AbstractAggregationBuilder subAggregation;
  private final BucketOrder order;

  public StickyFacetBuilder(QueryBuilder query, Map&lt;String, QueryBuilder&gt; filters) {
<span class="nc" id="L59">    this(query, filters, null, FACET_DEFAULT_ORDER);</span>
<span class="nc" id="L60">  }</span>

<span class="fc" id="L62">  public StickyFacetBuilder(QueryBuilder query, Map&lt;String, QueryBuilder&gt; filters, @Nullable AbstractAggregationBuilder subAggregation, @Nullable BucketOrder order) {</span>
<span class="fc" id="L63">    this.query = query;</span>
<span class="fc" id="L64">    this.filters = filters;</span>
<span class="fc" id="L65">    this.subAggregation = subAggregation;</span>
<span class="fc" id="L66">    this.order = order;</span>
<span class="fc" id="L67">  }</span>

  public AggregationBuilder buildStickyFacet(String fieldName, String facetName, Object... selected) {
<span class="fc" id="L70">    return buildStickyFacet(fieldName, facetName, FACET_DEFAULT_SIZE, t -&gt; t, selected);</span>
  }

  public AggregationBuilder buildStickyFacet(String fieldName, String facetName, int size, Object... selected) {
<span class="fc" id="L74">    return buildStickyFacet(fieldName, facetName, size, t -&gt; t, selected);</span>
  }

  /**
   * Creates an aggregation, that will return the top-terms for &lt;code&gt;fieldName&lt;/code&gt;.
   *
   * It will filter according to the filters of every of the &lt;em&gt;other&lt;/em&gt; fields, but will not apply filters to &lt;em&gt;this&lt;/em&gt; field (so that the user can see all terms, even
   * after having chosen for one of the terms).
   *
   * If special filtering is required (like for nested types), additional functionality can be passed into the method in the &lt;code&gt;additionalAggregationFilter&lt;/code&gt; parameter.
   *
   * @param fieldName the name of the field that contains the terms
   * @param facetName the name of the aggregation (use this for to find the corresponding results in the response)
   * @param size number of facet items
   * @param additionalAggregationFilter additional features (like filtering using childQuery)
   * @param selected the terms, that the user already has selected
   * @return the (global) aggregation, that can be added on top level of the elasticsearch request
   */
  public AggregationBuilder buildStickyFacet(String fieldName, String facetName, int size, Function&lt;TermsAggregationBuilder, AggregationBuilder&gt; additionalAggregationFilter,
    Object... selected) {
<span class="fc" id="L94">    BoolQueryBuilder facetFilter = getStickyFacetFilter(fieldName);</span>
<span class="fc" id="L95">    FilterAggregationBuilder facetTopAggregation = buildTopFacetAggregation(fieldName, facetName, facetFilter, size, additionalAggregationFilter);</span>
<span class="fc" id="L96">    facetTopAggregation = addSelectedItemsToFacet(fieldName, facetName, facetTopAggregation, additionalAggregationFilter, selected);</span>

<span class="fc" id="L98">    return AggregationBuilders</span>
<span class="fc" id="L99">      .global(facetName)</span>
<span class="fc" id="L100">      .subAggregation(facetTopAggregation);</span>
  }

  public AggregationBuilder buildNestedAggregationStickyFacet(String parentFieldName, String childFieldName, String facetName, AggregationBuilder additionalAggregationFilter) {
<span class="fc" id="L104">    BoolQueryBuilder facetFilter = getStickyFacetFilter(parentFieldName + &quot;.&quot; + childFieldName, parentFieldName);</span>
<span class="fc" id="L105">    return AggregationBuilders</span>
<span class="fc" id="L106">      .global(facetName)</span>
<span class="fc" id="L107">      .subAggregation(AggregationBuilders</span>
<span class="fc" id="L108">        .filter(facetName + &quot;_filter&quot;, facetFilter)</span>
<span class="fc" id="L109">        .subAggregation(additionalAggregationFilter));</span>
  }

  public BoolQueryBuilder getStickyFacetFilter(String... fieldNames) {
<span class="fc" id="L113">    BoolQueryBuilder facetFilter = boolQuery().must(query);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">    for (Map.Entry&lt;String, QueryBuilder&gt; filter : filters.entrySet()) {</span>
<span class="pc bpc" id="L115" title="1 of 4 branches missed.">      if (filter.getValue() != null &amp;&amp; !ArrayUtils.contains(fieldNames, filter.getKey())) {</span>
<span class="fc" id="L116">        facetFilter.must(filter.getValue());</span>
      }
<span class="fc" id="L118">    }</span>
<span class="fc" id="L119">    return facetFilter;</span>
  }

  private FilterAggregationBuilder buildTopFacetAggregation(String fieldName, String facetName, BoolQueryBuilder facetFilter, int size,
    Function&lt;TermsAggregationBuilder, AggregationBuilder&gt; additionalAggregationFilter) {
<span class="fc" id="L124">    TermsAggregationBuilder termsAggregation = buildTermsFacetAggregation(fieldName, facetName, size);</span>
<span class="fc" id="L125">    AggregationBuilder improvedAggregation = additionalAggregationFilter.apply(termsAggregation);</span>
<span class="fc" id="L126">    return AggregationBuilders</span>
<span class="fc" id="L127">      .filter(facetName + &quot;_filter&quot;, facetFilter)</span>
<span class="fc" id="L128">      .subAggregation(improvedAggregation);</span>
  }

  private TermsAggregationBuilder buildTermsFacetAggregation(String fieldName, String facetName, int size) {
<span class="fc" id="L132">    TermsAggregationBuilder termsAggregation = AggregationBuilders.terms(facetName)</span>
<span class="fc" id="L133">      .field(fieldName)</span>
<span class="fc" id="L134">      .order(order)</span>
<span class="fc" id="L135">      .size(size)</span>
<span class="fc" id="L136">      .minDocCount(FACET_DEFAULT_MIN_DOC_COUNT);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">    if (subAggregation != null) {</span>
<span class="nc" id="L138">      termsAggregation = termsAggregation.subAggregation(subAggregation);</span>
    }
<span class="fc" id="L140">    return termsAggregation;</span>
  }

  public FilterAggregationBuilder addSelectedItemsToFacet(String fieldName, String facetName, FilterAggregationBuilder facetTopAggregation,
    Function&lt;TermsAggregationBuilder, AggregationBuilder&gt; additionalAggregationFilter, Object... selected) {
<span class="fc bfc" id="L145" title="All 2 branches covered.">    if (selected.length &lt;= 0) {</span>
<span class="fc" id="L146">      return facetTopAggregation;</span>
    }
<span class="fc" id="L148">    String includes = Arrays.stream(selected)</span>
<span class="fc" id="L149">      .filter(Objects::nonNull)</span>
<span class="fc" id="L150">      .map(s -&gt; EsUtils.escapeSpecialRegexChars(s.toString()))</span>
<span class="fc" id="L151">      .collect(PIPE_JOINER);</span>

<span class="fc" id="L153">    TermsAggregationBuilder selectedTerms = AggregationBuilders.terms(facetName + &quot;_selected&quot;)</span>
<span class="fc" id="L154">      .size(max(MAXIMUM_NUMBER_OF_SELECTED_ITEMS_WHOSE_DOC_COUNT_WILL_BE_CALCULATED, includes.length()))</span>
<span class="fc" id="L155">      .field(fieldName)</span>
<span class="fc" id="L156">      .includeExclude(new IncludeExclude(includes, null));</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">    if (subAggregation != null) {</span>
<span class="nc" id="L158">      selectedTerms = selectedTerms.subAggregation(subAggregation);</span>
    }

<span class="fc" id="L161">    AggregationBuilder improvedAggregation = additionalAggregationFilter.apply(selectedTerms);</span>
<span class="fc" id="L162">    facetTopAggregation.subAggregation(improvedAggregation);</span>
<span class="fc" id="L163">    return facetTopAggregation;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>