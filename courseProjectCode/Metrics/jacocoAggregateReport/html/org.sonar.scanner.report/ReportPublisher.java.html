<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReportPublisher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sonarqube</a> &gt; <a href="index.source.html" class="el_package">org.sonar.scanner.report</a> &gt; <span class="el_source">ReportPublisher.java</span></div><h1>ReportPublisher.java</h1><pre class="source lang-java linenums">/*
 * SonarQube
 * Copyright (C) 2009-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package org.sonar.scanner.report;

import com.google.common.annotations.VisibleForTesting;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.LinkedHashMap;
import java.util.Map;
import javax.annotation.Nullable;
import okhttp3.HttpUrl;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.Startable;
import org.sonar.api.notifications.AnalysisWarnings;
import org.sonar.api.platform.Server;
import org.sonar.api.utils.MessageException;
import org.sonar.api.utils.TempFolder;
import org.sonar.api.utils.ZipUtils;
import org.sonar.core.ce.CeTaskCharacteristics;
import org.sonar.scanner.bootstrap.GlobalAnalysisMode;
import org.sonar.scanner.ci.CiConfiguration;
import org.sonar.scanner.fs.InputModuleHierarchy;
import org.sonar.scanner.http.DefaultScannerWsClient;
import org.sonar.scanner.protocol.output.FileStructure;
import org.sonar.scanner.protocol.output.ScannerReportReader;
import org.sonar.scanner.protocol.output.ScannerReportWriter;
import org.sonar.scanner.scan.ScanProperties;
import org.sonar.scanner.scan.branch.BranchConfiguration;
import org.sonar.scanner.scan.branch.BranchType;
import org.sonarqube.ws.Ce;
import org.sonarqube.ws.MediaTypes;
import org.sonarqube.ws.client.HttpException;
import org.sonarqube.ws.client.PostRequest;
import org.sonarqube.ws.client.RequestWithPayload.Part;
import org.sonarqube.ws.client.WsResponse;

import static java.net.URLEncoder.encode;
import static org.apache.commons.lang3.StringUtils.EMPTY;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.sonar.core.ce.CeTaskCharacteristics.BRANCH_TYPE;
import static org.sonar.core.ce.CeTaskCharacteristics.DEVOPS_PLATFORM_PROJECT_IDENTIFIER;
import static org.sonar.core.ce.CeTaskCharacteristics.DEVOPS_PLATFORM_URL;
import static org.sonar.core.util.FileUtils.deleteQuietly;
import static org.sonar.core.util.FileUtils.humanReadableByteCountSI;
import static org.sonar.scanner.scan.branch.BranchType.PULL_REQUEST;

public class ReportPublisher implements Startable {
<span class="fc" id="L74">  private static final Logger LOG = LoggerFactory.getLogger(ReportPublisher.class);</span>
  private static final String CHARACTERISTIC = &quot;characteristic&quot;;
  private static final String DASHBOARD = &quot;dashboard&quot;;
  private static final String BRANCH = &quot;branch&quot;;
  private static final String ID = &quot;id&quot;;

  @VisibleForTesting
  static final String SUPPORT_OF_32_BIT_JRE_IS_DEPRECATED_MESSAGE = &quot;You are using a 32 bits JRE. &quot;
    + &quot;The support of 32 bits JRE is deprecated and a future version of the scanner will remove it completely.&quot;;

  private final DefaultScannerWsClient wsClient;
  private final AnalysisContextReportPublisher contextPublisher;
  private final InputModuleHierarchy moduleHierarchy;
  private final GlobalAnalysisMode analysisMode;
  private final TempFolder temp;
  private final ReportPublisherStep[] publishers;
  private final Server server;
  private final BranchConfiguration branchConfiguration;
  private final ScanProperties properties;
  private final CeTaskReportDataHolder ceTaskReportDataHolder;

  private final Path reportDir;
  private final ScannerReportWriter writer;
  private final ScannerReportReader reader;
  private final AnalysisWarnings analysisWarnings;
  private final JavaArchitectureInformationProvider javaArchitectureInformationProvider;

  private final CiConfiguration ciConfiguration;

  public ReportPublisher(ScanProperties properties, DefaultScannerWsClient wsClient, Server server, AnalysisContextReportPublisher contextPublisher,
    InputModuleHierarchy moduleHierarchy, GlobalAnalysisMode analysisMode, TempFolder temp, ReportPublisherStep[] publishers, BranchConfiguration branchConfiguration,
    CeTaskReportDataHolder ceTaskReportDataHolder, AnalysisWarnings analysisWarnings,
<span class="fc" id="L106">    JavaArchitectureInformationProvider javaArchitectureInformationProvider, FileStructure fileStructure, CiConfiguration ciConfiguration) {</span>
<span class="fc" id="L107">    this.wsClient = wsClient;</span>
<span class="fc" id="L108">    this.server = server;</span>
<span class="fc" id="L109">    this.contextPublisher = contextPublisher;</span>
<span class="fc" id="L110">    this.moduleHierarchy = moduleHierarchy;</span>
<span class="fc" id="L111">    this.analysisMode = analysisMode;</span>
<span class="fc" id="L112">    this.temp = temp;</span>
<span class="fc" id="L113">    this.publishers = publishers;</span>
<span class="fc" id="L114">    this.branchConfiguration = branchConfiguration;</span>
<span class="fc" id="L115">    this.properties = properties;</span>
<span class="fc" id="L116">    this.ceTaskReportDataHolder = ceTaskReportDataHolder;</span>
<span class="fc" id="L117">    this.reportDir = fileStructure.root().toPath();</span>
<span class="fc" id="L118">    this.analysisWarnings = analysisWarnings;</span>
<span class="fc" id="L119">    this.javaArchitectureInformationProvider = javaArchitectureInformationProvider;</span>
<span class="fc" id="L120">    this.writer = new ScannerReportWriter(fileStructure);</span>
<span class="fc" id="L121">    this.reader = new ScannerReportReader(fileStructure);</span>
<span class="fc" id="L122">    this.ciConfiguration = ciConfiguration;</span>
<span class="fc" id="L123">  }</span>

  @Override
  public void start() {
<span class="fc" id="L127">    contextPublisher.init(writer);</span>

<span class="fc bfc" id="L129" title="All 2 branches covered.">    if (!analysisMode.isMediumTest()) {</span>
<span class="fc" id="L130">      String publicUrl = server.getPublicRootUrl();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">      if (HttpUrl.parse(publicUrl) == null) {</span>
<span class="fc" id="L132">        throw MessageException.of(&quot;Failed to parse public URL set in SonarQube server: &quot; + publicUrl);</span>
      }
    }
<span class="fc" id="L135">  }</span>

  @Override
  public void stop() {
<span class="fc bfc" id="L139" title="All 2 branches covered.">    if (!properties.shouldKeepReport()) {</span>
<span class="fc" id="L140">      deleteQuietly(reportDir);</span>
    }
<span class="fc" id="L142">  }</span>

  public Path getReportDir() {
<span class="nc" id="L145">    return reportDir;</span>
  }

  public ScannerReportWriter getWriter() {
<span class="fc" id="L149">    return writer;</span>
  }

  public ScannerReportReader getReader() {
<span class="fc" id="L153">    return reader;</span>
  }

  public void execute() {
<span class="fc" id="L157">    logDeprecationWarningIf32bitJava();</span>
<span class="fc" id="L158">    File report = generateReportFile();</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">    if (properties.shouldKeepReport()) {</span>
<span class="fc" id="L160">      LOG.info(&quot;Analysis report generated in {}&quot;, reportDir);</span>
    }
<span class="fc bfc" id="L162" title="All 2 branches covered.">    if (!analysisMode.isMediumTest()) {</span>
<span class="fc" id="L163">      String taskId = upload(report);</span>
<span class="fc" id="L164">      prepareAndDumpMetadata(taskId);</span>
    }

<span class="fc" id="L167">    logSuccess();</span>
<span class="fc" id="L168">  }</span>

  private void logDeprecationWarningIf32bitJava() {
<span class="fc bfc" id="L171" title="All 2 branches covered.">    if (!javaArchitectureInformationProvider.is64bitJavaVersion()) {</span>
<span class="fc" id="L172">      analysisWarnings.addUnique(SUPPORT_OF_32_BIT_JRE_IS_DEPRECATED_MESSAGE);</span>
<span class="fc" id="L173">      LOG.warn(SUPPORT_OF_32_BIT_JRE_IS_DEPRECATED_MESSAGE);</span>
    }
<span class="fc" id="L175">  }</span>

  private File generateReportFile() {
    try {
<span class="fc" id="L179">      long startTime = System.currentTimeMillis();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">      for (ReportPublisherStep publisher : publishers) {</span>
<span class="fc" id="L181">        publisher.publish(writer);</span>
      }
<span class="fc" id="L183">      long stopTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">      if (LOG.isInfoEnabled()) {</span>
<span class="fc" id="L185">        LOG.info(&quot;Analysis report generated in {}ms, dir size={}&quot;, stopTime - startTime, humanReadableByteCountSI(FileUtils.sizeOfDirectory(reportDir.toFile())));</span>
      }

<span class="fc" id="L188">      startTime = System.currentTimeMillis();</span>
<span class="fc" id="L189">      File reportZip = temp.newFile(&quot;scanner-report&quot;, &quot;.zip&quot;);</span>
<span class="fc" id="L190">      ZipUtils.zipDir(reportDir.toFile(), reportZip);</span>
<span class="fc" id="L191">      stopTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">      if (LOG.isInfoEnabled()) {</span>
<span class="fc" id="L193">        LOG.info(&quot;Analysis report compressed in {}ms, zip size={}&quot;, stopTime - startTime, humanReadableByteCountSI(FileUtils.sizeOf(reportZip)));</span>
      }
<span class="fc" id="L195">      return reportZip;</span>
<span class="nc" id="L196">    } catch (IOException e) {</span>
<span class="nc" id="L197">      throw new IllegalStateException(&quot;Unable to prepare analysis report&quot;, e);</span>
    }
  }

  private void logSuccess() {
<span class="fc bfc" id="L202" title="All 2 branches covered.">    if (analysisMode.isMediumTest()) {</span>
<span class="fc" id="L203">      LOG.info(&quot;ANALYSIS SUCCESSFUL&quot;);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">    } else if (!properties.shouldWaitForQualityGate()) {</span>
<span class="fc" id="L205">      LOG.info(&quot;ANALYSIS SUCCESSFUL, you can find the results at: {}&quot;, ceTaskReportDataHolder.getDashboardUrl());</span>
<span class="fc" id="L206">      LOG.info(&quot;Note that you will be able to access the updated dashboard once the server has processed the submitted analysis report&quot;);</span>
<span class="fc" id="L207">      LOG.info(&quot;More about the report processing at {}&quot;, ceTaskReportDataHolder.getCeTaskUrl());</span>
    }
<span class="fc" id="L209">  }</span>

  /**
   * Uploads the report file to server and returns the generated task id
   */
  String upload(File report) {
<span class="fc" id="L215">    LOG.debug(&quot;Upload report&quot;);</span>
<span class="fc" id="L216">    long startTime = System.currentTimeMillis();</span>
<span class="fc" id="L217">    Part filePart = new Part(MediaTypes.ZIP, report);</span>
<span class="fc" id="L218">    PostRequest post = new PostRequest(&quot;api/ce/submit&quot;)</span>
<span class="fc" id="L219">      .setMediaType(MediaTypes.PROTOBUF)</span>
<span class="fc" id="L220">      .setParam(&quot;projectKey&quot;, moduleHierarchy.root().key())</span>
<span class="fc" id="L221">      .setParam(&quot;projectName&quot;, moduleHierarchy.root().getOriginalName())</span>
<span class="fc" id="L222">      .setPart(&quot;report&quot;, filePart);</span>

<span class="fc" id="L224">    ciConfiguration.getDevOpsPlatformInfo().ifPresent(devOpsPlatformInfo -&gt; {</span>
<span class="fc" id="L225">      post.setParam(CHARACTERISTIC, buildCharacteristicParam(DEVOPS_PLATFORM_URL, devOpsPlatformInfo.getUrl()));</span>
<span class="fc" id="L226">      post.setParam(CHARACTERISTIC, buildCharacteristicParam(DEVOPS_PLATFORM_PROJECT_IDENTIFIER, devOpsPlatformInfo.getProjectIdentifier()));</span>
<span class="fc" id="L227">    });</span>
<span class="fc" id="L228">    String branchName = branchConfiguration.branchName();</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (branchName != null) {</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">      if (branchConfiguration.branchType() != PULL_REQUEST) {</span>
<span class="fc" id="L231">        post.setParam(CHARACTERISTIC, buildCharacteristicParam(CeTaskCharacteristics.BRANCH, branchName));</span>
<span class="fc" id="L232">        post.setParam(CHARACTERISTIC, buildCharacteristicParam(BRANCH_TYPE, branchConfiguration.branchType().name()));</span>
      } else {
<span class="fc" id="L234">        post.setParam(CHARACTERISTIC, buildCharacteristicParam(CeTaskCharacteristics.PULL_REQUEST, branchConfiguration.pullRequestKey()));</span>
      }
    }

    WsResponse response;
    try {
<span class="fc" id="L240">      post.setWriteTimeOutInMs(properties.reportPublishTimeout() * 1000);</span>
<span class="fc" id="L241">      response = wsClient.call(post);</span>
<span class="fc" id="L242">    } catch (Exception e) {</span>
<span class="fc" id="L243">      throw new IllegalStateException(&quot;Failed to upload report: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L244">    }</span>

    try {
<span class="fc" id="L247">      response.failIfNotSuccessful();</span>
<span class="fc" id="L248">    } catch (HttpException e) {</span>
<span class="fc" id="L249">      throw MessageException.of(String.format(&quot;Server failed to process report. Please check server logs: %s&quot;, DefaultScannerWsClient.createErrorMessage(e)));</span>
<span class="fc" id="L250">    }</span>
<span class="fc" id="L251">    try (InputStream protobuf = response.contentStream()) {</span>
<span class="fc" id="L252">      return Ce.SubmitResponse.parser().parseFrom(protobuf).getTaskId();</span>
<span class="nc" id="L253">    } catch (Exception e) {</span>
<span class="nc" id="L254">      throw new RuntimeException(e);</span>
    } finally {
<span class="fc" id="L256">      long stopTime = System.currentTimeMillis();</span>
<span class="fc" id="L257">      LOG.info(&quot;Analysis report uploaded in {}ms&quot;, (stopTime - startTime));</span>
    }
  }

  private static String buildCharacteristicParam(String characteristic, String value) {
<span class="fc" id="L262">    return characteristic + &quot;=&quot; + value;</span>
  }

  void prepareAndDumpMetadata(String taskId) {
<span class="fc" id="L266">    Map&lt;String, String&gt; metadata = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L268">    metadata.put(&quot;projectKey&quot;, moduleHierarchy.root().key());</span>
<span class="fc" id="L269">    metadata.put(&quot;serverUrl&quot;, server.getPublicRootUrl());</span>
<span class="fc" id="L270">    metadata.put(&quot;serverVersion&quot;, server.getVersion());</span>
<span class="pc" id="L271">    properties.branch().ifPresent(branch -&gt; metadata.put(&quot;branch&quot;, branch));</span>

<span class="fc" id="L273">    URL dashboardUrl = buildDashboardUrl(server.getPublicRootUrl(), moduleHierarchy.root().key());</span>
<span class="fc" id="L274">    metadata.put(&quot;dashboardUrl&quot;, dashboardUrl.toExternalForm());</span>

<span class="fc" id="L276">    URL taskUrl = HttpUrl.parse(server.getPublicRootUrl()).newBuilder()</span>
<span class="fc" id="L277">      .addPathSegment(&quot;api&quot;).addPathSegment(&quot;ce&quot;).addPathSegment(&quot;task&quot;)</span>
<span class="fc" id="L278">      .addQueryParameter(ID, taskId)</span>
<span class="fc" id="L279">      .build()</span>
<span class="fc" id="L280">      .url();</span>
<span class="fc" id="L281">    metadata.put(&quot;ceTaskId&quot;, taskId);</span>
<span class="fc" id="L282">    metadata.put(&quot;ceTaskUrl&quot;, taskUrl.toExternalForm());</span>

<span class="fc" id="L284">    ceTaskReportDataHolder.init(taskId, taskUrl.toExternalForm(), dashboardUrl.toExternalForm());</span>
<span class="fc" id="L285">    dumpMetadata(metadata);</span>
<span class="fc" id="L286">  }</span>

  private URL buildDashboardUrl(String publicUrl, String effectiveKey) {
<span class="fc" id="L289">    HttpUrl httpUrl = HttpUrl.parse(publicUrl);</span>

<span class="fc bfc" id="L291" title="All 2 branches covered.">    if (onPullRequest(branchConfiguration)) {</span>
<span class="fc" id="L292">      return httpUrl.newBuilder()</span>
<span class="fc" id="L293">        .addPathSegment(DASHBOARD)</span>
<span class="fc" id="L294">        .addEncodedQueryParameter(ID, encoded(effectiveKey))</span>
<span class="fc" id="L295">        .addEncodedQueryParameter(&quot;pullRequest&quot;, encoded(branchConfiguration.pullRequestKey()))</span>
<span class="fc" id="L296">        .build()</span>
<span class="fc" id="L297">        .url();</span>
    }

<span class="fc bfc" id="L300" title="All 2 branches covered.">    if (onBranch(branchConfiguration)) {</span>
<span class="fc" id="L301">      return httpUrl.newBuilder()</span>
<span class="fc" id="L302">        .addPathSegment(DASHBOARD)</span>
<span class="fc" id="L303">        .addEncodedQueryParameter(ID, encoded(effectiveKey))</span>
<span class="fc" id="L304">        .addEncodedQueryParameter(BRANCH, encoded(branchConfiguration.branchName()))</span>
<span class="fc" id="L305">        .build()</span>
<span class="fc" id="L306">        .url();</span>
    }

<span class="pc bpc" id="L309" title="1 of 2 branches missed.">    if (onMainBranch(branchConfiguration)) {</span>
<span class="fc" id="L310">      return httpUrl.newBuilder()</span>
<span class="fc" id="L311">        .addPathSegment(DASHBOARD)</span>
<span class="fc" id="L312">        .addEncodedQueryParameter(ID, encoded(effectiveKey))</span>
<span class="fc" id="L313">        .build()</span>
<span class="fc" id="L314">        .url();</span>
    }

<span class="nc" id="L317">    return httpUrl.newBuilder().build().url();</span>
  }

  private static boolean onPullRequest(BranchConfiguration branchConfiguration) {
<span class="fc bfc" id="L321" title="All 4 branches covered.">    return branchConfiguration.branchName() != null &amp;&amp; (branchConfiguration.branchType() == PULL_REQUEST);</span>
  }

  private static boolean onBranch(BranchConfiguration branchConfiguration) {
<span class="pc bpc" id="L325" title="1 of 4 branches missed.">    return branchConfiguration.branchName() != null &amp;&amp; (branchConfiguration.branchType() == BranchType.BRANCH);</span>
  }

  private static boolean onMainBranch(BranchConfiguration branchConfiguration) {
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">    return branchConfiguration.branchName() == null;</span>
  }

  private static String encoded(@Nullable String queryParameter) {
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">    if (isBlank(queryParameter)) {</span>
<span class="nc" id="L334">      return EMPTY;</span>
    }
    try {
<span class="fc" id="L337">      return encode(queryParameter, StandardCharsets.UTF_8.name());</span>
<span class="nc" id="L338">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L339">      throw new IllegalStateException(&quot;Unable to urlencode &quot; + queryParameter, e);</span>
    }
  }

  private void dumpMetadata(Map&lt;String, String&gt; metadata) {
<span class="fc" id="L344">    Path file = properties.metadataFilePath();</span>
    try {
<span class="fc" id="L346">      Files.createDirectories(file.getParent());</span>
<span class="fc" id="L347">      try (Writer output = Files.newBufferedWriter(file, StandardCharsets.UTF_8)) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (Map.Entry&lt;String, String&gt; entry : metadata.entrySet()) {</span>
<span class="fc" id="L349">          output.write(entry.getKey());</span>
<span class="fc" id="L350">          output.write(&quot;=&quot;);</span>
<span class="fc" id="L351">          output.write(entry.getValue());</span>
<span class="fc" id="L352">          output.write(&quot;\n&quot;);</span>
<span class="fc" id="L353">        }</span>
      }

<span class="fc" id="L356">      LOG.debug(&quot;Report metadata written to {}&quot;, file);</span>
<span class="nc" id="L357">    } catch (IOException e) {</span>
<span class="nc" id="L358">      throw new IllegalStateException(&quot;Unable to dump &quot; + file, e);</span>
<span class="fc" id="L359">    }</span>
<span class="fc" id="L360">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>